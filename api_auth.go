/*
HashiCorp Vault API

HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.

API version: 1.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package vault

import (
	"context"
	"net/http"
	"net/url"
	"strings"
)

// Auth is a simple wrapper around the client for Auth requests
type Auth struct {
	client *Client
}

// DeleteAuthAlicloudRoleRole Create a role and associate policies to it.
// role: The name of the role as it should appear in Vault.
func (a *Auth) DeleteAuthAlicloudRoleRole(ctx context.Context, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/alicloud/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAppIdMapAppIdKey Read/write/delete a single app-id mapping
// key: Key for the app-id mapping
func (a *Auth) DeleteAuthAppIdMapAppIdKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/app-id/map/app-id/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAppIdMapUserIdKey Read/write/delete a single user-id mapping
// key: Key for the user-id mapping
func (a *Auth) DeleteAuthAppIdMapUserIdKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/app-id/map/user-id/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleName Register an role with the backend.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleName(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleNameBindSecretId Impose secret_id to be presented during login using this role.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameBindSecretId(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/bind-secret-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleNameBoundCidrList Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameBoundCidrList(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/bound-cidr-list"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleNamePeriod Updates the value of 'period' on the role
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNamePeriod(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/period"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleNamePolicies Policies of the role.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNamePolicies(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/policies"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroy
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroy(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-accessor/destroy"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleNameSecretIdBoundCidrs Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameSecretIdBoundCidrs(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-bound-cidrs"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleNameSecretIdDestroy Invalidate an issued secret_id
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameSecretIdDestroy(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id/destroy"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleNameSecretIdNumUses Use limit of the SecretID generated against the role.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameSecretIdNumUses(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-num-uses"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleNameSecretIdTtl Duration in seconds, representing the lifetime of the SecretIDs that are generated against the role using 'role/<role_name>/secret-id' or 'role/<role_name>/custom-secret-id' endpoints.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameSecretIdTtl(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleNameTokenBoundCidrs Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameTokenBoundCidrs(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-bound-cidrs"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleNameTokenMaxTtl Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameTokenMaxTtl(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-max-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleNameTokenNumUses Number of times issued tokens can be used
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameTokenNumUses(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-num-uses"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthApproleRoleRoleNameTokenTtl Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameTokenTtl(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAwsConfigCertificateCertName
// certName: Name of the certificate.
func (a *Auth) DeleteAuthAwsConfigCertificateCertName(ctx context.Context, certName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/certificate/{cert_name}"
	requestPath = strings.Replace(requestPath, "{"+"cert_name"+"}", url.PathEscape(certName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAwsConfigClient
func (a *Auth) DeleteAuthAwsConfigClient(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/client"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAwsConfigStsAccountId
// accountId: AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.
func (a *Auth) DeleteAuthAwsConfigStsAccountId(ctx context.Context, accountId string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/sts/{account_id}"
	requestPath = strings.Replace(requestPath, "{"+"account_id"+"}", url.PathEscape(accountId), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAwsConfigTidyIdentityAccesslist
func (a *Auth) DeleteAuthAwsConfigTidyIdentityAccesslist(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/tidy/identity-accesslist"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAwsConfigTidyIdentityWhitelist
func (a *Auth) DeleteAuthAwsConfigTidyIdentityWhitelist(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/tidy/identity-whitelist"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAwsConfigTidyRoletagBlacklist
func (a *Auth) DeleteAuthAwsConfigTidyRoletagBlacklist(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/tidy/roletag-blacklist"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAwsConfigTidyRoletagDenylist
func (a *Auth) DeleteAuthAwsConfigTidyRoletagDenylist(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/tidy/roletag-denylist"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAwsIdentityAccesslistInstanceId
// instanceId: EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.
func (a *Auth) DeleteAuthAwsIdentityAccesslistInstanceId(ctx context.Context, instanceId string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/identity-accesslist/{instance_id}"
	requestPath = strings.Replace(requestPath, "{"+"instance_id"+"}", url.PathEscape(instanceId), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAwsIdentityWhitelistInstanceId
// instanceId: EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.
func (a *Auth) DeleteAuthAwsIdentityWhitelistInstanceId(ctx context.Context, instanceId string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/identity-whitelist/{instance_id}"
	requestPath = strings.Replace(requestPath, "{"+"instance_id"+"}", url.PathEscape(instanceId), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAwsRoleRole
// role: Name of the role.
func (a *Auth) DeleteAuthAwsRoleRole(ctx context.Context, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAwsRoletagBlacklistRoleTag
// roleTag: Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.
func (a *Auth) DeleteAuthAwsRoletagBlacklistRoleTag(ctx context.Context, roleTag string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/roletag-blacklist/{role_tag}"
	requestPath = strings.Replace(requestPath, "{"+"role_tag"+"}", url.PathEscape(roleTag), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAwsRoletagDenylistRoleTag
// roleTag: Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.
func (a *Auth) DeleteAuthAwsRoletagDenylistRoleTag(ctx context.Context, roleTag string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/roletag-denylist/{role_tag}"
	requestPath = strings.Replace(requestPath, "{"+"role_tag"+"}", url.PathEscape(roleTag), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAzureConfig
func (a *Auth) DeleteAuthAzureConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/azure/config"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthAzureRoleName
// name: Name of the role.
func (a *Auth) DeleteAuthAzureRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/azure/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthCertCertsName Manage trusted certificates used for authentication.
// name: The name of the certificate
func (a *Auth) DeleteAuthCertCertsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cert/certs/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthCertCrlsName Manage Certificate Revocation Lists checked during authentication.
// name: The name of the certificate
func (a *Auth) DeleteAuthCertCrlsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cert/crls/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthCfConfig
func (a *Auth) DeleteAuthCfConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cf/config"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthCfRolesRole
// role: The name of the role.
func (a *Auth) DeleteAuthCfRolesRole(ctx context.Context, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cf/roles/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthGcpRoleName Create a GCP role with associated policies and required attributes.
// name: Name of the role.
func (a *Auth) DeleteAuthGcpRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/gcp/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthGithubMapTeamsKey Read/write/delete a single teams mapping
// key: Key for the teams mapping
func (a *Auth) DeleteAuthGithubMapTeamsKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/github/map/teams/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthGithubMapUsersKey Read/write/delete a single users mapping
// key: Key for the users mapping
func (a *Auth) DeleteAuthGithubMapUsersKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/github/map/users/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthJwtRoleName Delete an existing role.
// name: Name of the role.
func (a *Auth) DeleteAuthJwtRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/jwt/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthKerberosGroupsName
// name: Name of the LDAP group.
func (a *Auth) DeleteAuthKerberosGroupsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kerberos/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthKubernetesRoleName Register an role with the backend.
// name: Name of the role.
func (a *Auth) DeleteAuthKubernetesRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kubernetes/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthLdapGroupsName Manage additional groups for users allowed to authenticate.
// name: Name of the LDAP group.
func (a *Auth) DeleteAuthLdapGroupsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/ldap/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthLdapUsersName Manage users allowed to authenticate.
// name: Name of the LDAP user.
func (a *Auth) DeleteAuthLdapUsersName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/ldap/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthOciConfig Manages the configuration for the Vault Auth Plugin.
func (a *Auth) DeleteAuthOciConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oci/config"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthOciRoleRole Create a role and associate policies to it.
// role: Name of the role.
func (a *Auth) DeleteAuthOciRoleRole(ctx context.Context, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oci/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthOidcRoleName Delete an existing role.
// name: Name of the role.
func (a *Auth) DeleteAuthOidcRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oidc/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthOktaGroupsName Manage users allowed to authenticate.
// name: Name of the Okta group.
func (a *Auth) DeleteAuthOktaGroupsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/okta/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthOktaUsersName Manage additional groups for users allowed to authenticate.
// name: Name of the user.
func (a *Auth) DeleteAuthOktaUsersName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/okta/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthRadiusUsersName Manage users allowed to authenticate.
// name: Name of the RADIUS user.
func (a *Auth) DeleteAuthRadiusUsersName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/radius/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthTokenRolesRoleName
// roleName: Name of the role
func (a *Auth) DeleteAuthTokenRolesRoleName(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/roles/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAuthUserpassUsersUsername Manage users allowed to authenticate.
// username: Username for this user.
func (a *Auth) DeleteAuthUserpassUsersUsername(ctx context.Context, username string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/userpass/users/{username}"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAlicloudRole Lists all the roles that are registered with Vault.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAlicloudRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/alicloud/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAlicloudRoleRole Create a role and associate policies to it.
// role: The name of the role as it should appear in Vault.
func (a *Auth) GetAuthAlicloudRoleRole(ctx context.Context, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/alicloud/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAlicloudRoles Lists all the roles that are registered with Vault.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAlicloudRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/alicloud/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAppIdMapAppId Read mappings for app-id
// list: Return a list if &#x60;true&#x60;
func (a *Auth) GetAuthAppIdMapAppId(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/app-id/map/app-id"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAppIdMapAppIdKey Read/write/delete a single app-id mapping
// key: Key for the app-id mapping
func (a *Auth) GetAuthAppIdMapAppIdKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/app-id/map/app-id/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAppIdMapUserId Read mappings for user-id
// list: Return a list if &#x60;true&#x60;
func (a *Auth) GetAuthAppIdMapUserId(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/app-id/map/user-id"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAppIdMapUserIdKey Read/write/delete a single user-id mapping
// key: Key for the user-id mapping
func (a *Auth) GetAuthAppIdMapUserIdKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/app-id/map/user-id/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRole Lists all the roles registered with the backend.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthApproleRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleName Register an role with the backend.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleName(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNameBindSecretId Impose secret_id to be presented during login using this role.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameBindSecretId(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/bind-secret-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNameBoundCidrList Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameBoundCidrList(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/bound-cidr-list"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNameLocalSecretIds Enables cluster local secret IDs
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameLocalSecretIds(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/local-secret-ids"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNamePeriod Updates the value of 'period' on the role
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNamePeriod(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/period"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNamePolicies Policies of the role.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNamePolicies(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/policies"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNameRoleId Returns the 'role_id' of the role.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameRoleId(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/role-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNameSecretId Generate a SecretID against this role.
// roleName: Name of the role.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthApproleRoleRoleNameSecretId(ctx context.Context, roleName string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNameSecretIdBoundCidrs Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameSecretIdBoundCidrs(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-bound-cidrs"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNameSecretIdNumUses Use limit of the SecretID generated against the role.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameSecretIdNumUses(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-num-uses"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNameSecretIdTtl Duration in seconds, representing the lifetime of the SecretIDs that are generated against the role using 'role/<role_name>/secret-id' or 'role/<role_name>/custom-secret-id' endpoints.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameSecretIdTtl(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNameTokenBoundCidrs Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameTokenBoundCidrs(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-bound-cidrs"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNameTokenMaxTtl Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameTokenMaxTtl(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-max-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNameTokenNumUses Number of times issued tokens can be used
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameTokenNumUses(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-num-uses"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthApproleRoleRoleNameTokenTtl Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameTokenTtl(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsConfigCertificateCertName
// certName: Name of the certificate.
func (a *Auth) GetAuthAwsConfigCertificateCertName(ctx context.Context, certName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/certificate/{cert_name}"
	requestPath = strings.Replace(requestPath, "{"+"cert_name"+"}", url.PathEscape(certName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsConfigCertificates
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsConfigCertificates(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/certificates"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsConfigClient
func (a *Auth) GetAuthAwsConfigClient(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/client"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsConfigIdentity
func (a *Auth) GetAuthAwsConfigIdentity(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/identity"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsConfigSts
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsConfigSts(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/sts"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsConfigStsAccountId
// accountId: AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.
func (a *Auth) GetAuthAwsConfigStsAccountId(ctx context.Context, accountId string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/sts/{account_id}"
	requestPath = strings.Replace(requestPath, "{"+"account_id"+"}", url.PathEscape(accountId), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsConfigTidyIdentityAccesslist
func (a *Auth) GetAuthAwsConfigTidyIdentityAccesslist(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/tidy/identity-accesslist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsConfigTidyIdentityWhitelist
func (a *Auth) GetAuthAwsConfigTidyIdentityWhitelist(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/tidy/identity-whitelist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsConfigTidyRoletagBlacklist
func (a *Auth) GetAuthAwsConfigTidyRoletagBlacklist(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/tidy/roletag-blacklist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsConfigTidyRoletagDenylist
func (a *Auth) GetAuthAwsConfigTidyRoletagDenylist(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/tidy/roletag-denylist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsIdentityAccesslist
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsIdentityAccesslist(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/identity-accesslist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsIdentityAccesslistInstanceId
// instanceId: EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.
func (a *Auth) GetAuthAwsIdentityAccesslistInstanceId(ctx context.Context, instanceId string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/identity-accesslist/{instance_id}"
	requestPath = strings.Replace(requestPath, "{"+"instance_id"+"}", url.PathEscape(instanceId), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsIdentityWhitelist
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsIdentityWhitelist(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/identity-whitelist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsIdentityWhitelistInstanceId
// instanceId: EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.
func (a *Auth) GetAuthAwsIdentityWhitelistInstanceId(ctx context.Context, instanceId string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/identity-whitelist/{instance_id}"
	requestPath = strings.Replace(requestPath, "{"+"instance_id"+"}", url.PathEscape(instanceId), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsRole
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsRoleRole
// role: Name of the role.
func (a *Auth) GetAuthAwsRoleRole(ctx context.Context, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsRoles
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsRoletagBlacklist
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsRoletagBlacklist(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/roletag-blacklist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsRoletagBlacklistRoleTag
// roleTag: Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.
func (a *Auth) GetAuthAwsRoletagBlacklistRoleTag(ctx context.Context, roleTag string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/roletag-blacklist/{role_tag}"
	requestPath = strings.Replace(requestPath, "{"+"role_tag"+"}", url.PathEscape(roleTag), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsRoletagDenylist
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsRoletagDenylist(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/roletag-denylist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAwsRoletagDenylistRoleTag
// roleTag: Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.
func (a *Auth) GetAuthAwsRoletagDenylistRoleTag(ctx context.Context, roleTag string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/roletag-denylist/{role_tag}"
	requestPath = strings.Replace(requestPath, "{"+"role_tag"+"}", url.PathEscape(roleTag), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAzureConfig
func (a *Auth) GetAuthAzureConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/azure/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAzureRole
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAzureRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/azure/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthAzureRoleName
// name: Name of the role.
func (a *Auth) GetAuthAzureRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/azure/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthCentrifyConfig This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform for authenticating users.
func (a *Auth) GetAuthCentrifyConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/centrify/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthCertCerts Manage trusted certificates used for authentication.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthCertCerts(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cert/certs"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthCertCertsName Manage trusted certificates used for authentication.
// name: The name of the certificate
func (a *Auth) GetAuthCertCertsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cert/certs/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthCertCrlsName Manage Certificate Revocation Lists checked during authentication.
// name: The name of the certificate
func (a *Auth) GetAuthCertCrlsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cert/crls/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthCfConfig
func (a *Auth) GetAuthCfConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cf/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthCfRoles
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthCfRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cf/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthCfRolesRole
// role: The name of the role.
func (a *Auth) GetAuthCfRolesRole(ctx context.Context, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cf/roles/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthGcpConfig Configure credentials used to query the GCP IAM API to verify authenticating service accounts
func (a *Auth) GetAuthGcpConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/gcp/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthGcpRole Lists all the roles that are registered with Vault.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthGcpRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/gcp/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthGcpRoleName Create a GCP role with associated policies and required attributes.
// name: Name of the role.
func (a *Auth) GetAuthGcpRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/gcp/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthGcpRoles Lists all the roles that are registered with Vault.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthGcpRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/gcp/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthGithubConfig
func (a *Auth) GetAuthGithubConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/github/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthGithubMapTeams Read mappings for teams
// list: Return a list if &#x60;true&#x60;
func (a *Auth) GetAuthGithubMapTeams(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/github/map/teams"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthGithubMapTeamsKey Read/write/delete a single teams mapping
// key: Key for the teams mapping
func (a *Auth) GetAuthGithubMapTeamsKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/github/map/teams/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthGithubMapUsers Read mappings for users
// list: Return a list if &#x60;true&#x60;
func (a *Auth) GetAuthGithubMapUsers(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/github/map/users"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthGithubMapUsersKey Read/write/delete a single users mapping
// key: Key for the users mapping
func (a *Auth) GetAuthGithubMapUsersKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/github/map/users/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthJwtConfig Read the current JWT authentication backend configuration.
func (a *Auth) GetAuthJwtConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/jwt/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthJwtOidcCallback Callback endpoint to complete an OIDC login.
func (a *Auth) GetAuthJwtOidcCallback(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/jwt/oidc/callback"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthJwtRole Lists all the roles registered with the backend.
// The list will contain the names of the roles.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthJwtRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/jwt/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthJwtRoleName Read an existing role.
// name: Name of the role.
func (a *Auth) GetAuthJwtRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/jwt/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthKerberosConfig
func (a *Auth) GetAuthKerberosConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kerberos/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthKerberosConfigLdap
func (a *Auth) GetAuthKerberosConfigLdap(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kerberos/config/ldap"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthKerberosGroups
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthKerberosGroups(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kerberos/groups"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthKerberosGroupsName
// name: Name of the LDAP group.
func (a *Auth) GetAuthKerberosGroupsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kerberos/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthKerberosLogin
func (a *Auth) GetAuthKerberosLogin(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kerberos/login"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthKubernetesConfig Configures the JWT Public Key and Kubernetes API information.
func (a *Auth) GetAuthKubernetesConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kubernetes/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthKubernetesRole Lists all the roles registered with the backend.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthKubernetesRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kubernetes/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthKubernetesRoleName Register an role with the backend.
// name: Name of the role.
func (a *Auth) GetAuthKubernetesRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kubernetes/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthLdapConfig Configure the LDAP server to connect to, along with its options.
func (a *Auth) GetAuthLdapConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/ldap/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthLdapGroups Manage additional groups for users allowed to authenticate.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthLdapGroups(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/ldap/groups"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthLdapGroupsName Manage additional groups for users allowed to authenticate.
// name: Name of the LDAP group.
func (a *Auth) GetAuthLdapGroupsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/ldap/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthLdapUsers Manage users allowed to authenticate.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthLdapUsers(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/ldap/users"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthLdapUsersName Manage users allowed to authenticate.
// name: Name of the LDAP user.
func (a *Auth) GetAuthLdapUsersName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/ldap/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthOciConfig Manages the configuration for the Vault Auth Plugin.
func (a *Auth) GetAuthOciConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oci/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthOciRole Lists all the roles that are registered with Vault.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthOciRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oci/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthOciRoleRole Create a role and associate policies to it.
// role: Name of the role.
func (a *Auth) GetAuthOciRoleRole(ctx context.Context, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oci/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthOidcConfig Read the current JWT authentication backend configuration.
func (a *Auth) GetAuthOidcConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oidc/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthOidcOidcCallback Callback endpoint to complete an OIDC login.
func (a *Auth) GetAuthOidcOidcCallback(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oidc/oidc/callback"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthOidcRole Lists all the roles registered with the backend.
// The list will contain the names of the roles.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthOidcRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oidc/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthOidcRoleName Read an existing role.
// name: Name of the role.
func (a *Auth) GetAuthOidcRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oidc/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthOktaConfig This endpoint allows you to configure the Okta and its configuration options.  The Okta organization are the characters at the front of the URL for Okta. Example https://ORG.okta.com
func (a *Auth) GetAuthOktaConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/okta/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthOktaGroups Manage users allowed to authenticate.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthOktaGroups(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/okta/groups"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthOktaGroupsName Manage users allowed to authenticate.
// name: Name of the Okta group.
func (a *Auth) GetAuthOktaGroupsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/okta/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthOktaUsers Manage additional groups for users allowed to authenticate.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthOktaUsers(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/okta/users"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthOktaUsersName Manage additional groups for users allowed to authenticate.
// name: Name of the user.
func (a *Auth) GetAuthOktaUsersName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/okta/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthOktaVerifyNonce
// nonce: Nonce provided during a login request to retrieve the number verification challenge for the matching request.
func (a *Auth) GetAuthOktaVerifyNonce(ctx context.Context, nonce string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/okta/verify/{nonce}"
	requestPath = strings.Replace(requestPath, "{"+"nonce"+"}", url.PathEscape(nonce), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthRadiusConfig Configure the RADIUS server to connect to, along with its options.
func (a *Auth) GetAuthRadiusConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/radius/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthRadiusUsers Manage users allowed to authenticate.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthRadiusUsers(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/radius/users"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthRadiusUsersName Manage users allowed to authenticate.
// name: Name of the RADIUS user.
func (a *Auth) GetAuthRadiusUsersName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/radius/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthTokenAccessors List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires 'sudo' capability in addition to 'list'.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthTokenAccessors(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/accessors/"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthTokenLookup This endpoint will lookup a token and its properties.
func (a *Auth) GetAuthTokenLookup(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/lookup"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthTokenLookupSelf This endpoint will lookup a token and its properties.
func (a *Auth) GetAuthTokenLookupSelf(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/lookup-self"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthTokenRoles This endpoint lists configured roles.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthTokenRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthTokenRolesRoleName
// roleName: Name of the role
func (a *Auth) GetAuthTokenRolesRoleName(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/roles/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthUserpassUsers Manage users allowed to authenticate.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthUserpassUsers(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/userpass/users"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAuthUserpassUsersUsername Manage users allowed to authenticate.
// username: Username for this user.
func (a *Auth) GetAuthUserpassUsersUsername(ctx context.Context, username string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/userpass/users/{username}"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAlicloudLogin Authenticates an RAM entity with Vault.
func (a *Auth) PostAuthAlicloudLogin(ctx context.Context, alicloudLoginRequest AlicloudLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/alicloud/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, alicloudLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAlicloudRoleRole Create a role and associate policies to it.
// role: The name of the role as it should appear in Vault.
func (a *Auth) PostAuthAlicloudRoleRole(ctx context.Context, role string, alicloudRoleRequest AlicloudRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/alicloud/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, alicloudRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAppIdLogin Log in with an App ID and User ID.
func (a *Auth) PostAuthAppIdLogin(ctx context.Context, appIdLoginRequest AppIdLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/app-id/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, appIdLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAppIdLoginAppId Log in with an App ID and User ID.
// appId: The unique app ID
func (a *Auth) PostAuthAppIdLoginAppId(ctx context.Context, appId string, appIdLoginRequest AppIdLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/app-id/login/{app_id}"
	requestPath = strings.Replace(requestPath, "{"+"app_id"+"}", url.PathEscape(appId), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, appIdLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAppIdMapAppIdKey Read/write/delete a single app-id mapping
// key: Key for the app-id mapping
func (a *Auth) PostAuthAppIdMapAppIdKey(ctx context.Context, key string, appIdMapAppIdRequest AppIdMapAppIdRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/app-id/map/app-id/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, appIdMapAppIdRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAppIdMapUserIdKey Read/write/delete a single user-id mapping
// key: Key for the user-id mapping
func (a *Auth) PostAuthAppIdMapUserIdKey(ctx context.Context, key string, appIdMapUserIdRequest AppIdMapUserIdRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/app-id/map/user-id/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, appIdMapUserIdRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleLogin
func (a *Auth) PostAuthApproleLogin(ctx context.Context, approleLoginRequest ApproleLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleName Register an role with the backend.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleName(ctx context.Context, roleName string, approleRoleRequest ApproleRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameBindSecretId Impose secret_id to be presented during login using this role.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameBindSecretId(ctx context.Context, roleName string, approleRoleBindSecretIdRequest ApproleRoleBindSecretIdRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/bind-secret-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleBindSecretIdRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameBoundCidrList Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameBoundCidrList(ctx context.Context, roleName string, approleRoleBoundCidrListRequest ApproleRoleBoundCidrListRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/bound-cidr-list"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleBoundCidrListRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameCustomSecretId Assign a SecretID of choice against the role.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameCustomSecretId(ctx context.Context, roleName string, approleRoleCustomSecretIdRequest ApproleRoleCustomSecretIdRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/custom-secret-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleCustomSecretIdRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNamePeriod Updates the value of 'period' on the role
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNamePeriod(ctx context.Context, roleName string, approleRolePeriodRequest ApproleRolePeriodRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/period"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRolePeriodRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNamePolicies Policies of the role.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNamePolicies(ctx context.Context, roleName string, approleRolePoliciesRequest ApproleRolePoliciesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/policies"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRolePoliciesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameRoleId Returns the 'role_id' of the role.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameRoleId(ctx context.Context, roleName string, approleRoleRoleIdRequest ApproleRoleRoleIdRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/role-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleRoleIdRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameSecretId Generate a SecretID against this role.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretId(ctx context.Context, roleName string, approleRoleSecretIdRequest ApproleRoleSecretIdRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameSecretIdAccessorDestroy
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdAccessorDestroy(ctx context.Context, roleName string, approleRoleSecretIdAccessorDestroyRequest ApproleRoleSecretIdAccessorDestroyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-accessor/destroy"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdAccessorDestroyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameSecretIdAccessorLookup
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdAccessorLookup(ctx context.Context, roleName string, approleRoleSecretIdAccessorLookupRequest ApproleRoleSecretIdAccessorLookupRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-accessor/lookup"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdAccessorLookupRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameSecretIdBoundCidrs Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdBoundCidrs(ctx context.Context, roleName string, approleRoleSecretIdBoundCidrsRequest ApproleRoleSecretIdBoundCidrsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-bound-cidrs"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdBoundCidrsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameSecretIdDestroy Invalidate an issued secret_id
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdDestroy(ctx context.Context, roleName string, approleRoleSecretIdDestroyRequest ApproleRoleSecretIdDestroyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id/destroy"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdDestroyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameSecretIdLookup Read the properties of an issued secret_id
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdLookup(ctx context.Context, roleName string, approleRoleSecretIdLookupRequest ApproleRoleSecretIdLookupRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id/lookup"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdLookupRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameSecretIdNumUses Use limit of the SecretID generated against the role.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdNumUses(ctx context.Context, roleName string, approleRoleSecretIdNumUsesRequest ApproleRoleSecretIdNumUsesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-num-uses"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdNumUsesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameSecretIdTtl Duration in seconds, representing the lifetime of the SecretIDs that are generated against the role using 'role/<role_name>/secret-id' or 'role/<role_name>/custom-secret-id' endpoints.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdTtl(ctx context.Context, roleName string, approleRoleSecretIdTtlRequest ApproleRoleSecretIdTtlRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdTtlRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameTokenBoundCidrs Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameTokenBoundCidrs(ctx context.Context, roleName string, approleRoleTokenBoundCidrsRequest ApproleRoleTokenBoundCidrsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-bound-cidrs"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleTokenBoundCidrsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameTokenMaxTtl Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameTokenMaxTtl(ctx context.Context, roleName string, approleRoleTokenMaxTtlRequest ApproleRoleTokenMaxTtlRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-max-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleTokenMaxTtlRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameTokenNumUses Number of times issued tokens can be used
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameTokenNumUses(ctx context.Context, roleName string, approleRoleTokenNumUsesRequest ApproleRoleTokenNumUsesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-num-uses"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleTokenNumUsesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleRoleRoleNameTokenTtl Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameTokenTtl(ctx context.Context, roleName string, approleRoleTokenTtlRequest ApproleRoleTokenTtlRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleTokenTtlRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthApproleTidySecretId Trigger the clean-up of expired SecretID entries.
func (a *Auth) PostAuthApproleTidySecretId(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/approle/tidy/secret-id"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsConfigCertificateCertName
// certName: Name of the certificate.
func (a *Auth) PostAuthAwsConfigCertificateCertName(ctx context.Context, certName string, awsConfigCertificateRequest AwsConfigCertificateRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/certificate/{cert_name}"
	requestPath = strings.Replace(requestPath, "{"+"cert_name"+"}", url.PathEscape(certName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigCertificateRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsConfigClient
func (a *Auth) PostAuthAwsConfigClient(ctx context.Context, awsConfigClientRequest AwsConfigClientRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/client"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigClientRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsConfigIdentity
func (a *Auth) PostAuthAwsConfigIdentity(ctx context.Context, awsConfigIdentityRequest AwsConfigIdentityRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/identity"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigIdentityRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsConfigRotateRoot
func (a *Auth) PostAuthAwsConfigRotateRoot(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/rotate-root"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsConfigStsAccountId
// accountId: AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.
func (a *Auth) PostAuthAwsConfigStsAccountId(ctx context.Context, accountId string, awsConfigStsRequest AwsConfigStsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/sts/{account_id}"
	requestPath = strings.Replace(requestPath, "{"+"account_id"+"}", url.PathEscape(accountId), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigStsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsConfigTidyIdentityAccesslist
func (a *Auth) PostAuthAwsConfigTidyIdentityAccesslist(ctx context.Context, awsConfigTidyIdentityAccesslistRequest AwsConfigTidyIdentityAccesslistRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/tidy/identity-accesslist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigTidyIdentityAccesslistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsConfigTidyIdentityWhitelist
func (a *Auth) PostAuthAwsConfigTidyIdentityWhitelist(ctx context.Context, awsConfigTidyIdentityWhitelistRequest AwsConfigTidyIdentityWhitelistRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/tidy/identity-whitelist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigTidyIdentityWhitelistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsConfigTidyRoletagBlacklist
func (a *Auth) PostAuthAwsConfigTidyRoletagBlacklist(ctx context.Context, awsConfigTidyRoletagBlacklistRequest AwsConfigTidyRoletagBlacklistRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/tidy/roletag-blacklist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigTidyRoletagBlacklistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsConfigTidyRoletagDenylist
func (a *Auth) PostAuthAwsConfigTidyRoletagDenylist(ctx context.Context, awsConfigTidyRoletagDenylistRequest AwsConfigTidyRoletagDenylistRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/config/tidy/roletag-denylist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigTidyRoletagDenylistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsLogin
func (a *Auth) PostAuthAwsLogin(ctx context.Context, awsLoginRequest AwsLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsRoleRole
// role: Name of the role.
func (a *Auth) PostAuthAwsRoleRole(ctx context.Context, role string, awsRoleRequest AwsRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsRoleRoleTag
// role: Name of the role.
func (a *Auth) PostAuthAwsRoleRoleTag(ctx context.Context, role string, awsRoleTagRequest AwsRoleTagRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/role/{role}/tag"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsRoleTagRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsRoletagBlacklistRoleTag
// roleTag: Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.
func (a *Auth) PostAuthAwsRoletagBlacklistRoleTag(ctx context.Context, roleTag string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/roletag-blacklist/{role_tag}"
	requestPath = strings.Replace(requestPath, "{"+"role_tag"+"}", url.PathEscape(roleTag), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsRoletagDenylistRoleTag
// roleTag: Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.
func (a *Auth) PostAuthAwsRoletagDenylistRoleTag(ctx context.Context, roleTag string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/roletag-denylist/{role_tag}"
	requestPath = strings.Replace(requestPath, "{"+"role_tag"+"}", url.PathEscape(roleTag), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsTidyIdentityAccesslist
func (a *Auth) PostAuthAwsTidyIdentityAccesslist(ctx context.Context, awsTidyIdentityAccesslistRequest AwsTidyIdentityAccesslistRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/tidy/identity-accesslist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsTidyIdentityAccesslistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsTidyIdentityWhitelist
func (a *Auth) PostAuthAwsTidyIdentityWhitelist(ctx context.Context, awsTidyIdentityWhitelistRequest AwsTidyIdentityWhitelistRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/tidy/identity-whitelist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsTidyIdentityWhitelistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsTidyRoletagBlacklist
func (a *Auth) PostAuthAwsTidyRoletagBlacklist(ctx context.Context, awsTidyRoletagBlacklistRequest AwsTidyRoletagBlacklistRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/tidy/roletag-blacklist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsTidyRoletagBlacklistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAwsTidyRoletagDenylist
func (a *Auth) PostAuthAwsTidyRoletagDenylist(ctx context.Context, awsTidyRoletagDenylistRequest AwsTidyRoletagDenylistRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/aws/tidy/roletag-denylist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsTidyRoletagDenylistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAzureConfig
func (a *Auth) PostAuthAzureConfig(ctx context.Context, azureConfigRequest AzureConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/azure/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, azureConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAzureLogin
func (a *Auth) PostAuthAzureLogin(ctx context.Context, azureLoginRequest AzureLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/azure/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, azureLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthAzureRoleName
// name: Name of the role.
func (a *Auth) PostAuthAzureRoleName(ctx context.Context, name string, azureRoleRequest AzureRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/azure/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, azureRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthCentrifyConfig This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform for authenticating users.
func (a *Auth) PostAuthCentrifyConfig(ctx context.Context, centrifyConfigRequest CentrifyConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/centrify/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, centrifyConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthCentrifyLogin Log in with a username and password.
func (a *Auth) PostAuthCentrifyLogin(ctx context.Context, centrifyLoginRequest CentrifyLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/centrify/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, centrifyLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthCertCertsName Manage trusted certificates used for authentication.
// name: The name of the certificate
func (a *Auth) PostAuthCertCertsName(ctx context.Context, name string, certCertsRequest CertCertsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cert/certs/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, certCertsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthCertConfig
func (a *Auth) PostAuthCertConfig(ctx context.Context, certConfigRequest CertConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cert/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, certConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthCertCrlsName Manage Certificate Revocation Lists checked during authentication.
// name: The name of the certificate
func (a *Auth) PostAuthCertCrlsName(ctx context.Context, name string, certCrlsRequest CertCrlsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cert/crls/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, certCrlsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthCertLogin
func (a *Auth) PostAuthCertLogin(ctx context.Context, certLoginRequest CertLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cert/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, certLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthCfConfig
func (a *Auth) PostAuthCfConfig(ctx context.Context, cfConfigRequest CfConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cf/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, cfConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthCfLogin
func (a *Auth) PostAuthCfLogin(ctx context.Context, cfLoginRequest CfLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cf/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, cfLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthCfRolesRole
// role: The name of the role.
func (a *Auth) PostAuthCfRolesRole(ctx context.Context, role string, cfRolesRequest CfRolesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/cf/roles/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, cfRolesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthGcpConfig Configure credentials used to query the GCP IAM API to verify authenticating service accounts
func (a *Auth) PostAuthGcpConfig(ctx context.Context, gcpConfigRequest GcpConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/gcp/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthGcpLogin
func (a *Auth) PostAuthGcpLogin(ctx context.Context, gcpLoginRequest GcpLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/gcp/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthGcpRoleName Create a GCP role with associated policies and required attributes.
// name: Name of the role.
func (a *Auth) PostAuthGcpRoleName(ctx context.Context, name string, gcpRoleRequest GcpRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/gcp/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthGcpRoleNameLabels Add or remove labels for an existing 'gce' role
// name: Name of the role.
func (a *Auth) PostAuthGcpRoleNameLabels(ctx context.Context, name string, gcpRoleLabelsRequest GcpRoleLabelsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/gcp/role/{name}/labels"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpRoleLabelsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthGcpRoleNameServiceAccounts Add or remove service accounts for an existing `iam` role
// name: Name of the role.
func (a *Auth) PostAuthGcpRoleNameServiceAccounts(ctx context.Context, name string, gcpRoleServiceAccountsRequest GcpRoleServiceAccountsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/gcp/role/{name}/service-accounts"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpRoleServiceAccountsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthGithubConfig
func (a *Auth) PostAuthGithubConfig(ctx context.Context, githubConfigRequest GithubConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/github/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, githubConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthGithubLogin
func (a *Auth) PostAuthGithubLogin(ctx context.Context, githubLoginRequest GithubLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/github/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, githubLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthGithubMapTeamsKey Read/write/delete a single teams mapping
// key: Key for the teams mapping
func (a *Auth) PostAuthGithubMapTeamsKey(ctx context.Context, key string, githubMapTeamsRequest GithubMapTeamsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/github/map/teams/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, githubMapTeamsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthGithubMapUsersKey Read/write/delete a single users mapping
// key: Key for the users mapping
func (a *Auth) PostAuthGithubMapUsersKey(ctx context.Context, key string, githubMapUsersRequest GithubMapUsersRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/github/map/users/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, githubMapUsersRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthJwtConfig Configure the JWT authentication backend.
// The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
func (a *Auth) PostAuthJwtConfig(ctx context.Context, jwtConfigRequest JwtConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/jwt/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, jwtConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthJwtLogin Authenticates to Vault using a JWT (or OIDC) token.
func (a *Auth) PostAuthJwtLogin(ctx context.Context, jwtLoginRequest JwtLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/jwt/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, jwtLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthJwtOidcAuthUrl Request an authorization URL to start an OIDC login flow.
func (a *Auth) PostAuthJwtOidcAuthUrl(ctx context.Context, jwtOidcAuthUrlRequest JwtOidcAuthUrlRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/jwt/oidc/auth_url"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, jwtOidcAuthUrlRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthJwtOidcCallback Callback endpoint to handle form_posts.
func (a *Auth) PostAuthJwtOidcCallback(ctx context.Context, jwtOidcCallbackRequest JwtOidcCallbackRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/jwt/oidc/callback"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, jwtOidcCallbackRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthJwtRoleName Register an role with the backend.
// A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
// name: Name of the role.
func (a *Auth) PostAuthJwtRoleName(ctx context.Context, name string, jwtRoleRequest JwtRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/jwt/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, jwtRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthKerberosConfig
func (a *Auth) PostAuthKerberosConfig(ctx context.Context, kerberosConfigRequest KerberosConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kerberos/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kerberosConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthKerberosConfigLdap
func (a *Auth) PostAuthKerberosConfigLdap(ctx context.Context, kerberosConfigLdapRequest KerberosConfigLdapRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kerberos/config/ldap"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kerberosConfigLdapRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthKerberosGroupsName
// name: Name of the LDAP group.
func (a *Auth) PostAuthKerberosGroupsName(ctx context.Context, name string, kerberosGroupsRequest KerberosGroupsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kerberos/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kerberosGroupsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthKerberosLogin
func (a *Auth) PostAuthKerberosLogin(ctx context.Context, kerberosLoginRequest KerberosLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kerberos/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kerberosLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthKubernetesConfig Configures the JWT Public Key and Kubernetes API information.
func (a *Auth) PostAuthKubernetesConfig(ctx context.Context, kubernetesConfigRequest KubernetesConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kubernetes/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kubernetesConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthKubernetesLogin Authenticates Kubernetes service accounts with Vault.
func (a *Auth) PostAuthKubernetesLogin(ctx context.Context, kubernetesLoginRequest KubernetesLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kubernetes/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kubernetesLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthKubernetesRoleName Register an role with the backend.
// name: Name of the role.
func (a *Auth) PostAuthKubernetesRoleName(ctx context.Context, name string, kubernetesRoleRequest KubernetesRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/kubernetes/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kubernetesRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthLdapConfig Configure the LDAP server to connect to, along with its options.
func (a *Auth) PostAuthLdapConfig(ctx context.Context, ldapConfigRequest LdapConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/ldap/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ldapConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthLdapGroupsName Manage additional groups for users allowed to authenticate.
// name: Name of the LDAP group.
func (a *Auth) PostAuthLdapGroupsName(ctx context.Context, name string, ldapGroupsRequest LdapGroupsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/ldap/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ldapGroupsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthLdapLoginUsername Log in with a username and password.
// username: DN (distinguished name) to be used for login.
func (a *Auth) PostAuthLdapLoginUsername(ctx context.Context, username string, ldapLoginRequest LdapLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/ldap/login/{username}"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ldapLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthLdapUsersName Manage users allowed to authenticate.
// name: Name of the LDAP user.
func (a *Auth) PostAuthLdapUsersName(ctx context.Context, name string, ldapUsersRequest LdapUsersRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/ldap/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ldapUsersRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthOciConfig Manages the configuration for the Vault Auth Plugin.
func (a *Auth) PostAuthOciConfig(ctx context.Context, ociConfigRequest OciConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oci/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ociConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthOciLoginRole Authenticates to Vault using OCI credentials
// role: Name of the role.
func (a *Auth) PostAuthOciLoginRole(ctx context.Context, role string, ociLoginRequest OciLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oci/login/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ociLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthOciRoleRole Create a role and associate policies to it.
// role: Name of the role.
func (a *Auth) PostAuthOciRoleRole(ctx context.Context, role string, ociRoleRequest OciRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oci/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ociRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthOidcConfig Configure the JWT authentication backend.
// The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
func (a *Auth) PostAuthOidcConfig(ctx context.Context, oidcConfigRequest OidcConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oidc/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oidcConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthOidcLogin Authenticates to Vault using a JWT (or OIDC) token.
func (a *Auth) PostAuthOidcLogin(ctx context.Context, oidcLoginRequest OidcLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oidc/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oidcLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthOidcOidcAuthUrl Request an authorization URL to start an OIDC login flow.
func (a *Auth) PostAuthOidcOidcAuthUrl(ctx context.Context, oidcOidcAuthUrlRequest OidcOidcAuthUrlRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oidc/oidc/auth_url"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oidcOidcAuthUrlRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthOidcOidcCallback Callback endpoint to handle form_posts.
func (a *Auth) PostAuthOidcOidcCallback(ctx context.Context, oidcOidcCallbackRequest OidcOidcCallbackRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oidc/oidc/callback"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oidcOidcCallbackRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthOidcRoleName Register an role with the backend.
// A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
// name: Name of the role.
func (a *Auth) PostAuthOidcRoleName(ctx context.Context, name string, oidcRoleRequest OidcRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/oidc/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oidcRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthOktaConfig This endpoint allows you to configure the Okta and its configuration options.  The Okta organization are the characters at the front of the URL for Okta. Example https://ORG.okta.com
func (a *Auth) PostAuthOktaConfig(ctx context.Context, oktaConfigRequest OktaConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/okta/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oktaConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthOktaGroupsName Manage users allowed to authenticate.
// name: Name of the Okta group.
func (a *Auth) PostAuthOktaGroupsName(ctx context.Context, name string, oktaGroupsRequest OktaGroupsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/okta/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oktaGroupsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthOktaLoginUsername Log in with a username and password.
// username: Username to be used for login.
func (a *Auth) PostAuthOktaLoginUsername(ctx context.Context, username string, oktaLoginRequest OktaLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/okta/login/{username}"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oktaLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthOktaUsersName Manage additional groups for users allowed to authenticate.
// name: Name of the user.
func (a *Auth) PostAuthOktaUsersName(ctx context.Context, name string, oktaUsersRequest OktaUsersRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/okta/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oktaUsersRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthRadiusConfig Configure the RADIUS server to connect to, along with its options.
func (a *Auth) PostAuthRadiusConfig(ctx context.Context, radiusConfigRequest RadiusConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/radius/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, radiusConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthRadiusLogin Log in with a username and password.
func (a *Auth) PostAuthRadiusLogin(ctx context.Context, radiusLoginRequest RadiusLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/radius/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, radiusLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthRadiusLoginUrlusername Log in with a username and password.
// urlusername: Username to be used for login. (URL parameter)
func (a *Auth) PostAuthRadiusLoginUrlusername(ctx context.Context, urlusername string, radiusLoginRequest RadiusLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/radius/login/{urlusername}"
	requestPath = strings.Replace(requestPath, "{"+"urlusername"+"}", url.PathEscape(urlusername), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, radiusLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthRadiusUsersName Manage users allowed to authenticate.
// name: Name of the RADIUS user.
func (a *Auth) PostAuthRadiusUsersName(ctx context.Context, name string, radiusUsersRequest RadiusUsersRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/radius/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, radiusUsersRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenCreate The token create path is used to create new tokens.
func (a *Auth) PostAuthTokenCreate(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/create"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenCreateOrphan The token create path is used to create new orphan tokens.
func (a *Auth) PostAuthTokenCreateOrphan(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/create-orphan"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenCreateRoleName This token create path is used to create new tokens adhering to the given role.
// roleName: Name of the role
func (a *Auth) PostAuthTokenCreateRoleName(ctx context.Context, roleName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/create/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenLookup This endpoint will lookup a token and its properties.
func (a *Auth) PostAuthTokenLookup(ctx context.Context, tokenLookupRequest TokenLookupRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/lookup"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenLookupRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenLookupAccessor This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.
func (a *Auth) PostAuthTokenLookupAccessor(ctx context.Context, tokenLookupAccessorRequest TokenLookupAccessorRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/lookup-accessor"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenLookupAccessorRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenLookupSelf This endpoint will lookup a token and its properties.
func (a *Auth) PostAuthTokenLookupSelf(ctx context.Context, tokenLookupSelfRequest TokenLookupSelfRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/lookup-self"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenLookupSelfRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenRenew This endpoint will renew the given token and prevent expiration.
func (a *Auth) PostAuthTokenRenew(ctx context.Context, tokenRenewRequest TokenRenewRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/renew"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRenewRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenRenewAccessor This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.
func (a *Auth) PostAuthTokenRenewAccessor(ctx context.Context, tokenRenewAccessorRequest TokenRenewAccessorRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/renew-accessor"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRenewAccessorRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenRenewSelf This endpoint will renew the token used to call it and prevent expiration.
func (a *Auth) PostAuthTokenRenewSelf(ctx context.Context, tokenRenewSelfRequest TokenRenewSelfRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/renew-self"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRenewSelfRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenRevoke This endpoint will delete the given token and all of its child tokens.
func (a *Auth) PostAuthTokenRevoke(ctx context.Context, tokenRevokeRequest TokenRevokeRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/revoke"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRevokeRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenRevokeAccessor This endpoint will delete the token associated with the accessor and all of its child tokens.
func (a *Auth) PostAuthTokenRevokeAccessor(ctx context.Context, tokenRevokeAccessorRequest TokenRevokeAccessorRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/revoke-accessor"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRevokeAccessorRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenRevokeOrphan This endpoint will delete the token and orphan its child tokens.
func (a *Auth) PostAuthTokenRevokeOrphan(ctx context.Context, tokenRevokeOrphanRequest TokenRevokeOrphanRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/revoke-orphan"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRevokeOrphanRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenRevokeSelf This endpoint will delete the token used to call it and all of its child tokens.
func (a *Auth) PostAuthTokenRevokeSelf(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/revoke-self"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenRolesRoleName
// roleName: Name of the role
func (a *Auth) PostAuthTokenRolesRoleName(ctx context.Context, roleName string, tokenRolesRequest TokenRolesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/roles/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRolesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthTokenTidy This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
func (a *Auth) PostAuthTokenTidy(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/token/tidy"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthUserpassLoginUsername Log in with a username and password.
// username: Username of the user.
func (a *Auth) PostAuthUserpassLoginUsername(ctx context.Context, username string, userpassLoginRequest UserpassLoginRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/userpass/login/{username}"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, userpassLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthUserpassUsersUsername Manage users allowed to authenticate.
// username: Username for this user.
func (a *Auth) PostAuthUserpassUsersUsername(ctx context.Context, username string, userpassUsersRequest UserpassUsersRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/userpass/users/{username}"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, userpassUsersRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthUserpassUsersUsernamePassword Reset user's password.
// username: Username for this user.
func (a *Auth) PostAuthUserpassUsersUsernamePassword(ctx context.Context, username string, userpassUsersPasswordRequest UserpassUsersPasswordRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/userpass/users/{username}/password"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, userpassUsersPasswordRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAuthUserpassUsersUsernamePolicies Update the policies associated with the username.
// username: Username for this user.
func (a *Auth) PostAuthUserpassUsersUsernamePolicies(ctx context.Context, username string, userpassUsersPoliciesRequest UserpassUsersPoliciesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/auth/userpass/users/{username}/policies"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, userpassUsersPoliciesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}
