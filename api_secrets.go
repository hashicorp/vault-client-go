/*
HashiCorp Vault API

HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.

API version: 1.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package vault

import (
	"context"
	"net/http"
	"net/url"
	"strings"
)

// Secrets is a simple wrapper around the client for Secrets requests
type Secrets struct {
	client *Client
}

// DeleteAdConfig Configure the AD server to connect to, along with password options.
func (a *Secrets) DeleteAdConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/config"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAdLibraryName Delete a library set.
// name: Name of the set.
func (a *Secrets) DeleteAdLibraryName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/library/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAdRolesName Manage roles to build links between Vault and Active Directory service accounts.
// name: Name of the role
func (a *Secrets) DeleteAdRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAlicloudConfig Configure the access key and secret to use for RAM and STS calls.
func (a *Secrets) DeleteAlicloudConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/alicloud/config"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAlicloudRoleName Read, write and reference policies and roles that API keys or STS credentials can be made for.
// name: The name of the role.
func (a *Secrets) DeleteAlicloudRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/alicloud/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAwsRolesName Read, write and reference IAM policies that access keys can be made for.
// name: Name of the policy
func (a *Secrets) DeleteAwsRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/aws/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAzureConfig
func (a *Secrets) DeleteAzureConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/azure/config"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteAzureRolesName Manage the Vault roles used to generate Azure credentials.
// name: Name of the role.
func (a *Secrets) DeleteAzureRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/azure/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteConsulRolesName
// name: Name of the role.
func (a *Secrets) DeleteConsulRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/consul/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteCubbyholePath Deletes the secret at the specified location.
// path: Specifies the path of the secret.
func (a *Secrets) DeleteCubbyholePath(ctx context.Context, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/cubbyhole/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteGcpRolesetName
// name: Required. Name of the role.
func (a *Secrets) DeleteGcpRolesetName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/roleset/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteGcpStaticAccountName
// name: Required. Name to refer to this static account in Vault. Cannot be updated.
func (a *Secrets) DeleteGcpStaticAccountName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/static-account/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteGcpkmsConfig Configure the GCP KMS secrets engine
func (a *Secrets) DeleteGcpkmsConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/config"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteGcpkmsKeysDeregisterKey Deregister an existing key in Vault
// key: Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.
func (a *Secrets) DeleteGcpkmsKeysDeregisterKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/keys/deregister/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteGcpkmsKeysKey Interact with crypto keys in Vault and Google Cloud KMS
// key: Name of the key in Vault.
func (a *Secrets) DeleteGcpkmsKeysKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/keys/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteGcpkmsKeysTrimKey Delete old crypto key versions from Google Cloud KMS
// key: Name of the key in Vault.
func (a *Secrets) DeleteGcpkmsKeysTrimKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/keys/trim/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteKubernetesConfig
func (a *Secrets) DeleteKubernetesConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/kubernetes/config"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteKubernetesRolesName
// name: Name of the role
func (a *Secrets) DeleteKubernetesRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/kubernetes/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteKvPath Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
// path: Location of the secret.
func (a *Secrets) DeleteKvPath(ctx context.Context, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/kv/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteMongodbatlasRolesName Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
// name: Name of the Roles
func (a *Secrets) DeleteMongodbatlasRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/mongodbatlas/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteNomadConfigAccess
func (a *Secrets) DeleteNomadConfigAccess(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/nomad/config/access"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteNomadConfigLease Configure the lease parameters for generated tokens
func (a *Secrets) DeleteNomadConfigLease(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/nomad/config/lease"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteNomadRoleName
// name: Name of the role
func (a *Secrets) DeleteNomadRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/nomad/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteOpenldapConfig
func (a *Secrets) DeleteOpenldapConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/config"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteOpenldapRoleName
// name: Name of the role (lowercase)
func (a *Secrets) DeleteOpenldapRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteOpenldapStaticRoleName
// name: Name of the role
func (a *Secrets) DeleteOpenldapStaticRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/static-role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeletePkiIssuerRefDerPem
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
func (a *Secrets) DeletePkiIssuerRefDerPem(ctx context.Context, issuerRef string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/{issuer_ref}/der|/pem"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeletePkiJson
func (a *Secrets) DeletePkiJson(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki//json"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeletePkiKeyKeyRef
// keyRef: Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.
func (a *Secrets) DeletePkiKeyKeyRef(ctx context.Context, keyRef string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/key/{key_ref}"
	requestPath = strings.Replace(requestPath, "{"+"key_ref"+"}", url.PathEscape(keyRef), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeletePkiRolesName
// name: Name of the role
func (a *Secrets) DeletePkiRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeletePkiRoot
func (a *Secrets) DeletePkiRoot(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/root"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteRabbitmqRolesName Manage the roles that can be created with this backend.
// name: Name of the role.
func (a *Secrets) DeleteRabbitmqRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/rabbitmq/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteSecretDataPath Write, Patch, Read, and Delete data in the Key-Value Store.
// path: Location of the secret.
func (a *Secrets) DeleteSecretDataPath(ctx context.Context, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/secret/data/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteSecretMetadataPath Configures settings for the KV store
// path: Location of the secret.
func (a *Secrets) DeleteSecretMetadataPath(ctx context.Context, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/secret/metadata/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteSshConfigCa Set the SSH private key used for signing certificates.
func (a *Secrets) DeleteSshConfigCa(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/config/ca"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteSshConfigZeroaddress Assign zero address as default CIDR block for select roles.
func (a *Secrets) DeleteSshConfigZeroaddress(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/config/zeroaddress"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteSshKeysKeyName Register a shared private key with Vault.
// keyName: [Required] Name of the key
func (a *Secrets) DeleteSshKeysKeyName(ctx context.Context, keyName string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/keys/{key_name}"
	requestPath = strings.Replace(requestPath, "{"+"key_name"+"}", url.PathEscape(keyName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteSshRolesRole Manage the 'roles' that can be created with this backend.
// role: [Required for all types] Name of the role being created.
func (a *Secrets) DeleteSshRolesRole(ctx context.Context, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/roles/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteTerraformConfig
func (a *Secrets) DeleteTerraformConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/terraform/config"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteTerraformRoleName
// name: Name of the role
func (a *Secrets) DeleteTerraformRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/terraform/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteTotpKeysName Manage the keys that can be created with this backend.
// name: Name of the key.
func (a *Secrets) DeleteTotpKeysName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/totp/keys/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// DeleteTransitKeysName Managed named encryption keys
// name: Name of the key
func (a *Secrets) DeleteTransitKeysName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/keys/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAdConfig Configure the AD server to connect to, along with password options.
func (a *Secrets) GetAdConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAdCredsName
// name: Name of the role
func (a *Secrets) GetAdCredsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/creds/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAdLibrary
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetAdLibrary(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/library"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAdLibraryName Read a library set.
// name: Name of the set.
func (a *Secrets) GetAdLibraryName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/library/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAdLibraryNameStatus Check the status of the service accounts in a library set.
// name: Name of the set.
func (a *Secrets) GetAdLibraryNameStatus(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/library/{name}/status"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAdRoles List the name of each role currently stored.
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetAdRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAdRolesName Manage roles to build links between Vault and Active Directory service accounts.
// name: Name of the role
func (a *Secrets) GetAdRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAdRotateRoot
func (a *Secrets) GetAdRotateRoot(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/rotate-root"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAlicloudConfig Configure the access key and secret to use for RAM and STS calls.
func (a *Secrets) GetAlicloudConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/alicloud/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAlicloudCredsName Generate an API key or STS credential using the given role's configuration.'
// name: The name of the role.
func (a *Secrets) GetAlicloudCredsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/alicloud/creds/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAlicloudRole List the existing roles in this backend.
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetAlicloudRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/alicloud/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAlicloudRoleName Read, write and reference policies and roles that API keys or STS credentials can be made for.
// name: The name of the role.
func (a *Secrets) GetAlicloudRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/alicloud/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAwsConfigLease Configure the default lease information for generated credentials.
func (a *Secrets) GetAwsConfigLease(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/aws/config/lease"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAwsConfigRoot Configure the root credentials that are used to manage IAM.
func (a *Secrets) GetAwsConfigRoot(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/aws/config/root"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAwsCreds Generate AWS credentials from a specific Vault role.
func (a *Secrets) GetAwsCreds(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/aws/creds"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAwsRoles List the existing roles in this backend
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetAwsRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/aws/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAwsRolesName Read, write and reference IAM policies that access keys can be made for.
// name: Name of the policy
func (a *Secrets) GetAwsRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/aws/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAwsStsName Generate AWS credentials from a specific Vault role.
// name: Name of the role
func (a *Secrets) GetAwsStsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/aws/sts/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAzureConfig
func (a *Secrets) GetAzureConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/azure/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAzureCredsRole
// role: Name of the Vault role
func (a *Secrets) GetAzureCredsRole(ctx context.Context, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/azure/creds/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAzureRoles List existing roles.
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetAzureRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/azure/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetAzureRolesName Manage the Vault roles used to generate Azure credentials.
// name: Name of the role.
func (a *Secrets) GetAzureRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/azure/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetConsulConfigAccess
func (a *Secrets) GetConsulConfigAccess(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/consul/config/access"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetConsulCredsRole
// role: Name of the role.
func (a *Secrets) GetConsulCredsRole(ctx context.Context, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/consul/creds/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetConsulRoles
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetConsulRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/consul/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetConsulRolesName
// name: Name of the role.
func (a *Secrets) GetConsulRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/consul/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetCubbyholePath Retrieve the secret at the specified location.
// path: Specifies the path of the secret.
// list: Return a list if &#x60;true&#x60;
func (a *Secrets) GetCubbyholePath(ctx context.Context, path string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/cubbyhole/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpConfig
func (a *Secrets) GetGcpConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpKeyRoleset
// roleset: Required. Name of the role set.
func (a *Secrets) GetGcpKeyRoleset(ctx context.Context, roleset string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/key/{roleset}"
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpRolesetName
// name: Required. Name of the role.
func (a *Secrets) GetGcpRolesetName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/roleset/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpRolesetRolesetKey
// roleset: Required. Name of the role set.
func (a *Secrets) GetGcpRolesetRolesetKey(ctx context.Context, roleset string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/roleset/{roleset}/key"
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpRolesetRolesetToken
// roleset: Required. Name of the role set.
func (a *Secrets) GetGcpRolesetRolesetToken(ctx context.Context, roleset string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/roleset/{roleset}/token"
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpRolesets
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetGcpRolesets(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/rolesets"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpStaticAccountName
// name: Required. Name to refer to this static account in Vault. Cannot be updated.
func (a *Secrets) GetGcpStaticAccountName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/static-account/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpStaticAccountNameKey
// name: Required. Name of the static account.
func (a *Secrets) GetGcpStaticAccountNameKey(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/static-account/{name}/key"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpStaticAccountNameToken
// name: Required. Name of the static account.
func (a *Secrets) GetGcpStaticAccountNameToken(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/static-account/{name}/token"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpStaticAccounts
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetGcpStaticAccounts(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/static-accounts"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpTokenRoleset
// roleset: Required. Name of the role set.
func (a *Secrets) GetGcpTokenRoleset(ctx context.Context, roleset string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/token/{roleset}"
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpkmsConfig Configure the GCP KMS secrets engine
func (a *Secrets) GetGcpkmsConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpkmsKeys List named keys
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetGcpkmsKeys(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/keys"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpkmsKeysConfigKey Configure the key in Vault
// key: Name of the key in Vault.
func (a *Secrets) GetGcpkmsKeysConfigKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/keys/config/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpkmsKeysKey Interact with crypto keys in Vault and Google Cloud KMS
// key: Name of the key in Vault.
func (a *Secrets) GetGcpkmsKeysKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/keys/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetGcpkmsPubkeyKey Retrieve the public key associated with the named key
// key: Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.
func (a *Secrets) GetGcpkmsPubkeyKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/pubkey/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetKubernetesConfig
func (a *Secrets) GetKubernetesConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/kubernetes/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetKubernetesRoles
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetKubernetesRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/kubernetes/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetKubernetesRolesName
// name: Name of the role
func (a *Secrets) GetKubernetesRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/kubernetes/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetKvPath Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
// path: Location of the secret.
// list: Return a list if &#x60;true&#x60;
func (a *Secrets) GetKvPath(ctx context.Context, path string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/kv/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetMongodbatlasConfig Configure the  credentials that are used to manage Database Users.
func (a *Secrets) GetMongodbatlasConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/mongodbatlas/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetMongodbatlasCredsName Generate MongoDB Atlas Programmatic API from a specific Vault role.
// name: Name of the role
func (a *Secrets) GetMongodbatlasCredsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/mongodbatlas/creds/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetMongodbatlasRoles List the existing roles in this backend
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetMongodbatlasRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/mongodbatlas/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetMongodbatlasRolesName Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
// name: Name of the Roles
func (a *Secrets) GetMongodbatlasRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/mongodbatlas/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetNomadConfigAccess
func (a *Secrets) GetNomadConfigAccess(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/nomad/config/access"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetNomadConfigLease Configure the lease parameters for generated tokens
func (a *Secrets) GetNomadConfigLease(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/nomad/config/lease"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetNomadCredsName
// name: Name of the role
func (a *Secrets) GetNomadCredsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/nomad/creds/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetNomadRole
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetNomadRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/nomad/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetNomadRoleName
// name: Name of the role
func (a *Secrets) GetNomadRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/nomad/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetOpenldapConfig
func (a *Secrets) GetOpenldapConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetOpenldapCredsName
// name: Name of the dynamic role.
func (a *Secrets) GetOpenldapCredsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/creds/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetOpenldapRole
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetOpenldapRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetOpenldapRoleName
// name: Name of the role (lowercase)
func (a *Secrets) GetOpenldapRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetOpenldapStaticCredName
// name: Name of the static role.
func (a *Secrets) GetOpenldapStaticCredName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/static-cred/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetOpenldapStaticRole
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetOpenldapStaticRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/static-role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetOpenldapStaticRoleName
// name: Name of the role
func (a *Secrets) GetOpenldapStaticRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/static-role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiCa
func (a *Secrets) GetPkiCa(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/ca"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiCaChain
func (a *Secrets) GetPkiCaChain(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/ca_chain"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiCaPem
func (a *Secrets) GetPkiCaPem(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/ca/pem"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiCertCaChain
func (a *Secrets) GetPkiCertCaChain(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/cert/ca_chain"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiCertCrl
func (a *Secrets) GetPkiCertCrl(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/cert/crl"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiCertSerial
// serial: Certificate serial number, in colon- or hyphen-separated octal
func (a *Secrets) GetPkiCertSerial(ctx context.Context, serial string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/cert/{serial}"
	requestPath = strings.Replace(requestPath, "{"+"serial"+"}", url.PathEscape(serial), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiCertSerialRaw
// serial: Certificate serial number, in colon- or hyphen-separated octal
func (a *Secrets) GetPkiCertSerialRaw(ctx context.Context, serial string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/cert/{serial}/raw"
	requestPath = strings.Replace(requestPath, "{"+"serial"+"}", url.PathEscape(serial), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiCertSerialRawPem
// serial: Certificate serial number, in colon- or hyphen-separated octal
func (a *Secrets) GetPkiCertSerialRawPem(ctx context.Context, serial string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/cert/{serial}/raw/pem"
	requestPath = strings.Replace(requestPath, "{"+"serial"+"}", url.PathEscape(serial), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiCerts
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetPkiCerts(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/certs"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiConfigCrl
func (a *Secrets) GetPkiConfigCrl(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/config/crl"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiConfigIssuers
func (a *Secrets) GetPkiConfigIssuers(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/config/issuers"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiConfigKeys
func (a *Secrets) GetPkiConfigKeys(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/config/keys"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiConfigUrls
func (a *Secrets) GetPkiConfigUrls(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/config/urls"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiCrl
func (a *Secrets) GetPkiCrl(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/crl"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiCrlPem
func (a *Secrets) GetPkiCrlPem(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/crl/pem"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiCrlRotate
func (a *Secrets) GetPkiCrlRotate(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/crl/rotate"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiDer
func (a *Secrets) GetPkiDer(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki//der"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiIssuerRefCrlPem
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
func (a *Secrets) GetPkiIssuerRefCrlPem(ctx context.Context, issuerRef string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/{issuer_ref}/crl/pem"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiIssuerRefDerPem
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
func (a *Secrets) GetPkiIssuerRefDerPem(ctx context.Context, issuerRef string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/{issuer_ref}/der|/pem"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiIssuers
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetPkiIssuers(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/issuers"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiJson
func (a *Secrets) GetPkiJson(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki//json"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiKeyKeyRef
// keyRef: Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.
func (a *Secrets) GetPkiKeyKeyRef(ctx context.Context, keyRef string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/key/{key_ref}"
	requestPath = strings.Replace(requestPath, "{"+"key_ref"+"}", url.PathEscape(keyRef), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiKeys
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetPkiKeys(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/keys"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiRoles
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetPkiRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiRolesName
// name: Name of the role
func (a *Secrets) GetPkiRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetPkiTidyStatus
func (a *Secrets) GetPkiTidyStatus(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/tidy-status"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetRabbitmqConfigLease Configure the lease parameters for generated credentials
func (a *Secrets) GetRabbitmqConfigLease(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/rabbitmq/config/lease"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetRabbitmqCredsName Request RabbitMQ credentials for a certain role.
// name: Name of the role.
func (a *Secrets) GetRabbitmqCredsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/rabbitmq/creds/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetRabbitmqRoles Manage the roles that can be created with this backend.
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetRabbitmqRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/rabbitmq/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetRabbitmqRolesName Manage the roles that can be created with this backend.
// name: Name of the role.
func (a *Secrets) GetRabbitmqRolesName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/rabbitmq/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetSecretConfig Read the backend level settings.
func (a *Secrets) GetSecretConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/secret/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetSecretDataPath Write, Patch, Read, and Delete data in the Key-Value Store.
// path: Location of the secret.
func (a *Secrets) GetSecretDataPath(ctx context.Context, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/secret/data/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetSecretMetadataPath Configures settings for the KV store
// path: Location of the secret.
// list: Return a list if &#x60;true&#x60;
func (a *Secrets) GetSecretMetadataPath(ctx context.Context, path string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/secret/metadata/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetSecretSubkeysPath Read the structure of a secret entry from the Key-Value store with the values removed.
// path: Location of the secret.
func (a *Secrets) GetSecretSubkeysPath(ctx context.Context, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/secret/subkeys/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetSshConfigCa Set the SSH private key used for signing certificates.
func (a *Secrets) GetSshConfigCa(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/config/ca"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetSshConfigZeroaddress Assign zero address as default CIDR block for select roles.
func (a *Secrets) GetSshConfigZeroaddress(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/config/zeroaddress"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetSshPublicKey Retrieve the public key.
func (a *Secrets) GetSshPublicKey(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/public_key"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetSshRoles Manage the 'roles' that can be created with this backend.
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetSshRoles(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetSshRolesRole Manage the 'roles' that can be created with this backend.
// role: [Required for all types] Name of the role being created.
func (a *Secrets) GetSshRolesRole(ctx context.Context, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/roles/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTerraformConfig
func (a *Secrets) GetTerraformConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/terraform/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTerraformCredsName Generate a Terraform Cloud or Enterprise API token from a specific Vault role.
// name: Name of the role
func (a *Secrets) GetTerraformCredsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/terraform/creds/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTerraformRole
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetTerraformRole(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/terraform/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTerraformRoleName
// name: Name of the role
func (a *Secrets) GetTerraformRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/terraform/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTotpCodeName Request time-based one-time use password or validate a password for a certain key .
// name: Name of the key.
func (a *Secrets) GetTotpCodeName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/totp/code/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTotpKeys Manage the keys that can be created with this backend.
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetTotpKeys(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/totp/keys"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTotpKeysName Manage the keys that can be created with this backend.
// name: Name of the key.
func (a *Secrets) GetTotpKeysName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/totp/keys/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTransitBackupName Backup the named key
// name: Name of the key
func (a *Secrets) GetTransitBackupName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/backup/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTransitCacheConfig Returns the size of the active cache
func (a *Secrets) GetTransitCacheConfig(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/cache-config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTransitExportTypeName Export named encryption or signing key
// name: Name of the key
// type_: Type of key to export (encryption-key, signing-key, hmac-key)
func (a *Secrets) GetTransitExportTypeName(ctx context.Context, name string, type_ string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/export/{type}/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)
	requestPath = strings.Replace(requestPath, "{"+"type"+"}", url.PathEscape(type_), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTransitExportTypeNameVersion Export named encryption or signing key
// name: Name of the key
// type_: Type of key to export (encryption-key, signing-key, hmac-key)
// version: Version of the key
func (a *Secrets) GetTransitExportTypeNameVersion(ctx context.Context, name string, type_ string, version string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/export/{type}/{name}/{version}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)
	requestPath = strings.Replace(requestPath, "{"+"type"+"}", url.PathEscape(type_), -1)
	requestPath = strings.Replace(requestPath, "{"+"version"+"}", url.PathEscape(version), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTransitKeys Managed named encryption keys
// list: Must be set to &#x60;true&#x60;
func (a *Secrets) GetTransitKeys(ctx context.Context, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/keys"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTransitKeysName Managed named encryption keys
// name: Name of the key
func (a *Secrets) GetTransitKeysName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/keys/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// GetTransitWrappingKey Returns the public key to use for wrapping imported keys
func (a *Secrets) GetTransitWrappingKey(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/wrapping_key"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAdConfig Configure the AD server to connect to, along with password options.
func (a *Secrets) PostAdConfig(ctx context.Context, adConfigRequest AdConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, adConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAdLibraryManageNameCheckIn Check service accounts in to the library.
// name: Name of the set.
func (a *Secrets) PostAdLibraryManageNameCheckIn(ctx context.Context, name string, adLibraryManageCheckInRequest AdLibraryManageCheckInRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/library/manage/{name}/check-in"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, adLibraryManageCheckInRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAdLibraryName Update a library set.
// name: Name of the set.
func (a *Secrets) PostAdLibraryName(ctx context.Context, name string, adLibraryRequest AdLibraryRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/library/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, adLibraryRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAdLibraryNameCheckIn Check service accounts in to the library.
// name: Name of the set.
func (a *Secrets) PostAdLibraryNameCheckIn(ctx context.Context, name string, adLibraryCheckInRequest AdLibraryCheckInRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/library/{name}/check-in"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, adLibraryCheckInRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAdLibraryNameCheckOut Check a service account out from the library.
// name: Name of the set
func (a *Secrets) PostAdLibraryNameCheckOut(ctx context.Context, name string, adLibraryCheckOutRequest AdLibraryCheckOutRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/library/{name}/check-out"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, adLibraryCheckOutRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAdRolesName Manage roles to build links between Vault and Active Directory service accounts.
// name: Name of the role
func (a *Secrets) PostAdRolesName(ctx context.Context, name string, adRolesRequest AdRolesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, adRolesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAdRotateRoleName
// name: Name of the static role
func (a *Secrets) PostAdRotateRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/rotate-role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAdRotateRoot
func (a *Secrets) PostAdRotateRoot(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ad/rotate-root"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAlicloudConfig Configure the access key and secret to use for RAM and STS calls.
func (a *Secrets) PostAlicloudConfig(ctx context.Context, alicloudConfigRequest AlicloudConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/alicloud/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, alicloudConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAlicloudRoleName Read, write and reference policies and roles that API keys or STS credentials can be made for.
// name: The name of the role.
func (a *Secrets) PostAlicloudRoleName(ctx context.Context, name string, alicloudRoleRequest AlicloudRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/alicloud/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, alicloudRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAwsConfigLease Configure the default lease information for generated credentials.
func (a *Secrets) PostAwsConfigLease(ctx context.Context, awsConfigLeaseRequest AwsConfigLeaseRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/aws/config/lease"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigLeaseRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAwsConfigRoot Configure the root credentials that are used to manage IAM.
func (a *Secrets) PostAwsConfigRoot(ctx context.Context, awsConfigRootRequest AwsConfigRootRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/aws/config/root"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigRootRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAwsConfigRotateRoot
func (a *Secrets) PostAwsConfigRotateRoot(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/aws/config/rotate-root"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAwsCreds Generate AWS credentials from a specific Vault role.
func (a *Secrets) PostAwsCreds(ctx context.Context, awsCredsRequest AwsCredsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/aws/creds"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsCredsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAwsRolesName Read, write and reference IAM policies that access keys can be made for.
// name: Name of the policy
func (a *Secrets) PostAwsRolesName(ctx context.Context, name string, awsRolesRequest AwsRolesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/aws/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsRolesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAwsStsName Generate AWS credentials from a specific Vault role.
// name: Name of the role
func (a *Secrets) PostAwsStsName(ctx context.Context, name string, awsStsRequest AwsStsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/aws/sts/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsStsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAzureConfig
func (a *Secrets) PostAzureConfig(ctx context.Context, azureConfigRequest AzureConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/azure/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, azureConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAzureRolesName Manage the Vault roles used to generate Azure credentials.
// name: Name of the role.
func (a *Secrets) PostAzureRolesName(ctx context.Context, name string, azureRolesRequest AzureRolesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/azure/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, azureRolesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostAzureRotateRoot
func (a *Secrets) PostAzureRotateRoot(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/azure/rotate-root"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostConsulConfigAccess
func (a *Secrets) PostConsulConfigAccess(ctx context.Context, consulConfigAccessRequest ConsulConfigAccessRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/consul/config/access"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, consulConfigAccessRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostConsulRolesName
// name: Name of the role.
func (a *Secrets) PostConsulRolesName(ctx context.Context, name string, consulRolesRequest ConsulRolesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/consul/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, consulRolesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostCubbyholePath Store a secret at the specified location.
// path: Specifies the path of the secret.
func (a *Secrets) PostCubbyholePath(ctx context.Context, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/cubbyhole/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpConfig
func (a *Secrets) PostGcpConfig(ctx context.Context, gcpConfigRequest GcpConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpConfigRotateRoot
func (a *Secrets) PostGcpConfigRotateRoot(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/config/rotate-root"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpKeyRoleset
// roleset: Required. Name of the role set.
func (a *Secrets) PostGcpKeyRoleset(ctx context.Context, roleset string, gcpKeyRequest GcpKeyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/key/{roleset}"
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpKeyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpRolesetName
// name: Required. Name of the role.
func (a *Secrets) PostGcpRolesetName(ctx context.Context, name string, gcpRolesetRequest GcpRolesetRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/roleset/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpRolesetRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpRolesetNameRotate
// name: Name of the role.
func (a *Secrets) PostGcpRolesetNameRotate(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/roleset/{name}/rotate"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpRolesetNameRotateKey
// name: Name of the role.
func (a *Secrets) PostGcpRolesetNameRotateKey(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/roleset/{name}/rotate-key"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpRolesetRolesetKey
// roleset: Required. Name of the role set.
func (a *Secrets) PostGcpRolesetRolesetKey(ctx context.Context, roleset string, gcpRolesetKeyRequest GcpRolesetKeyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/roleset/{roleset}/key"
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpRolesetKeyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpRolesetRolesetToken
// roleset: Required. Name of the role set.
func (a *Secrets) PostGcpRolesetRolesetToken(ctx context.Context, roleset string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/roleset/{roleset}/token"
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpStaticAccountName
// name: Required. Name to refer to this static account in Vault. Cannot be updated.
func (a *Secrets) PostGcpStaticAccountName(ctx context.Context, name string, gcpStaticAccountRequest GcpStaticAccountRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/static-account/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpStaticAccountRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpStaticAccountNameKey
// name: Required. Name of the static account.
func (a *Secrets) PostGcpStaticAccountNameKey(ctx context.Context, name string, gcpStaticAccountKeyRequest GcpStaticAccountKeyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/static-account/{name}/key"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpStaticAccountKeyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpStaticAccountNameRotateKey
// name: Name of the account.
func (a *Secrets) PostGcpStaticAccountNameRotateKey(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/static-account/{name}/rotate-key"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpStaticAccountNameToken
// name: Required. Name of the static account.
func (a *Secrets) PostGcpStaticAccountNameToken(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/static-account/{name}/token"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpTokenRoleset
// roleset: Required. Name of the role set.
func (a *Secrets) PostGcpTokenRoleset(ctx context.Context, roleset string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcp/token/{roleset}"
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpkmsConfig Configure the GCP KMS secrets engine
func (a *Secrets) PostGcpkmsConfig(ctx context.Context, gcpkmsConfigRequest GcpkmsConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpkmsConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpkmsDecryptKey Decrypt a ciphertext value using a named key
// key: Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.
func (a *Secrets) PostGcpkmsDecryptKey(ctx context.Context, key string, gcpkmsDecryptRequest GcpkmsDecryptRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/decrypt/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpkmsDecryptRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpkmsEncryptKey Encrypt a plaintext value using a named key
// key: Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.
func (a *Secrets) PostGcpkmsEncryptKey(ctx context.Context, key string, gcpkmsEncryptRequest GcpkmsEncryptRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/encrypt/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpkmsEncryptRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpkmsKeysConfigKey Configure the key in Vault
// key: Name of the key in Vault.
func (a *Secrets) PostGcpkmsKeysConfigKey(ctx context.Context, key string, gcpkmsKeysConfigRequest GcpkmsKeysConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/keys/config/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpkmsKeysConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpkmsKeysDeregisterKey Deregister an existing key in Vault
// key: Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.
func (a *Secrets) PostGcpkmsKeysDeregisterKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/keys/deregister/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpkmsKeysKey Interact with crypto keys in Vault and Google Cloud KMS
// key: Name of the key in Vault.
func (a *Secrets) PostGcpkmsKeysKey(ctx context.Context, key string, gcpkmsKeysRequest GcpkmsKeysRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/keys/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpkmsKeysRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpkmsKeysRegisterKey Register an existing crypto key in Google Cloud KMS
// key: Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.
func (a *Secrets) PostGcpkmsKeysRegisterKey(ctx context.Context, key string, gcpkmsKeysRegisterRequest GcpkmsKeysRegisterRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/keys/register/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpkmsKeysRegisterRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpkmsKeysRotateKey Rotate a crypto key to a new primary version
// key: Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.
func (a *Secrets) PostGcpkmsKeysRotateKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/keys/rotate/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpkmsKeysTrimKey Delete old crypto key versions from Google Cloud KMS
// key: Name of the key in Vault.
func (a *Secrets) PostGcpkmsKeysTrimKey(ctx context.Context, key string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/keys/trim/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpkmsReencryptKey Re-encrypt existing ciphertext data to a new version
// key: Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.
func (a *Secrets) PostGcpkmsReencryptKey(ctx context.Context, key string, gcpkmsReencryptRequest GcpkmsReencryptRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/reencrypt/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpkmsReencryptRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpkmsSignKey Signs a message or digest using a named key
// key: Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.
func (a *Secrets) PostGcpkmsSignKey(ctx context.Context, key string, gcpkmsSignRequest GcpkmsSignRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/sign/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpkmsSignRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostGcpkmsVerifyKey Verify a signature using a named key
// key: Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.
func (a *Secrets) PostGcpkmsVerifyKey(ctx context.Context, key string, gcpkmsVerifyRequest GcpkmsVerifyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/gcpkms/verify/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpkmsVerifyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostKubernetesConfig
func (a *Secrets) PostKubernetesConfig(ctx context.Context, kubernetesConfigRequest KubernetesConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/kubernetes/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kubernetesConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostKubernetesCredsName
// name: Name of the Vault role
func (a *Secrets) PostKubernetesCredsName(ctx context.Context, name string, kubernetesCredsRequest KubernetesCredsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/kubernetes/creds/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kubernetesCredsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostKubernetesRolesName
// name: Name of the role
func (a *Secrets) PostKubernetesRolesName(ctx context.Context, name string, kubernetesRolesRequest KubernetesRolesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/kubernetes/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kubernetesRolesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostKvPath Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.
// path: Location of the secret.
func (a *Secrets) PostKvPath(ctx context.Context, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/kv/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostMongodbatlasConfig Configure the  credentials that are used to manage Database Users.
func (a *Secrets) PostMongodbatlasConfig(ctx context.Context, mongodbatlasConfigRequest MongodbatlasConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/mongodbatlas/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, mongodbatlasConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostMongodbatlasCredsName Generate MongoDB Atlas Programmatic API from a specific Vault role.
// name: Name of the role
func (a *Secrets) PostMongodbatlasCredsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/mongodbatlas/creds/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostMongodbatlasRolesName Manage the roles used to generate MongoDB Atlas Programmatic API Keys.
// name: Name of the Roles
func (a *Secrets) PostMongodbatlasRolesName(ctx context.Context, name string, mongodbatlasRolesRequest MongodbatlasRolesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/mongodbatlas/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, mongodbatlasRolesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostNomadConfigAccess
func (a *Secrets) PostNomadConfigAccess(ctx context.Context, nomadConfigAccessRequest NomadConfigAccessRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/nomad/config/access"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, nomadConfigAccessRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostNomadConfigLease Configure the lease parameters for generated tokens
func (a *Secrets) PostNomadConfigLease(ctx context.Context, nomadConfigLeaseRequest NomadConfigLeaseRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/nomad/config/lease"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, nomadConfigLeaseRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostNomadRoleName
// name: Name of the role
func (a *Secrets) PostNomadRoleName(ctx context.Context, name string, nomadRoleRequest NomadRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/nomad/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, nomadRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostOpenldapConfig
func (a *Secrets) PostOpenldapConfig(ctx context.Context, openldapConfigRequest OpenldapConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, openldapConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostOpenldapRoleName
// name: Name of the role (lowercase)
func (a *Secrets) PostOpenldapRoleName(ctx context.Context, name string, openldapRoleRequest OpenldapRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, openldapRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostOpenldapRotateRoleName
// name: Name of the static role
func (a *Secrets) PostOpenldapRotateRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/rotate-role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostOpenldapRotateRoot
func (a *Secrets) PostOpenldapRotateRoot(ctx context.Context) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/rotate-root"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostOpenldapStaticRoleName
// name: Name of the role
func (a *Secrets) PostOpenldapStaticRoleName(ctx context.Context, name string, openldapStaticRoleRequest OpenldapStaticRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/openldap/static-role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, openldapStaticRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiBundle
func (a *Secrets) PostPkiBundle(ctx context.Context, pkiBundleRequest PkiBundleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/bundle"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiBundleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiCert
func (a *Secrets) PostPkiCert(ctx context.Context, pkiCertRequest PkiCertRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/cert"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiCertRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiConfigCa
func (a *Secrets) PostPkiConfigCa(ctx context.Context, pkiConfigCaRequest PkiConfigCaRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/config/ca"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiConfigCaRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiConfigCrl
func (a *Secrets) PostPkiConfigCrl(ctx context.Context, pkiConfigCrlRequest PkiConfigCrlRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/config/crl"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiConfigCrlRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiConfigIssuers
func (a *Secrets) PostPkiConfigIssuers(ctx context.Context, pkiConfigIssuersRequest PkiConfigIssuersRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/config/issuers"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiConfigIssuersRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiConfigKeys
func (a *Secrets) PostPkiConfigKeys(ctx context.Context, pkiConfigKeysRequest PkiConfigKeysRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/config/keys"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiConfigKeysRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiConfigUrls
func (a *Secrets) PostPkiConfigUrls(ctx context.Context, pkiConfigUrlsRequest PkiConfigUrlsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/config/urls"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiConfigUrlsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiIntermediateCrossSign
func (a *Secrets) PostPkiIntermediateCrossSign(ctx context.Context, pkiIntermediateCrossSignRequest PkiIntermediateCrossSignRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/intermediate/cross-sign"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiIntermediateCrossSignRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiIntermediateGenerateExported
// exported: Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!
func (a *Secrets) PostPkiIntermediateGenerateExported(ctx context.Context, exported string, pkiIntermediateGenerateRequest PkiIntermediateGenerateRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/intermediate/generate/{exported}"
	requestPath = strings.Replace(requestPath, "{"+"exported"+"}", url.PathEscape(exported), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiIntermediateGenerateRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiIntermediateSetSigned
func (a *Secrets) PostPkiIntermediateSetSigned(ctx context.Context, pkiIntermediateSetSignedRequest PkiIntermediateSetSignedRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/intermediate/set-signed"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiIntermediateSetSignedRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiInternalExported
func (a *Secrets) PostPkiInternalExported(ctx context.Context, pkiInternalExportedRequest PkiInternalExportedRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/internal|exported"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiInternalExportedRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiIssueRole
// role: The desired role with configuration for this request
func (a *Secrets) PostPkiIssueRole(ctx context.Context, role string, pkiIssueRequest PkiIssueRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/issue/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiIssueRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiIssuerIssuerRefIssueRole
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
// role: The desired role with configuration for this request
func (a *Secrets) PostPkiIssuerIssuerRefIssueRole(ctx context.Context, issuerRef string, role string, pkiIssuerIssueRequest PkiIssuerIssueRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/issuer/{issuer_ref}/issue/{role}"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiIssuerIssueRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiIssuerIssuerRefSignIntermediate
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
func (a *Secrets) PostPkiIssuerIssuerRefSignIntermediate(ctx context.Context, issuerRef string, pkiIssuerSignIntermediateRequest PkiIssuerSignIntermediateRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/issuer/{issuer_ref}/sign-intermediate"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiIssuerSignIntermediateRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiIssuerIssuerRefSignRole
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
// role: The desired role with configuration for this request
func (a *Secrets) PostPkiIssuerIssuerRefSignRole(ctx context.Context, issuerRef string, role string, pkiIssuerSignRequest PkiIssuerSignRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/issuer/{issuer_ref}/sign/{role}"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiIssuerSignRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiIssuerIssuerRefSignSelfIssued
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
func (a *Secrets) PostPkiIssuerIssuerRefSignSelfIssued(ctx context.Context, issuerRef string, pkiIssuerSignSelfIssuedRequest PkiIssuerSignSelfIssuedRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/issuer/{issuer_ref}/sign-self-issued"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiIssuerSignSelfIssuedRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiIssuerIssuerRefSignVerbatim
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
func (a *Secrets) PostPkiIssuerIssuerRefSignVerbatim(ctx context.Context, issuerRef string, pkiIssuerSignVerbatimRequest PkiIssuerSignVerbatimRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/issuer/{issuer_ref}/sign-verbatim"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiIssuerSignVerbatimRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiIssuerIssuerRefSignVerbatimRole
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
// role: The desired role with configuration for this request
func (a *Secrets) PostPkiIssuerIssuerRefSignVerbatimRole(ctx context.Context, issuerRef string, role string, pkiIssuerSignVerbatimRequest PkiIssuerSignVerbatimRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/issuer/{issuer_ref}/sign-verbatim/{role}"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiIssuerSignVerbatimRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiIssuerRefDerPem
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
func (a *Secrets) PostPkiIssuerRefDerPem(ctx context.Context, issuerRef string, pkiDerPemRequest PkiDerPemRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/{issuer_ref}/der|/pem"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiDerPemRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiIssuersGenerateIntermediateExported
// exported: Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!
func (a *Secrets) PostPkiIssuersGenerateIntermediateExported(ctx context.Context, exported string, pkiIssuersGenerateIntermediateRequest PkiIssuersGenerateIntermediateRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/issuers/generate/intermediate/{exported}"
	requestPath = strings.Replace(requestPath, "{"+"exported"+"}", url.PathEscape(exported), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiIssuersGenerateIntermediateRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiIssuersGenerateRootExported
// exported: Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!
func (a *Secrets) PostPkiIssuersGenerateRootExported(ctx context.Context, exported string, pkiIssuersGenerateRootRequest PkiIssuersGenerateRootRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/issuers/generate/root/{exported}"
	requestPath = strings.Replace(requestPath, "{"+"exported"+"}", url.PathEscape(exported), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiIssuersGenerateRootRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiJson
func (a *Secrets) PostPkiJson(ctx context.Context, pkiJsonRequest PkiJsonRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki//json"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiJsonRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiKeyKeyRef
// keyRef: Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.
func (a *Secrets) PostPkiKeyKeyRef(ctx context.Context, keyRef string, pkiKeyRequest PkiKeyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/key/{key_ref}"
	requestPath = strings.Replace(requestPath, "{"+"key_ref"+"}", url.PathEscape(keyRef), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiKeyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiKeysImport
func (a *Secrets) PostPkiKeysImport(ctx context.Context, pkiKeysImportRequest PkiKeysImportRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/keys/import"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiKeysImportRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiKms
func (a *Secrets) PostPkiKms(ctx context.Context, pkiKmsRequest PkiKmsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/kms"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiKmsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiRevoke
func (a *Secrets) PostPkiRevoke(ctx context.Context, pkiRevokeRequest PkiRevokeRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/revoke"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiRevokeRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiRolesName
// name: Name of the role
func (a *Secrets) PostPkiRolesName(ctx context.Context, name string, pkiRolesRequest PkiRolesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiRolesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiRootGenerateExported
// exported: Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!
func (a *Secrets) PostPkiRootGenerateExported(ctx context.Context, exported string, pkiRootGenerateRequest PkiRootGenerateRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/root/generate/{exported}"
	requestPath = strings.Replace(requestPath, "{"+"exported"+"}", url.PathEscape(exported), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiRootGenerateRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiRootReplace
func (a *Secrets) PostPkiRootReplace(ctx context.Context, pkiRootReplaceRequest PkiRootReplaceRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/root/replace"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiRootReplaceRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiRootRotateExported
// exported: Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!
func (a *Secrets) PostPkiRootRotateExported(ctx context.Context, exported string, pkiRootRotateRequest PkiRootRotateRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/root/rotate/{exported}"
	requestPath = strings.Replace(requestPath, "{"+"exported"+"}", url.PathEscape(exported), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiRootRotateRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiRootSignIntermediate
func (a *Secrets) PostPkiRootSignIntermediate(ctx context.Context, pkiRootSignIntermediateRequest PkiRootSignIntermediateRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/root/sign-intermediate"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiRootSignIntermediateRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiRootSignSelfIssued
func (a *Secrets) PostPkiRootSignSelfIssued(ctx context.Context, pkiRootSignSelfIssuedRequest PkiRootSignSelfIssuedRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/root/sign-self-issued"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiRootSignSelfIssuedRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiSignRole
// role: The desired role with configuration for this request
func (a *Secrets) PostPkiSignRole(ctx context.Context, role string, pkiSignRequest PkiSignRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/sign/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiSignRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiSignVerbatim
func (a *Secrets) PostPkiSignVerbatim(ctx context.Context, pkiSignVerbatimRequest PkiSignVerbatimRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/sign-verbatim"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiSignVerbatimRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiSignVerbatimRole
// role: The desired role with configuration for this request
func (a *Secrets) PostPkiSignVerbatimRole(ctx context.Context, role string, pkiSignVerbatimRequest PkiSignVerbatimRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/sign-verbatim/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiSignVerbatimRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostPkiTidy
func (a *Secrets) PostPkiTidy(ctx context.Context, pkiTidyRequest PkiTidyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/pki/tidy"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, pkiTidyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostRabbitmqConfigConnection Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API.
func (a *Secrets) PostRabbitmqConfigConnection(ctx context.Context, rabbitmqConfigConnectionRequest RabbitmqConfigConnectionRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/rabbitmq/config/connection"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, rabbitmqConfigConnectionRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostRabbitmqConfigLease Configure the lease parameters for generated credentials
func (a *Secrets) PostRabbitmqConfigLease(ctx context.Context, rabbitmqConfigLeaseRequest RabbitmqConfigLeaseRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/rabbitmq/config/lease"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, rabbitmqConfigLeaseRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostRabbitmqRolesName Manage the roles that can be created with this backend.
// name: Name of the role.
func (a *Secrets) PostRabbitmqRolesName(ctx context.Context, name string, rabbitmqRolesRequest RabbitmqRolesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/rabbitmq/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, rabbitmqRolesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSecretConfig Configure backend level settings that are applied to every key in the key-value store.
func (a *Secrets) PostSecretConfig(ctx context.Context, kvConfigRequest KvConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/secret/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kvConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSecretDataPath Write, Patch, Read, and Delete data in the Key-Value Store.
// path: Location of the secret.
func (a *Secrets) PostSecretDataPath(ctx context.Context, path string, kvDataRequest KvDataRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/secret/data/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kvDataRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSecretDeletePath Marks one or more versions as deleted in the KV store.
// path: Location of the secret.
func (a *Secrets) PostSecretDeletePath(ctx context.Context, path string, kvDeleteRequest KvDeleteRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/secret/delete/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kvDeleteRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSecretDestroyPath Permanently removes one or more versions in the KV store
// path: Location of the secret.
func (a *Secrets) PostSecretDestroyPath(ctx context.Context, path string, kvDestroyRequest KvDestroyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/secret/destroy/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kvDestroyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSecretMetadataPath Configures settings for the KV store
// path: Location of the secret.
func (a *Secrets) PostSecretMetadataPath(ctx context.Context, path string, kvMetadataRequest KvMetadataRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/secret/metadata/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kvMetadataRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSecretUndeletePath Undeletes one or more versions from the KV store.
// path: Location of the secret.
func (a *Secrets) PostSecretUndeletePath(ctx context.Context, path string, kvUndeleteRequest KvUndeleteRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/secret/undelete/{path}"
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kvUndeleteRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSshConfigCa Set the SSH private key used for signing certificates.
func (a *Secrets) PostSshConfigCa(ctx context.Context, sshConfigCaRequest SshConfigCaRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/config/ca"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, sshConfigCaRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSshConfigZeroaddress Assign zero address as default CIDR block for select roles.
func (a *Secrets) PostSshConfigZeroaddress(ctx context.Context, sshConfigZeroaddressRequest SshConfigZeroaddressRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/config/zeroaddress"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, sshConfigZeroaddressRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSshCredsRole Creates a credential for establishing SSH connection with the remote host.
// role: [Required] Name of the role
func (a *Secrets) PostSshCredsRole(ctx context.Context, role string, sshCredsRequest SshCredsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/creds/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, sshCredsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSshKeysKeyName Register a shared private key with Vault.
// keyName: [Required] Name of the key
func (a *Secrets) PostSshKeysKeyName(ctx context.Context, keyName string, sshKeysRequest SshKeysRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/keys/{key_name}"
	requestPath = strings.Replace(requestPath, "{"+"key_name"+"}", url.PathEscape(keyName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, sshKeysRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSshLookup List all the roles associated with the given IP address.
func (a *Secrets) PostSshLookup(ctx context.Context, sshLookupRequest SshLookupRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/lookup"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, sshLookupRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSshRolesRole Manage the 'roles' that can be created with this backend.
// role: [Required for all types] Name of the role being created.
func (a *Secrets) PostSshRolesRole(ctx context.Context, role string, sshRolesRequest SshRolesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/roles/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, sshRolesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSshSignRole Request signing an SSH key using a certain role with the provided details.
// role: The desired role with configuration for this request.
func (a *Secrets) PostSshSignRole(ctx context.Context, role string, sshSignRequest SshSignRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/sign/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, sshSignRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostSshVerify Validate the OTP provided by Vault SSH Agent.
func (a *Secrets) PostSshVerify(ctx context.Context, sshVerifyRequest SshVerifyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/ssh/verify"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, sshVerifyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTerraformConfig
func (a *Secrets) PostTerraformConfig(ctx context.Context, terraformConfigRequest TerraformConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/terraform/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, terraformConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTerraformCredsName Generate a Terraform Cloud or Enterprise API token from a specific Vault role.
// name: Name of the role
func (a *Secrets) PostTerraformCredsName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/terraform/creds/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTerraformRoleName
// name: Name of the role
func (a *Secrets) PostTerraformRoleName(ctx context.Context, name string, terraformRoleRequest TerraformRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/terraform/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, terraformRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTerraformRotateRoleName
// name: Name of the team or organization role
func (a *Secrets) PostTerraformRotateRoleName(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/terraform/rotate-role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTotpCodeName Request time-based one-time use password or validate a password for a certain key .
// name: Name of the key.
func (a *Secrets) PostTotpCodeName(ctx context.Context, name string, totpCodeRequest TotpCodeRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/totp/code/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, totpCodeRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTotpKeysName Manage the keys that can be created with this backend.
// name: Name of the key.
func (a *Secrets) PostTotpKeysName(ctx context.Context, name string, totpKeysRequest TotpKeysRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/totp/keys/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, totpKeysRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitCacheConfig Configures a new cache of the specified size
func (a *Secrets) PostTransitCacheConfig(ctx context.Context, transitCacheConfigRequest TransitCacheConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/cache-config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitCacheConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitDatakeyPlaintextName Generate a data key
// name: The backend key used for encrypting the data key
// plaintext: \&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.
func (a *Secrets) PostTransitDatakeyPlaintextName(ctx context.Context, name string, plaintext string, transitDatakeyRequest TransitDatakeyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/datakey/{plaintext}/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)
	requestPath = strings.Replace(requestPath, "{"+"plaintext"+"}", url.PathEscape(plaintext), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitDatakeyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitDecryptName Decrypt a ciphertext value using a named key
// name: Name of the policy
func (a *Secrets) PostTransitDecryptName(ctx context.Context, name string, transitDecryptRequest TransitDecryptRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/decrypt/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitDecryptRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitEncryptName Encrypt a plaintext value or a batch of plaintext blocks using a named key
// name: Name of the policy
func (a *Secrets) PostTransitEncryptName(ctx context.Context, name string, transitEncryptRequest TransitEncryptRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/encrypt/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitEncryptRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitHash Generate a hash sum for input data
func (a *Secrets) PostTransitHash(ctx context.Context, transitHashRequest TransitHashRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/hash"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitHashRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitHashUrlalgorithm Generate a hash sum for input data
// urlalgorithm: Algorithm to use (POST URL parameter)
func (a *Secrets) PostTransitHashUrlalgorithm(ctx context.Context, urlalgorithm string, transitHashRequest TransitHashRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/hash/{urlalgorithm}"
	requestPath = strings.Replace(requestPath, "{"+"urlalgorithm"+"}", url.PathEscape(urlalgorithm), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitHashRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitHmacName Generate an HMAC for input data using the named key
// name: The key to use for the HMAC function
func (a *Secrets) PostTransitHmacName(ctx context.Context, name string, transitHmacRequest TransitHmacRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/hmac/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitHmacRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitHmacNameUrlalgorithm Generate an HMAC for input data using the named key
// name: The key to use for the HMAC function
// urlalgorithm: Algorithm to use (POST URL parameter)
func (a *Secrets) PostTransitHmacNameUrlalgorithm(ctx context.Context, name string, urlalgorithm string, transitHmacRequest TransitHmacRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/hmac/{name}/{urlalgorithm}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)
	requestPath = strings.Replace(requestPath, "{"+"urlalgorithm"+"}", url.PathEscape(urlalgorithm), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitHmacRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitKeysName Managed named encryption keys
// name: Name of the key
func (a *Secrets) PostTransitKeysName(ctx context.Context, name string, transitKeysRequest TransitKeysRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/keys/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitKeysRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitKeysNameConfig Configure a named encryption key
// name: Name of the key
func (a *Secrets) PostTransitKeysNameConfig(ctx context.Context, name string, transitKeysConfigRequest TransitKeysConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/keys/{name}/config"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitKeysConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitKeysNameImport Imports an externally-generated key into a new transit key
// name: The name of the key
func (a *Secrets) PostTransitKeysNameImport(ctx context.Context, name string, transitKeysImportRequest TransitKeysImportRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/keys/{name}/import"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitKeysImportRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitKeysNameImportVersion Imports an externally-generated key into an existing imported key
// name: The name of the key
func (a *Secrets) PostTransitKeysNameImportVersion(ctx context.Context, name string, transitKeysImportVersionRequest TransitKeysImportVersionRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/keys/{name}/import_version"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitKeysImportVersionRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitKeysNameRotate Rotate named encryption key
// name: Name of the key
func (a *Secrets) PostTransitKeysNameRotate(ctx context.Context, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/keys/{name}/rotate"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitKeysNameTrim Trim key versions of a named key
// name: Name of the key
func (a *Secrets) PostTransitKeysNameTrim(ctx context.Context, name string, transitKeysTrimRequest TransitKeysTrimRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/keys/{name}/trim"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitKeysTrimRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitRandom Generate random bytes
func (a *Secrets) PostTransitRandom(ctx context.Context, transitRandomRequest TransitRandomRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/random"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitRandomRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitRandomSource Generate random bytes
// source: Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.
func (a *Secrets) PostTransitRandomSource(ctx context.Context, source string, transitRandomRequest TransitRandomRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/random/{source}"
	requestPath = strings.Replace(requestPath, "{"+"source"+"}", url.PathEscape(source), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitRandomRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitRandomSourceUrlbytes Generate random bytes
// source: Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.
// urlbytes: The number of bytes to generate (POST URL parameter)
func (a *Secrets) PostTransitRandomSourceUrlbytes(ctx context.Context, source string, urlbytes string, transitRandomRequest TransitRandomRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/random/{source}/{urlbytes}"
	requestPath = strings.Replace(requestPath, "{"+"source"+"}", url.PathEscape(source), -1)
	requestPath = strings.Replace(requestPath, "{"+"urlbytes"+"}", url.PathEscape(urlbytes), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitRandomRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitRandomUrlbytes Generate random bytes
// urlbytes: The number of bytes to generate (POST URL parameter)
func (a *Secrets) PostTransitRandomUrlbytes(ctx context.Context, urlbytes string, transitRandomRequest TransitRandomRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/random/{urlbytes}"
	requestPath = strings.Replace(requestPath, "{"+"urlbytes"+"}", url.PathEscape(urlbytes), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitRandomRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitRestore Restore the named key
func (a *Secrets) PostTransitRestore(ctx context.Context, transitRestoreRequest TransitRestoreRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/restore"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitRestoreRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitRestoreName Restore the named key
// name: If set, this will be the name of the restored key.
func (a *Secrets) PostTransitRestoreName(ctx context.Context, name string, transitRestoreRequest TransitRestoreRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/restore/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitRestoreRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitRewrapName Rewrap ciphertext
// name: Name of the key
func (a *Secrets) PostTransitRewrapName(ctx context.Context, name string, transitRewrapRequest TransitRewrapRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/rewrap/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitRewrapRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitSignName Generate a signature for input data using the named key
// name: The key to use
func (a *Secrets) PostTransitSignName(ctx context.Context, name string, transitSignRequest TransitSignRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/sign/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitSignRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitSignNameUrlalgorithm Generate a signature for input data using the named key
// name: The key to use
// urlalgorithm: Hash algorithm to use (POST URL parameter)
func (a *Secrets) PostTransitSignNameUrlalgorithm(ctx context.Context, name string, urlalgorithm string, transitSignRequest TransitSignRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/sign/{name}/{urlalgorithm}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)
	requestPath = strings.Replace(requestPath, "{"+"urlalgorithm"+"}", url.PathEscape(urlalgorithm), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitSignRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitVerifyName Verify a signature or HMAC for input data created using the named key
// name: The key to use
func (a *Secrets) PostTransitVerifyName(ctx context.Context, name string, transitVerifyRequest TransitVerifyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/verify/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitVerifyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}

// PostTransitVerifyNameUrlalgorithm Verify a signature or HMAC for input data created using the named key
// name: The key to use
// urlalgorithm: Hash algorithm to use (POST URL parameter)
func (a *Secrets) PostTransitVerifyNameUrlalgorithm(ctx context.Context, name string, urlalgorithm string, transitVerifyRequest TransitVerifyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/transit/verify/{name}/{urlalgorithm}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)
	requestPath = strings.Replace(requestPath, "{"+"urlalgorithm"+"}", url.PathEscape(urlalgorithm), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, transitVerifyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return nil, err
	}
	defer resp.Body.Close()

	return parseResponse[map[string]interface{}](resp.Body)
}
