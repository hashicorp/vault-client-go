// {{classname}} {{{description}}}{{#unless description}}struct for {{{classname}}}{{/unless}}
type {{classname}} struct {
{{#with parent}}
{{#unless isMap}}
{{#unless isArray}}
	{{{parent}}}
{{/unless}}
{{/unless}}
{{#if isArray}}
	Items {{{parent}}}
{{/if}}
{{/with}}
{{#each vars}}
{{#unless @first}}
{{/unless}}
{{#with description}}
	// {{{.}}}
{{/with}}
{{#with deprecated}}
	// Deprecated
{{/with}}
	{{name}} {{{dataType}}} `json:"{{baseName}}"{{#with withXml}} xml:"{{baseName}}{{#if isXmlAttribute}},attr{{/if}}"{{/with}}{{#with vendorExtensions.x-go-custom-tag}} {{{.}}}{{/with}}`
{{/each}}
{{#if isAdditionalPropertiesTrue}}
	AdditionalProperties map[string]interface{}
{{/if}}
}

{{#if isAdditionalPropertiesTrue}}
type _{{{classname}}} {{{classname}}}

{{/if}}
// New{{classname}}WithDefaults instantiates a new {{classname}} object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func New{{classname}}WithDefaults() *{{classname}} {
	var this {{classname}}

{{#each vars}}
{{#with defaultValue}}
{{#unless vendorExtensions.x-golang-is-container}}
{{#unless isReadOnly}}
	this.{{name}} = {{{.}}}
{{/unless}}
{{/unless}}
{{/with}}
{{/each}}

	return &this
}

func (o {{classname}}) MarshalJSON() ([]byte, error) {
	toSerialize := {{#if isArray}}make([]interface{}, len(o.Items)){{/if}}{{#unless isArray}}make(map[string]interface{}){{/unless}}

	{{#with parent}}
	{{#unless isMap}}
	{{#unless isArray}}
	serialized{{parent}}, err{{parent}} := json.Marshal(o.{{parent}})
	if err{{parent}} != nil {
		return []byte{}, err{{parent}}
	}
	err{{parent}} = json.Unmarshal([]byte(serialized{{parent}}), &toSerialize)
	if err{{parent}} != nil {
		return []byte{}, err{{parent}}
	}
	{{/unless}}
	{{/unless}}
	{{#if isArray}}
	for i, item := range o.Items {
		toSerialize[i] = item
	}
	{{/if}}
	{{/with}}
	{{#each vars}}
	toSerialize["{{baseName}}"] = o.{{name}}
	{{/each}}
	{{#if isAdditionalPropertiesTrue}}

	for key, value := range o.AdditionalProperties {
		toSerialize[key] = value
	}
	{{/if}}

	return json.Marshal(toSerialize)
}

{{#if isAdditionalPropertiesTrue}}
func (o *{{{classname}}}) UnmarshalJSON(bytes []byte) (err error) {
{{#with parent}}
{{#unless isMap}}
	type {{classname}}WithoutEmbeddedStruct struct {
	{{#each vars}}
	{{#unless @first}}
	{{/unless}}
	{{#with description}}
		// {{{.}}}
	{{/with}}
	{{#with deprecated}}
		// Deprecated
	{{/with}}
		{{name}} {{{dataType}}} `json:"{{baseName}}"{{#with withXml}} xml:"{{baseName}}{{#if isXmlAttribute}},attr{{/if}}"{{/with}}{{#with vendorExtensions.x-go-custom-tag}} {{{.}}}{{/with}}`
	{{/each}}
	}

	var{{{classname}}}WithoutEmbeddedStruct := {{{classname}}}WithoutEmbeddedStruct{}

	err = json.Unmarshal(bytes, &var{{{classname}}}WithoutEmbeddedStruct)
	if err == nil {
		var{{{classname}}} := _{{{classname}}}{}
		{{#each vars}}
		var{{{classname}}}.{{{name}}} = var{{{classname}}}WithoutEmbeddedStruct.{{{name}}}
		{{/each}}
		*o = {{{classname}}}(var{{{classname}}})
	} else {
		return err
	}

	var{{{classname}}} := _{{{classname}}}{}

	err = json.Unmarshal(bytes, &var{{{classname}}})
	if err == nil {
		o.{{{parent}}} = var{{{classname}}}.{{{parent}}}
	} else {
		return err
	}

	additionalProperties := make(map[string]interface{})

	if err = json.Unmarshal(bytes, &additionalProperties); err == nil {
		{{#each vars}}
		delete(additionalProperties, "{{{baseName}}}")
		{{/each}}

		// remove fields from embedded structs
		reflect{{{parent}}} := reflect.ValueOf(o.{{{parent}}})
		for i := 0; i < reflect{{{parent}}}.Type().NumField(); i++ {
			t := reflect{{{parent}}}.Type().Field(i)

			if jsonTag := t.Tag.Get("json"); jsonTag != "" {
				fieldName := ""
				if commaIdx := strings.Index(jsonTag, ","); commaIdx > 0 {
					fieldName = jsonTag[:commaIdx]
				} else {
					fieldName = jsonTag
				}
				if fieldName != "AdditionalProperties" {
					delete(additionalProperties, fieldName)
				}
			}
		}

		o.AdditionalProperties = additionalProperties
	}

	return err
{{/unless}}
{{#if isMap}}
	var{{{classname}}} := _{{{classname}}}{}

	if err = json.Unmarshal(bytes, &var{{{classname}}}); err == nil {
		*o = {{{classname}}}(var{{{classname}}})
	}

	additionalProperties := make(map[string]interface{})

	if err = json.Unmarshal(bytes, &additionalProperties); err == nil {
		{{#each vars}}
		delete(additionalProperties, "{{{baseName}}}")
		{{/each}}
		o.AdditionalProperties = additionalProperties
	}

	return err
{{/if}}
{{/with}}
{{#unless parent}}
	var{{{classname}}} := _{{{classname}}}{}

	if err = json.Unmarshal(bytes, &var{{{classname}}}); err == nil {
		*o = {{{classname}}}(var{{{classname}}})
	}

	additionalProperties := make(map[string]interface{})

	if err = json.Unmarshal(bytes, &additionalProperties); err == nil {
		{{#each vars}}
		delete(additionalProperties, "{{{baseName}}}")
		{{/each}}
		o.AdditionalProperties = additionalProperties
	}

	return err
{{/unless}}
}

{{/if}}
{{#if isArray}}
func (o *{{{classname}}}) UnmarshalJSON(bytes []byte) (err error) {
	return json.Unmarshal(bytes, &o.Items)
}

{{/if}}
{{>nullable_model}}
