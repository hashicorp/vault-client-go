/*
HashiCorp Vault API

HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.

API version: 1.13.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package vault

import (
	"context"
	"net/http"
	"net/url"
	"strings"
)

// Secrets is a simple wrapper around the client for Secrets requests
type Secrets struct {
	client *Client
}

// DeleteAwsRolesName Read, write and reference IAM policies that access keys can be made for.
// name: Name of the policy
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteAwsRolesName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteCubbyholePath Deletes the secret at the specified location.
// path: Specifies the path of the secret.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteCubbyholePath(ctx context.Context, mountPath string, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/{path}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteGcpRolesetName
// name: Required. Name of the role.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteGcpRolesetName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roleset/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteGcpStaticAccountName
// name: Required. Name to refer to this static account in Vault. Cannot be updated.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteGcpStaticAccountName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-account/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteGcpkmsKeysDeregisterKey Deregister an existing key in Vault
// key: Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteGcpkmsKeysDeregisterKey(ctx context.Context, key string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/deregister/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteGcpkmsKeysKey Interact with crypto keys in Vault and Google Cloud KMS
// key: Name of the key in Vault.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteGcpkmsKeysKey(ctx context.Context, key string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteGcpkmsKeysTrimKey Delete old crypto key versions from Google Cloud KMS
// key: Name of the key in Vault.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteGcpkmsKeysTrimKey(ctx context.Context, key string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/trim/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteLdapLibraryName Delete a library set.
// name: Name of the set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteLdapLibraryName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/library/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteLdapRoleName
// name: Name of the role (lowercase)
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteLdapRoleName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteLdapStaticRoleName
// name: Name of the role
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteLdapStaticRoleName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteNomadConfigAccess
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteNomadConfigAccess(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/access"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeletePkiIssuerRefDerPem
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeletePkiIssuerRefDerPem(ctx context.Context, issuerRef string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/{issuer_ref}/der|/pem"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeletePkiJson
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeletePkiJson(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}//json"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeletePkiKeyKeyRef
// keyRef: Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeletePkiKeyKeyRef(ctx context.Context, keyRef string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/key/{key_ref}"
	requestPath = strings.Replace(requestPath, "{"+"key_ref"+"}", url.PathEscape(keyRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeletePkiRoot
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeletePkiRoot(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/root"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteSecretDataPath Write, Patch, Read, and Delete data in the Key-Value Store.
// path: Location of the secret.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteSecretDataPath(ctx context.Context, mountPath string, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/data/{path}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteSecretMetadataPath Configures settings for the KV store
// path: Location of the secret.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteSecretMetadataPath(ctx context.Context, mountPath string, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/metadata/{path}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteSshConfigZeroaddress Assign zero address as default CIDR block for select roles.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteSshConfigZeroaddress(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/zeroaddress"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteSshKeysKeyName Register a shared private key with Vault.
// keyName: [Required] Name of the key
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteSshKeysKeyName(ctx context.Context, keyName string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/{key_name}"
	requestPath = strings.Replace(requestPath, "{"+"key_name"+"}", url.PathEscape(keyName), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteSshRolesRole Manage the 'roles' that can be created with this backend.
// role: [Required for all types] Name of the role being created.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteSshRolesRole(ctx context.Context, mountPath string, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roles/{role}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// DeleteTotpKeysName Manage the keys that can be created with this backend.
// name: Name of the key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) DeleteTotpKeysName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodDelete,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ListAwsRoles List the existing roles in this backend
// list: Must be set to &#x60;true&#x60;
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ListAwsRoles(ctx context.Context, mountPath string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roles"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ListGcpRolesets
// list: Must be set to &#x60;true&#x60;
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ListGcpRolesets(ctx context.Context, mountPath string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/rolesets"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ListGcpStaticAccounts
// list: Must be set to &#x60;true&#x60;
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ListGcpStaticAccounts(ctx context.Context, mountPath string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-accounts"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ListLdapLibrary
// list: Must be set to &#x60;true&#x60;
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ListLdapLibrary(ctx context.Context, mountPath string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/library"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ListLdapRole
// list: Must be set to &#x60;true&#x60;
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ListLdapRole(ctx context.Context, mountPath string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/role"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ListLdapStaticRole
// list: Must be set to &#x60;true&#x60;
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ListLdapStaticRole(ctx context.Context, mountPath string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-role"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ListPkiCerts
// list: Must be set to &#x60;true&#x60;
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ListPkiCerts(ctx context.Context, mountPath string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/certs"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ListPkiIssuers
// list: Must be set to &#x60;true&#x60;
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ListPkiIssuers(ctx context.Context, mountPath string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/issuers"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ListTotpKeys Manage the keys that can be created with this backend.
// list: Must be set to &#x60;true&#x60;
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ListTotpKeys(ctx context.Context, mountPath string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadAwsConfigLease Configure the default lease information for generated credentials.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadAwsConfigLease(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/lease"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadAwsConfigRoot Configure the root credentials that are used to manage IAM.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadAwsConfigRoot(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/root"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadAwsCreds Generate AWS credentials from a specific Vault role.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadAwsCreds(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/creds"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadAwsRolesName Read, write and reference IAM policies that access keys can be made for.
// name: Name of the policy
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadAwsRolesName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadAwsStsName Generate AWS credentials from a specific Vault role.
// name: Name of the role
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadAwsStsName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/sts/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadAzureCredsRole
// role: Name of the Vault role
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadAzureCredsRole(ctx context.Context, mountPath string, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/creds/{role}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadCubbyholePath Retrieve the secret at the specified location.
// path: Specifies the path of the secret.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
// list: Return a list if &#x60;true&#x60;
func (a *Secrets) ReadCubbyholePath(ctx context.Context, mountPath string, path string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/{path}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadGcpConfig
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadGcpConfig(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadGcpKeyRoleset
// roleset: Required. Name of the role set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadGcpKeyRoleset(ctx context.Context, mountPath string, roleset string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/key/{roleset}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadGcpRolesetName
// name: Required. Name of the role.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadGcpRolesetName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roleset/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadGcpRolesetRolesetKey
// roleset: Required. Name of the role set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadGcpRolesetRolesetKey(ctx context.Context, mountPath string, roleset string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roleset/{roleset}/key"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadGcpRolesetRolesetToken
// roleset: Required. Name of the role set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadGcpRolesetRolesetToken(ctx context.Context, mountPath string, roleset string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roleset/{roleset}/token"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadGcpStaticAccountName
// name: Required. Name to refer to this static account in Vault. Cannot be updated.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadGcpStaticAccountName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-account/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadGcpStaticAccountNameKey
// name: Required. Name of the static account.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadGcpStaticAccountNameKey(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-account/{name}/key"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadGcpStaticAccountNameToken
// name: Required. Name of the static account.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadGcpStaticAccountNameToken(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-account/{name}/token"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadGcpTokenRoleset
// roleset: Required. Name of the role set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadGcpTokenRoleset(ctx context.Context, mountPath string, roleset string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/token/{roleset}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadGcpkmsKeysConfigKey Configure the key in Vault
// key: Name of the key in Vault.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadGcpkmsKeysConfigKey(ctx context.Context, key string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/config/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadGcpkmsKeysKey Interact with crypto keys in Vault and Google Cloud KMS
// key: Name of the key in Vault.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadGcpkmsKeysKey(ctx context.Context, key string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadGcpkmsPubkeyKey Retrieve the public key associated with the named key
// key: Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadGcpkmsPubkeyKey(ctx context.Context, key string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/pubkey/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadLdapCredsName
// name: Name of the dynamic role.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadLdapCredsName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/creds/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadLdapLibraryName Read a library set.
// name: Name of the set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadLdapLibraryName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/library/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadLdapLibraryNameStatus Check the status of the service accounts in a library set.
// name: Name of the set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadLdapLibraryNameStatus(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/library/{name}/status"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadLdapRoleName
// name: Name of the role (lowercase)
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadLdapRoleName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadLdapStaticCredName
// name: Name of the static role.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadLdapStaticCredName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-cred/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadLdapStaticRoleName
// name: Name of the role
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadLdapStaticRoleName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadNomadConfigAccess
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadNomadConfigAccess(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/access"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiCa
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiCa(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/ca"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiCaChain
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiCaChain(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/ca_chain"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiCaPem
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiCaPem(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/ca/pem"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiCertCaChain
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiCertCaChain(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/cert/ca_chain"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiCertSerial
// serial: Certificate serial number, in colon- or hyphen-separated octal
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiCertSerial(ctx context.Context, mountPath string, serial string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/cert/{serial}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"serial"+"}", url.PathEscape(serial), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiCertSerialRaw
// serial: Certificate serial number, in colon- or hyphen-separated octal
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiCertSerialRaw(ctx context.Context, mountPath string, serial string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/cert/{serial}/raw"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"serial"+"}", url.PathEscape(serial), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiCertSerialRawPem
// serial: Certificate serial number, in colon- or hyphen-separated octal
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiCertSerialRawPem(ctx context.Context, mountPath string, serial string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/cert/{serial}/raw/pem"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"serial"+"}", url.PathEscape(serial), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiConfigAutoTidy
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiConfigAutoTidy(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/auto-tidy"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiConfigCrl
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiConfigCrl(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/crl"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiConfigIssuers
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiConfigIssuers(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/issuers"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiConfigKeys
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiConfigKeys(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/keys"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiConfigUrls
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiConfigUrls(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/urls"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiCrl
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiCrl(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/crl"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiCrlRotate
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiCrlRotate(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/crl/rotate"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiCrlRotateDelta
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiCrlRotateDelta(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/crl/rotate-delta"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiDelta
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiDelta(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}//delta"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiDeltaCrl
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiDeltaCrl(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/delta-crl"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiDeltaPem
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiDeltaPem(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}//delta/pem"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiDer
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiDer(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}//der"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiIssuerRefCrlPemDerDeltaPem
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiIssuerRefCrlPemDerDeltaPem(ctx context.Context, issuerRef string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/{issuer_ref}/crl/pem|/der|/delta/pem"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiIssuerRefDerPem
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiIssuerRefDerPem(ctx context.Context, issuerRef string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/{issuer_ref}/der|/pem"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiJson
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiJson(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}//json"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiKeyKeyRef
// keyRef: Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiKeyKeyRef(ctx context.Context, keyRef string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/key/{key_ref}"
	requestPath = strings.Replace(requestPath, "{"+"key_ref"+"}", url.PathEscape(keyRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiOcspReq
// req: base-64 encoded ocsp request
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiOcspReq(ctx context.Context, mountPath string, req string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/ocsp/{req}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"req"+"}", url.PathEscape(req), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiPem
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiPem(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}//pem"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadPkiTidyStatus
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadPkiTidyStatus(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/tidy-status"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadSecretDataPath Write, Patch, Read, and Delete data in the Key-Value Store.
// path: Location of the secret.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadSecretDataPath(ctx context.Context, mountPath string, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/data/{path}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadSecretMetadataPath Configures settings for the KV store
// path: Location of the secret.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
// list: Return a list if &#x60;true&#x60;
func (a *Secrets) ReadSecretMetadataPath(ctx context.Context, mountPath string, path string, list string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/metadata/{path}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadSecretSubkeysPath Read the structure of a secret entry from the Key-Value store with the values removed.
// path: Location of the secret.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadSecretSubkeysPath(ctx context.Context, mountPath string, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/subkeys/{path}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadSshConfigZeroaddress Assign zero address as default CIDR block for select roles.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadSshConfigZeroaddress(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/zeroaddress"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadSshPublicKey Retrieve the public key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadSshPublicKey(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/public_key"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadSshRolesRole Manage the 'roles' that can be created with this backend.
// role: [Required for all types] Name of the role being created.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadSshRolesRole(ctx context.Context, mountPath string, role string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roles/{role}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadTotpCodeName Request time-based one-time use password or validate a password for a certain key .
// name: Name of the key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadTotpCodeName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/code/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadTotpKeysName Manage the keys that can be created with this backend.
// name: Name of the key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadTotpKeysName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadTransitBackupName Backup the named key
// name: Name of the key
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadTransitBackupName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/backup/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadTransitCacheConfig Returns the size of the active cache
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadTransitCacheConfig(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/cache-config"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadTransitExportTypeName Export named encryption or signing key
// name: Name of the key
// type_: Type of key to export (encryption-key, signing-key, hmac-key)
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadTransitExportTypeName(ctx context.Context, mountPath string, name string, type_ string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/export/{type}/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)
	requestPath = strings.Replace(requestPath, "{"+"type"+"}", url.PathEscape(type_), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadTransitExportTypeNameVersion Export named encryption or signing key
// name: Name of the key
// type_: Type of key to export (encryption-key, signing-key, hmac-key)
// version: Version of the key
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadTransitExportTypeNameVersion(ctx context.Context, mountPath string, name string, type_ string, version string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/export/{type}/{name}/{version}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)
	requestPath = strings.Replace(requestPath, "{"+"type"+"}", url.PathEscape(type_), -1)
	requestPath = strings.Replace(requestPath, "{"+"version"+"}", url.PathEscape(version), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// ReadTransitWrappingKey Returns the public key to use for wrapping imported keys
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) ReadTransitWrappingKey(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/wrapping_key"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodGet,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateAwsConfigLease Configure the default lease information for generated credentials.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateAwsConfigLease(ctx context.Context, mountPath string, awsConfigLeaseRequest AwsConfigLeaseRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/lease"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		awsConfigLeaseRequest,
		nil, // request query parameters
	)
}

// UpdateAwsConfigRoot Configure the root credentials that are used to manage IAM.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateAwsConfigRoot(ctx context.Context, mountPath string, awsConfigRootRequest AwsConfigRootRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/root"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		awsConfigRootRequest,
		nil, // request query parameters
	)
}

// UpdateAwsCreds Generate AWS credentials from a specific Vault role.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateAwsCreds(ctx context.Context, mountPath string, awsCredsRequest AwsCredsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/creds"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		awsCredsRequest,
		nil, // request query parameters
	)
}

// UpdateAwsRolesName Read, write and reference IAM policies that access keys can be made for.
// name: Name of the policy
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateAwsRolesName(ctx context.Context, mountPath string, name string, awsRolesRequest AwsRolesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roles/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		awsRolesRequest,
		nil, // request query parameters
	)
}

// UpdateAwsStsName Generate AWS credentials from a specific Vault role.
// name: Name of the role
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateAwsStsName(ctx context.Context, mountPath string, name string, awsStsRequest AwsStsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/sts/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		awsStsRequest,
		nil, // request query parameters
	)
}

// UpdateCubbyholePath Store a secret at the specified location.
// path: Specifies the path of the secret.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateCubbyholePath(ctx context.Context, mountPath string, path string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/{path}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateGcpConfig
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpConfig(ctx context.Context, mountPath string, gcpConfigRequest GcpConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpConfigRequest,
		nil, // request query parameters
	)
}

// UpdateGcpConfigRotateRoot
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpConfigRotateRoot(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/rotate-root"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateGcpKeyRoleset
// roleset: Required. Name of the role set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpKeyRoleset(ctx context.Context, mountPath string, roleset string, gcpKeyRequest GcpKeyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/key/{roleset}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpKeyRequest,
		nil, // request query parameters
	)
}

// UpdateGcpRolesetName
// name: Required. Name of the role.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpRolesetName(ctx context.Context, mountPath string, name string, gcpRolesetRequest GcpRolesetRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roleset/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpRolesetRequest,
		nil, // request query parameters
	)
}

// UpdateGcpRolesetNameRotate
// name: Name of the role.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpRolesetNameRotate(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roleset/{name}/rotate"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateGcpRolesetNameRotateKey
// name: Name of the role.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpRolesetNameRotateKey(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roleset/{name}/rotate-key"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateGcpRolesetRolesetKey
// roleset: Required. Name of the role set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpRolesetRolesetKey(ctx context.Context, mountPath string, roleset string, gcpRolesetKeyRequest GcpRolesetKeyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roleset/{roleset}/key"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpRolesetKeyRequest,
		nil, // request query parameters
	)
}

// UpdateGcpRolesetRolesetToken
// roleset: Required. Name of the role set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpRolesetRolesetToken(ctx context.Context, mountPath string, roleset string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roleset/{roleset}/token"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateGcpStaticAccountName
// name: Required. Name to refer to this static account in Vault. Cannot be updated.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpStaticAccountName(ctx context.Context, mountPath string, name string, gcpStaticAccountRequest GcpStaticAccountRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-account/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpStaticAccountRequest,
		nil, // request query parameters
	)
}

// UpdateGcpStaticAccountNameKey
// name: Required. Name of the static account.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpStaticAccountNameKey(ctx context.Context, mountPath string, name string, gcpStaticAccountKeyRequest GcpStaticAccountKeyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-account/{name}/key"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpStaticAccountKeyRequest,
		nil, // request query parameters
	)
}

// UpdateGcpStaticAccountNameRotateKey
// name: Name of the account.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpStaticAccountNameRotateKey(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-account/{name}/rotate-key"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateGcpStaticAccountNameToken
// name: Required. Name of the static account.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpStaticAccountNameToken(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-account/{name}/token"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateGcpTokenRoleset
// roleset: Required. Name of the role set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpTokenRoleset(ctx context.Context, mountPath string, roleset string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/token/{roleset}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"roleset"+"}", url.PathEscape(roleset), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateGcpkmsDecryptKey Decrypt a ciphertext value using a named key
// key: Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpkmsDecryptKey(ctx context.Context, key string, mountPath string, gcpkmsDecryptRequest GcpkmsDecryptRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/decrypt/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpkmsDecryptRequest,
		nil, // request query parameters
	)
}

// UpdateGcpkmsEncryptKey Encrypt a plaintext value using a named key
// key: Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpkmsEncryptKey(ctx context.Context, key string, mountPath string, gcpkmsEncryptRequest GcpkmsEncryptRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/encrypt/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpkmsEncryptRequest,
		nil, // request query parameters
	)
}

// UpdateGcpkmsKeysConfigKey Configure the key in Vault
// key: Name of the key in Vault.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpkmsKeysConfigKey(ctx context.Context, key string, mountPath string, gcpkmsKeysConfigRequest GcpkmsKeysConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/config/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpkmsKeysConfigRequest,
		nil, // request query parameters
	)
}

// UpdateGcpkmsKeysDeregisterKey Deregister an existing key in Vault
// key: Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpkmsKeysDeregisterKey(ctx context.Context, key string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/deregister/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateGcpkmsKeysKey Interact with crypto keys in Vault and Google Cloud KMS
// key: Name of the key in Vault.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpkmsKeysKey(ctx context.Context, key string, mountPath string, gcpkmsKeysRequest GcpkmsKeysRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpkmsKeysRequest,
		nil, // request query parameters
	)
}

// UpdateGcpkmsKeysRegisterKey Register an existing crypto key in Google Cloud KMS
// key: Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpkmsKeysRegisterKey(ctx context.Context, key string, mountPath string, gcpkmsKeysRegisterRequest GcpkmsKeysRegisterRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/register/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpkmsKeysRegisterRequest,
		nil, // request query parameters
	)
}

// UpdateGcpkmsKeysRotateKey Rotate a crypto key to a new primary version
// key: Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpkmsKeysRotateKey(ctx context.Context, key string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/rotate/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateGcpkmsKeysTrimKey Delete old crypto key versions from Google Cloud KMS
// key: Name of the key in Vault.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpkmsKeysTrimKey(ctx context.Context, key string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/trim/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateGcpkmsReencryptKey Re-encrypt existing ciphertext data to a new version
// key: Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpkmsReencryptKey(ctx context.Context, key string, mountPath string, gcpkmsReencryptRequest GcpkmsReencryptRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/reencrypt/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpkmsReencryptRequest,
		nil, // request query parameters
	)
}

// UpdateGcpkmsSignKey Signs a message or digest using a named key
// key: Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpkmsSignKey(ctx context.Context, key string, mountPath string, gcpkmsSignRequest GcpkmsSignRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/sign/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpkmsSignRequest,
		nil, // request query parameters
	)
}

// UpdateGcpkmsVerifyKey Verify a signature using a named key
// key: Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateGcpkmsVerifyKey(ctx context.Context, key string, mountPath string, gcpkmsVerifyRequest GcpkmsVerifyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/verify/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		gcpkmsVerifyRequest,
		nil, // request query parameters
	)
}

// UpdateLdapLibraryManageNameCheckIn Check service accounts in to the library.
// name: Name of the set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateLdapLibraryManageNameCheckIn(ctx context.Context, mountPath string, name string, ldapLibraryManageCheckInRequest LdapLibraryManageCheckInRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/library/manage/{name}/check-in"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		ldapLibraryManageCheckInRequest,
		nil, // request query parameters
	)
}

// UpdateLdapLibraryName Update a library set.
// name: Name of the set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateLdapLibraryName(ctx context.Context, mountPath string, name string, ldapLibraryRequest LdapLibraryRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/library/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		ldapLibraryRequest,
		nil, // request query parameters
	)
}

// UpdateLdapLibraryNameCheckIn Check service accounts in to the library.
// name: Name of the set.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateLdapLibraryNameCheckIn(ctx context.Context, mountPath string, name string, ldapLibraryCheckInRequest LdapLibraryCheckInRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/library/{name}/check-in"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		ldapLibraryCheckInRequest,
		nil, // request query parameters
	)
}

// UpdateLdapLibraryNameCheckOut Check a service account out from the library.
// name: Name of the set
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateLdapLibraryNameCheckOut(ctx context.Context, mountPath string, name string, ldapLibraryCheckOutRequest LdapLibraryCheckOutRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/library/{name}/check-out"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		ldapLibraryCheckOutRequest,
		nil, // request query parameters
	)
}

// UpdateLdapRoleName
// name: Name of the role (lowercase)
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateLdapRoleName(ctx context.Context, mountPath string, name string, ldapRoleRequest LdapRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		ldapRoleRequest,
		nil, // request query parameters
	)
}

// UpdateLdapRotateRoleName
// name: Name of the static role
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateLdapRotateRoleName(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/rotate-role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateLdapRotateRoot
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateLdapRotateRoot(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/rotate-root"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateLdapStaticRoleName
// name: Name of the role
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateLdapStaticRoleName(ctx context.Context, mountPath string, name string, ldapStaticRoleRequest LdapStaticRoleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/static-role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		ldapStaticRoleRequest,
		nil, // request query parameters
	)
}

// UpdateNomadConfigAccess
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateNomadConfigAccess(ctx context.Context, mountPath string, nomadConfigAccessRequest NomadConfigAccessRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/access"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nomadConfigAccessRequest,
		nil, // request query parameters
	)
}

// UpdatePkiBundle
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiBundle(ctx context.Context, mountPath string, pkiBundleRequest PkiBundleRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/bundle"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiBundleRequest,
		nil, // request query parameters
	)
}

// UpdatePkiCert
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiCert(ctx context.Context, mountPath string, pkiCertRequest PkiCertRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/cert"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiCertRequest,
		nil, // request query parameters
	)
}

// UpdatePkiConfigAutoTidy
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiConfigAutoTidy(ctx context.Context, mountPath string, pkiConfigAutoTidyRequest PkiConfigAutoTidyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/auto-tidy"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiConfigAutoTidyRequest,
		nil, // request query parameters
	)
}

// UpdatePkiConfigCa
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiConfigCa(ctx context.Context, mountPath string, pkiConfigCaRequest PkiConfigCaRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/ca"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiConfigCaRequest,
		nil, // request query parameters
	)
}

// UpdatePkiConfigCrl
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiConfigCrl(ctx context.Context, mountPath string, pkiConfigCrlRequest PkiConfigCrlRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/crl"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiConfigCrlRequest,
		nil, // request query parameters
	)
}

// UpdatePkiConfigIssuers
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiConfigIssuers(ctx context.Context, mountPath string, pkiConfigIssuersRequest PkiConfigIssuersRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/issuers"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiConfigIssuersRequest,
		nil, // request query parameters
	)
}

// UpdatePkiConfigKeys
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiConfigKeys(ctx context.Context, mountPath string, pkiConfigKeysRequest PkiConfigKeysRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/keys"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiConfigKeysRequest,
		nil, // request query parameters
	)
}

// UpdatePkiConfigUrls
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiConfigUrls(ctx context.Context, mountPath string, pkiConfigUrlsRequest PkiConfigUrlsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/urls"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiConfigUrlsRequest,
		nil, // request query parameters
	)
}

// UpdatePkiIntermediateCrossSign
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiIntermediateCrossSign(ctx context.Context, mountPath string, pkiIntermediateCrossSignRequest PkiIntermediateCrossSignRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/intermediate/cross-sign"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiIntermediateCrossSignRequest,
		nil, // request query parameters
	)
}

// UpdatePkiIntermediateGenerateExported
// exported: Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiIntermediateGenerateExported(ctx context.Context, exported string, mountPath string, pkiIntermediateGenerateRequest PkiIntermediateGenerateRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/intermediate/generate/{exported}"
	requestPath = strings.Replace(requestPath, "{"+"exported"+"}", url.PathEscape(exported), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiIntermediateGenerateRequest,
		nil, // request query parameters
	)
}

// UpdatePkiIntermediateSetSigned
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiIntermediateSetSigned(ctx context.Context, mountPath string, pkiIntermediateSetSignedRequest PkiIntermediateSetSignedRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/intermediate/set-signed"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiIntermediateSetSignedRequest,
		nil, // request query parameters
	)
}

// UpdatePkiIssueRole
// role: The desired role with configuration for this request
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiIssueRole(ctx context.Context, mountPath string, role string, pkiIssueRequest PkiIssueRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/issue/{role}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiIssueRequest,
		nil, // request query parameters
	)
}

// UpdatePkiIssuerIssuerRefIssueRole
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
// role: The desired role with configuration for this request
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiIssuerIssuerRefIssueRole(ctx context.Context, issuerRef string, mountPath string, role string, pkiIssuerIssueRequest PkiIssuerIssueRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/issuer/{issuer_ref}/issue/{role}"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiIssuerIssueRequest,
		nil, // request query parameters
	)
}

// UpdatePkiIssuerIssuerRefRevoke
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiIssuerIssuerRefRevoke(ctx context.Context, issuerRef string, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/issuer/{issuer_ref}/revoke"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdatePkiIssuerIssuerRefSignIntermediate
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiIssuerIssuerRefSignIntermediate(ctx context.Context, issuerRef string, mountPath string, pkiIssuerSignIntermediateRequest PkiIssuerSignIntermediateRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/issuer/{issuer_ref}/sign-intermediate"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiIssuerSignIntermediateRequest,
		nil, // request query parameters
	)
}

// UpdatePkiIssuerIssuerRefSignRole
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
// role: The desired role with configuration for this request
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiIssuerIssuerRefSignRole(ctx context.Context, issuerRef string, mountPath string, role string, pkiIssuerSignRequest PkiIssuerSignRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/issuer/{issuer_ref}/sign/{role}"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiIssuerSignRequest,
		nil, // request query parameters
	)
}

// UpdatePkiIssuerIssuerRefSignSelfIssued
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiIssuerIssuerRefSignSelfIssued(ctx context.Context, issuerRef string, mountPath string, pkiIssuerSignSelfIssuedRequest PkiIssuerSignSelfIssuedRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/issuer/{issuer_ref}/sign-self-issued"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiIssuerSignSelfIssuedRequest,
		nil, // request query parameters
	)
}

// UpdatePkiIssuerIssuerRefSignVerbatim
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiIssuerIssuerRefSignVerbatim(ctx context.Context, issuerRef string, mountPath string, pkiIssuerSignVerbatimRequest PkiIssuerSignVerbatimRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/issuer/{issuer_ref}/sign-verbatim"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiIssuerSignVerbatimRequest,
		nil, // request query parameters
	)
}

// UpdatePkiIssuerIssuerRefSignVerbatimRole
// issuerRef: Reference to a existing issuer; either \&quot;default\&quot; for the configured default issuer, an identifier or the name assigned to the issuer.
// role: The desired role with configuration for this request
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiIssuerIssuerRefSignVerbatimRole(ctx context.Context, issuerRef string, mountPath string, role string, pkiIssuerSignVerbatimRequest PkiIssuerSignVerbatimRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/issuer/{issuer_ref}/sign-verbatim/{role}"
	requestPath = strings.Replace(requestPath, "{"+"issuer_ref"+"}", url.PathEscape(issuerRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiIssuerSignVerbatimRequest,
		nil, // request query parameters
	)
}

// UpdatePkiIssuersGenerateIntermediateExported
// exported: Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiIssuersGenerateIntermediateExported(ctx context.Context, exported string, mountPath string, pkiIssuersGenerateIntermediateRequest PkiIssuersGenerateIntermediateRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/issuers/generate/intermediate/{exported}"
	requestPath = strings.Replace(requestPath, "{"+"exported"+"}", url.PathEscape(exported), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiIssuersGenerateIntermediateRequest,
		nil, // request query parameters
	)
}

// UpdatePkiIssuersGenerateRootExported
// exported: Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiIssuersGenerateRootExported(ctx context.Context, exported string, mountPath string, pkiIssuersGenerateRootRequest PkiIssuersGenerateRootRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/issuers/generate/root/{exported}"
	requestPath = strings.Replace(requestPath, "{"+"exported"+"}", url.PathEscape(exported), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiIssuersGenerateRootRequest,
		nil, // request query parameters
	)
}

// UpdatePkiJson
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiJson(ctx context.Context, mountPath string, pkiJsonRequest PkiJsonRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}//json"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiJsonRequest,
		nil, // request query parameters
	)
}

// UpdatePkiKeyKeyRef
// keyRef: Reference to key; either \&quot;default\&quot; for the configured default key, an identifier of a key, or the name assigned to the key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiKeyKeyRef(ctx context.Context, keyRef string, mountPath string, pkiKeyRequest PkiKeyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/key/{key_ref}"
	requestPath = strings.Replace(requestPath, "{"+"key_ref"+"}", url.PathEscape(keyRef), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiKeyRequest,
		nil, // request query parameters
	)
}

// UpdatePkiKeysImport
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiKeysImport(ctx context.Context, mountPath string, pkiKeysImportRequest PkiKeysImportRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/import"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiKeysImportRequest,
		nil, // request query parameters
	)
}

// UpdatePkiKms
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiKms(ctx context.Context, mountPath string, pkiKmsRequest PkiKmsRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/kms"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiKmsRequest,
		nil, // request query parameters
	)
}

// UpdatePkiOcsp
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiOcsp(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/ocsp"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdatePkiRevoke
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiRevoke(ctx context.Context, mountPath string, pkiRevokeRequest PkiRevokeRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/revoke"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiRevokeRequest,
		nil, // request query parameters
	)
}

// UpdatePkiRevokeWithKey
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiRevokeWithKey(ctx context.Context, mountPath string, pkiRevokeWithKeyRequest PkiRevokeWithKeyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/revoke-with-key"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiRevokeWithKeyRequest,
		nil, // request query parameters
	)
}

// UpdatePkiRootGenerateExported
// exported: Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiRootGenerateExported(ctx context.Context, exported string, mountPath string, pkiRootGenerateRequest PkiRootGenerateRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/root/generate/{exported}"
	requestPath = strings.Replace(requestPath, "{"+"exported"+"}", url.PathEscape(exported), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiRootGenerateRequest,
		nil, // request query parameters
	)
}

// UpdatePkiRootReplace
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiRootReplace(ctx context.Context, mountPath string, pkiRootReplaceRequest PkiRootReplaceRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/root/replace"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiRootReplaceRequest,
		nil, // request query parameters
	)
}

// UpdatePkiRootRotateExported
// exported: Must be \&quot;internal\&quot;, \&quot;exported\&quot; or \&quot;kms\&quot;. If set to \&quot;exported\&quot;, the generated private key will be returned. This is your *only* chance to retrieve the private key!
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiRootRotateExported(ctx context.Context, exported string, mountPath string, pkiRootRotateRequest PkiRootRotateRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/root/rotate/{exported}"
	requestPath = strings.Replace(requestPath, "{"+"exported"+"}", url.PathEscape(exported), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiRootRotateRequest,
		nil, // request query parameters
	)
}

// UpdatePkiRootSignIntermediate
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiRootSignIntermediate(ctx context.Context, mountPath string, pkiRootSignIntermediateRequest PkiRootSignIntermediateRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/root/sign-intermediate"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiRootSignIntermediateRequest,
		nil, // request query parameters
	)
}

// UpdatePkiRootSignSelfIssued
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiRootSignSelfIssued(ctx context.Context, mountPath string, pkiRootSignSelfIssuedRequest PkiRootSignSelfIssuedRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/root/sign-self-issued"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiRootSignSelfIssuedRequest,
		nil, // request query parameters
	)
}

// UpdatePkiSignRole
// role: The desired role with configuration for this request
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiSignRole(ctx context.Context, mountPath string, role string, pkiSignRequest PkiSignRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/sign/{role}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiSignRequest,
		nil, // request query parameters
	)
}

// UpdatePkiSignVerbatim
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiSignVerbatim(ctx context.Context, mountPath string, pkiSignVerbatimRequest PkiSignVerbatimRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/sign-verbatim"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiSignVerbatimRequest,
		nil, // request query parameters
	)
}

// UpdatePkiSignVerbatimRole
// role: The desired role with configuration for this request
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiSignVerbatimRole(ctx context.Context, mountPath string, role string, pkiSignVerbatimRequest PkiSignVerbatimRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/sign-verbatim/{role}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiSignVerbatimRequest,
		nil, // request query parameters
	)
}

// UpdatePkiTidy
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiTidy(ctx context.Context, mountPath string, pkiTidyRequest PkiTidyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/tidy"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		pkiTidyRequest,
		nil, // request query parameters
	)
}

// UpdatePkiTidyCancel
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdatePkiTidyCancel(ctx context.Context, mountPath string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/tidy-cancel"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateRabbitmqConfigConnection Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateRabbitmqConfigConnection(ctx context.Context, mountPath string, rabbitmqConfigConnectionRequest RabbitmqConfigConnectionRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/connection"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		rabbitmqConfigConnectionRequest,
		nil, // request query parameters
	)
}

// UpdateSecretDataPath Write, Patch, Read, and Delete data in the Key-Value Store.
// path: Location of the secret.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateSecretDataPath(ctx context.Context, mountPath string, path string, kvDataRequest KvDataRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/data/{path}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		kvDataRequest,
		nil, // request query parameters
	)
}

// UpdateSecretDeletePath Marks one or more versions as deleted in the KV store.
// path: Location of the secret.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateSecretDeletePath(ctx context.Context, mountPath string, path string, kvDeleteRequest KvDeleteRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/delete/{path}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		kvDeleteRequest,
		nil, // request query parameters
	)
}

// UpdateSecretDestroyPath Permanently removes one or more versions in the KV store
// path: Location of the secret.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateSecretDestroyPath(ctx context.Context, mountPath string, path string, kvDestroyRequest KvDestroyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/destroy/{path}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		kvDestroyRequest,
		nil, // request query parameters
	)
}

// UpdateSecretMetadataPath Configures settings for the KV store
// path: Location of the secret.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateSecretMetadataPath(ctx context.Context, mountPath string, path string, kvMetadataRequest KvMetadataRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/metadata/{path}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		kvMetadataRequest,
		nil, // request query parameters
	)
}

// UpdateSecretUndeletePath Undeletes one or more versions from the KV store.
// path: Location of the secret.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateSecretUndeletePath(ctx context.Context, mountPath string, path string, kvUndeleteRequest KvUndeleteRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/undelete/{path}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"path"+"}", url.PathEscape(path), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		kvUndeleteRequest,
		nil, // request query parameters
	)
}

// UpdateSshConfigZeroaddress Assign zero address as default CIDR block for select roles.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateSshConfigZeroaddress(ctx context.Context, mountPath string, sshConfigZeroaddressRequest SshConfigZeroaddressRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/config/zeroaddress"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		sshConfigZeroaddressRequest,
		nil, // request query parameters
	)
}

// UpdateSshKeysKeyName Register a shared private key with Vault.
// keyName: [Required] Name of the key
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateSshKeysKeyName(ctx context.Context, keyName string, mountPath string, sshKeysRequest SshKeysRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/{key_name}"
	requestPath = strings.Replace(requestPath, "{"+"key_name"+"}", url.PathEscape(keyName), -1)
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		sshKeysRequest,
		nil, // request query parameters
	)
}

// UpdateSshLookup List all the roles associated with the given IP address.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateSshLookup(ctx context.Context, mountPath string, sshLookupRequest SshLookupRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/lookup"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		sshLookupRequest,
		nil, // request query parameters
	)
}

// UpdateSshRolesRole Manage the 'roles' that can be created with this backend.
// role: [Required for all types] Name of the role being created.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateSshRolesRole(ctx context.Context, mountPath string, role string, sshRolesRequest SshRolesRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/roles/{role}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		sshRolesRequest,
		nil, // request query parameters
	)
}

// UpdateSshVerify Validate the OTP provided by Vault SSH Agent.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateSshVerify(ctx context.Context, mountPath string, sshVerifyRequest SshVerifyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/verify"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		sshVerifyRequest,
		nil, // request query parameters
	)
}

// UpdateTotpCodeName Request time-based one-time use password or validate a password for a certain key .
// name: Name of the key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTotpCodeName(ctx context.Context, mountPath string, name string, totpCodeRequest TotpCodeRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/code/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		totpCodeRequest,
		nil, // request query parameters
	)
}

// UpdateTotpKeysName Manage the keys that can be created with this backend.
// name: Name of the key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTotpKeysName(ctx context.Context, mountPath string, name string, totpKeysRequest TotpKeysRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		totpKeysRequest,
		nil, // request query parameters
	)
}

// UpdateTransitCacheConfig Configures a new cache of the specified size
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitCacheConfig(ctx context.Context, mountPath string, transitCacheConfigRequest TransitCacheConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/cache-config"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitCacheConfigRequest,
		nil, // request query parameters
	)
}

// UpdateTransitDatakeyPlaintextName Generate a data key
// name: The backend key used for encrypting the data key
// plaintext: \&quot;plaintext\&quot; will return the key in both plaintext and ciphertext; \&quot;wrapped\&quot; will return the ciphertext only.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitDatakeyPlaintextName(ctx context.Context, mountPath string, name string, plaintext string, transitDatakeyRequest TransitDatakeyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/datakey/{plaintext}/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)
	requestPath = strings.Replace(requestPath, "{"+"plaintext"+"}", url.PathEscape(plaintext), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitDatakeyRequest,
		nil, // request query parameters
	)
}

// UpdateTransitDecryptName Decrypt a ciphertext value using a named key
// name: Name of the key
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitDecryptName(ctx context.Context, mountPath string, name string, transitDecryptRequest TransitDecryptRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/decrypt/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitDecryptRequest,
		nil, // request query parameters
	)
}

// UpdateTransitEncryptName Encrypt a plaintext value or a batch of plaintext blocks using a named key
// name: Name of the key
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitEncryptName(ctx context.Context, mountPath string, name string, transitEncryptRequest TransitEncryptRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/encrypt/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitEncryptRequest,
		nil, // request query parameters
	)
}

// UpdateTransitHash Generate a hash sum for input data
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitHash(ctx context.Context, mountPath string, transitHashRequest TransitHashRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/hash"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitHashRequest,
		nil, // request query parameters
	)
}

// UpdateTransitHashUrlalgorithm Generate a hash sum for input data
// urlalgorithm: Algorithm to use (POST URL parameter)
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitHashUrlalgorithm(ctx context.Context, mountPath string, urlalgorithm string, transitHashRequest TransitHashRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/hash/{urlalgorithm}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"urlalgorithm"+"}", url.PathEscape(urlalgorithm), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitHashRequest,
		nil, // request query parameters
	)
}

// UpdateTransitHmacName Generate an HMAC for input data using the named key
// name: The key to use for the HMAC function
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitHmacName(ctx context.Context, mountPath string, name string, transitHmacRequest TransitHmacRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/hmac/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitHmacRequest,
		nil, // request query parameters
	)
}

// UpdateTransitHmacNameUrlalgorithm Generate an HMAC for input data using the named key
// name: The key to use for the HMAC function
// urlalgorithm: Algorithm to use (POST URL parameter)
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitHmacNameUrlalgorithm(ctx context.Context, mountPath string, name string, urlalgorithm string, transitHmacRequest TransitHmacRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/hmac/{name}/{urlalgorithm}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)
	requestPath = strings.Replace(requestPath, "{"+"urlalgorithm"+"}", url.PathEscape(urlalgorithm), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitHmacRequest,
		nil, // request query parameters
	)
}

// UpdateTransitKeysNameConfig Configure a named encryption key
// name: Name of the key
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitKeysNameConfig(ctx context.Context, mountPath string, name string, transitKeysConfigRequest TransitKeysConfigRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/{name}/config"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitKeysConfigRequest,
		nil, // request query parameters
	)
}

// UpdateTransitKeysNameImport Imports an externally-generated key into a new transit key
// name: The name of the key
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitKeysNameImport(ctx context.Context, mountPath string, name string, transitKeysImportRequest TransitKeysImportRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/{name}/import"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitKeysImportRequest,
		nil, // request query parameters
	)
}

// UpdateTransitKeysNameImportVersion Imports an externally-generated key into an existing imported key
// name: The name of the key
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitKeysNameImportVersion(ctx context.Context, mountPath string, name string, transitKeysImportVersionRequest TransitKeysImportVersionRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/{name}/import_version"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitKeysImportVersionRequest,
		nil, // request query parameters
	)
}

// UpdateTransitKeysNameRotate Rotate named encryption key
// name: Name of the key
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitKeysNameRotate(ctx context.Context, mountPath string, name string) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/{name}/rotate"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		nil, // request body
		nil, // request query parameters
	)
}

// UpdateTransitKeysNameTrim Trim key versions of a named key
// name: Name of the key
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitKeysNameTrim(ctx context.Context, mountPath string, name string, transitKeysTrimRequest TransitKeysTrimRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/keys/{name}/trim"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitKeysTrimRequest,
		nil, // request query parameters
	)
}

// UpdateTransitRandom Generate random bytes
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitRandom(ctx context.Context, mountPath string, transitRandomRequest TransitRandomRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/random"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitRandomRequest,
		nil, // request query parameters
	)
}

// UpdateTransitRandomSource Generate random bytes
// source: Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitRandomSource(ctx context.Context, mountPath string, source string, transitRandomRequest TransitRandomRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/random/{source}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"source"+"}", url.PathEscape(source), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitRandomRequest,
		nil, // request query parameters
	)
}

// UpdateTransitRandomSourceUrlbytes Generate random bytes
// source: Which system to source random data from, ether \&quot;platform\&quot;, \&quot;seal\&quot;, or \&quot;all\&quot;.
// urlbytes: The number of bytes to generate (POST URL parameter)
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitRandomSourceUrlbytes(ctx context.Context, mountPath string, source string, urlbytes string, transitRandomRequest TransitRandomRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/random/{source}/{urlbytes}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"source"+"}", url.PathEscape(source), -1)
	requestPath = strings.Replace(requestPath, "{"+"urlbytes"+"}", url.PathEscape(urlbytes), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitRandomRequest,
		nil, // request query parameters
	)
}

// UpdateTransitRandomUrlbytes Generate random bytes
// urlbytes: The number of bytes to generate (POST URL parameter)
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitRandomUrlbytes(ctx context.Context, mountPath string, urlbytes string, transitRandomRequest TransitRandomRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/random/{urlbytes}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"urlbytes"+"}", url.PathEscape(urlbytes), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitRandomRequest,
		nil, // request query parameters
	)
}

// UpdateTransitRestore Restore the named key
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitRestore(ctx context.Context, mountPath string, transitRestoreRequest TransitRestoreRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/restore"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitRestoreRequest,
		nil, // request query parameters
	)
}

// UpdateTransitRestoreName Restore the named key
// name: If set, this will be the name of the restored key.
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitRestoreName(ctx context.Context, mountPath string, name string, transitRestoreRequest TransitRestoreRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/restore/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitRestoreRequest,
		nil, // request query parameters
	)
}

// UpdateTransitRewrapName Rewrap ciphertext
// name: Name of the key
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitRewrapName(ctx context.Context, mountPath string, name string, transitRewrapRequest TransitRewrapRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/rewrap/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitRewrapRequest,
		nil, // request query parameters
	)
}

// UpdateTransitSignName Generate a signature for input data using the named key
// name: The key to use
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitSignName(ctx context.Context, mountPath string, name string, transitSignRequest TransitSignRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/sign/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitSignRequest,
		nil, // request query parameters
	)
}

// UpdateTransitSignNameUrlalgorithm Generate a signature for input data using the named key
// name: The key to use
// urlalgorithm: Hash algorithm to use (POST URL parameter)
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitSignNameUrlalgorithm(ctx context.Context, mountPath string, name string, urlalgorithm string, transitSignRequest TransitSignRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/sign/{name}/{urlalgorithm}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)
	requestPath = strings.Replace(requestPath, "{"+"urlalgorithm"+"}", url.PathEscape(urlalgorithm), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitSignRequest,
		nil, // request query parameters
	)
}

// UpdateTransitVerifyName Verify a signature or HMAC for input data created using the named key
// name: The key to use
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitVerifyName(ctx context.Context, mountPath string, name string, transitVerifyRequest TransitVerifyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/verify/{name}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitVerifyRequest,
		nil, // request query parameters
	)
}

// UpdateTransitVerifyNameUrlalgorithm Verify a signature or HMAC for input data created using the named key
// name: The key to use
// urlalgorithm: Hash algorithm to use (POST URL parameter)
// mountPath: Path where the backend was mounted; the endpoint path will be offset by the mount path
func (a *Secrets) UpdateTransitVerifyNameUrlalgorithm(ctx context.Context, mountPath string, name string, urlalgorithm string, transitVerifyRequest TransitVerifyRequest) (*Response[map[string]interface{}], error) {
	requestPath := "/v1/{mount_path}/verify/{name}/{urlalgorithm}"
	requestPath = strings.Replace(requestPath, "{"+"mount_path"+"}", url.PathEscape(mountPath), -1)
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)
	requestPath = strings.Replace(requestPath, "{"+"urlalgorithm"+"}", url.PathEscape(urlalgorithm), -1)

	return sendStructuredRequestParseResponse[map[string]interface{}](
		ctx,
		a.client,
		http.MethodPost,
		requestPath,
		transitVerifyRequest,
		nil, // request query parameters
	)
}
