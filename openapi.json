{
  "openapi": "3.0.2",
  "info": {
    "title": "HashiCorp Vault API",
    "description": "HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.",
    "version": "1.13.0",
    "license": {
      "name": "Mozilla Public License 2.0",
      "url": "https://www.mozilla.org/en-US/MPL/2.0"
    }
  },
  "paths": {
    "/auth/{alicloud_mount_path}/login": {
      "description": "Authenticates an RAM entity with Vault.",
      "parameters": [
        {
          "name": "alicloud_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "alicloud"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Authenticates an RAM entity with Vault.",
        "operationId": "AliCloudLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AliCloudLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{alicloud_mount_path}/role": {
      "description": "Lists all the roles that are registered with Vault.",
      "parameters": [
        {
          "name": "alicloud_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "alicloud"
          }
        }
      ],
      "get": {
        "summary": "Lists all the roles that are registered with Vault.",
        "operationId": "AliCloudListAuthRoles",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{alicloud_mount_path}/role/{role}": {
      "description": "Create a role and associate policies to it.",
      "parameters": [
        {
          "name": "alicloud_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "alicloud"
          }
        },
        {
          "name": "role",
          "description": "The name of the role as it should appear in Vault.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Create a role and associate policies to it.",
        "operationId": "AliCloudReadAuthRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Create a role and associate policies to it.",
        "operationId": "AliCloudWriteAuthRole",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AliCloudWriteAuthRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Create a role and associate policies to it.",
        "operationId": "AliCloudDeleteAuthRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{alicloud_mount_path}/roles": {
      "description": "Lists all the roles that are registered with Vault.",
      "parameters": [
        {
          "name": "alicloud_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "alicloud"
          }
        }
      ],
      "get": {
        "summary": "Lists all the roles that are registered with Vault.",
        "operationId": "AliCloudListAuthRoles2",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/login": {
      "description": "Issue a token based on the credentials supplied",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "operationId": "AppRoleLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role": {
      "description": "Lists all the roles registered with the backend.",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        }
      ],
      "get": {
        "operationId": "AppRoleListRoles",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleListRolesResponse"
                }
              }
            }
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}": {
      "description": "Register an role with the backend.",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "AppRoleReadRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadRoleResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWriteRole",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeleteRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/bind-secret-id": {
      "description": "Impose secret_id to be presented during login using this role.",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleReadBindSecretID",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadBindSecretIDResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWriteBindSecretID",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteBindSecretIDRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeleteBindSecretID",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/bound-cidr-list": {
      "description": "Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleReadBoundCIDRList",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadBoundCIDRListResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWriteBoundCIDRList",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteBoundCIDRListRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeleteBoundCIDRList",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/custom-secret-id": {
      "description": "Assign a SecretID of choice against the role.",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "AppRoleWriteCustomSecretID",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteCustomSecretIDRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleWriteCustomSecretIDResponse"
                }
              }
            }
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/local-secret-ids": {
      "description": "Enables cluster local secret IDs",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleReadLocalSecretIDs",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadLocalSecretIDsResponse"
                }
              }
            }
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/period": {
      "description": "Updates the value of 'period' on the role",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleReadPeriod",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadPeriodResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWritePeriod",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWritePeriodRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeletePeriod",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/policies": {
      "description": "Policies of the role.",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleReadPolicies",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadPoliciesResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWritePolicies",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWritePoliciesRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeletePolicies",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/role-id": {
      "description": "Returns the 'role_id' of the role.",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleReadRoleID",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadRoleIDResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWriteRoleID",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteRoleIDRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/secret-id": {
      "description": "Generate a SecretID against this role.",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleListSecretID",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleListSecretIDResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWriteSecretID",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteSecretIDRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleWriteSecretIDResponse"
                }
              }
            }
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/destroy": {
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "AppRoleWriteSecretIDAccessorDestroy",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteSecretIDAccessorDestroyRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeleteSecretIDAccessorDestroy",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/secret-id-accessor/lookup": {
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "AppRoleWriteSecretIDAccessorLookup",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteSecretIDAccessorLookupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleWriteSecretIDAccessorLookupResponse"
                }
              }
            }
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/secret-id-bound-cidrs": {
      "description": "Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleReadSecretIDBoundCIDRs",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadSecretIDBoundCIDRsResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWriteSecretIDBoundCIDRs",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteSecretIDBoundCIDRsRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeleteSecretIDBoundCIDRs",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/secret-id-num-uses": {
      "description": "Use limit of the SecretID generated against the role.",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleReadSecretIDNumUses",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadSecretIDNumUsesResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWriteSecretIDNumUses",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteSecretIDNumUsesRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeleteSecretIDNumUses",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/secret-id-ttl": {
      "description": "Duration in seconds of the SecretID generated against the role.",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleReadSecretIDTTL",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadSecretIDTTLResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWriteSecretIDTTL",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteSecretIDTTLRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeleteSecretIDTTL",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/secret-id/destroy": {
      "description": "Invalidate an issued secret_id",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "AppRoleWriteSecretIDDestroy",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteSecretIDDestroyRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeleteSecretIDDestroy",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/secret-id/lookup": {
      "description": "Read the properties of an issued secret_id",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "AppRoleWriteSecretIDLookup",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteSecretIDLookupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleWriteSecretIDLookupResponse"
                }
              }
            }
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/token-bound-cidrs": {
      "description": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleReadTokenBoundCIDRs",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadTokenBoundCIDRsResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWriteTokenBoundCIDRs",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteTokenBoundCIDRsRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeleteTokenBoundCIDRs",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/token-max-ttl": {
      "description": "Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleReadTokenMaxTTL",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadTokenMaxTTLResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWriteTokenMaxTTL",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteTokenMaxTTLRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeleteTokenMaxTTL",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/token-num-uses": {
      "description": "Number of times issued tokens can be used",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleReadTokenNumUses",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadTokenNumUsesResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWriteTokenNumUses",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteTokenNumUsesRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeleteTokenNumUses",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/role/{role_name}/token-ttl": {
      "description": "Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role. Must be less than 4096 bytes.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AppRoleReadTokenTTL",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AppRoleReadTokenTTLResponse"
                }
              }
            }
          }
        }
      },
      "post": {
        "operationId": "AppRoleWriteTokenTTL",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AppRoleWriteTokenTTLRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      },
      "delete": {
        "operationId": "AppRoleDeleteTokenTTL",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "No Content"
          }
        }
      }
    },
    "/auth/{approle_mount_path}/tidy/secret-id": {
      "description": "Trigger the clean-up of expired SecretID entries.",
      "parameters": [
        {
          "name": "approle_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "approle"
          }
        }
      ],
      "post": {
        "summary": "Trigger the clean-up of expired SecretID entries.",
        "operationId": "AppRoleTidySecretID",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/config/certificate/{cert_name}": {
      "description": "Adds the AWS Public Key that is used to verify the PKCS#7 signature of the identity document.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        },
        {
          "name": "cert_name",
          "description": "Name of the certificate.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "AWSConfigReadCertificate",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AWSConfigWriteCertificate",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSConfigWriteCertificateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AWSConfigDeleteCertificate",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/config/certificates": {
      "description": "Lists all the AWS public certificates that are registered with the backend.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "get": {
        "operationId": "AWSConfigListCertificates",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/config/client": {
      "description": "Configure AWS IAM credentials that are used to query instance and role details from the AWS API.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "AWSConfigReadClient",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AWSConfigWriteClient",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSConfigWriteClientRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AWSConfigDeleteClient",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/config/identity": {
      "description": "Configure the way the AWS auth method interacts with the identity store",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "get": {
        "operationId": "AWSConfigReadIdentity",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AWSConfigWriteIdentity",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSConfigWriteIdentityRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/config/rotate-root": {
      "description": "Request to rotate the AWS credentials used by Vault",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "post": {
        "operationId": "AWSConfigRotateRoot",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/config/sts": {
      "description": "List all the AWS account/STS role relationships registered with Vault.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "get": {
        "operationId": "AWSConfigListSecurityTokenService",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/config/sts/{account_id}": {
      "description": "Specify STS roles to be assumed for certain AWS accounts.",
      "parameters": [
        {
          "name": "account_id",
          "description": "AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "AWSConfigReadSecurityTokenServiceAccount",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AWSConfigWriteSecurityTokenServiceAccount",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSConfigWriteSecurityTokenServiceAccountRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AWSConfigDeleteSecurityTokenServiceAccount",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/config/tidy/identity-accesslist": {
      "description": "Configures the periodic tidying operation of the access list identity entries.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "AWSConfigReadIdentityAccessList",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AWSConfigWriteIdentityAccessList",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSConfigWriteIdentityAccessListRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AWSConfigDeleteIdentityAccessList",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/config/tidy/identity-whitelist": {
      "description": "Configures the periodic tidying operation of the access list identity entries.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "AWSConfigReadIdentityWhiteList",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AWSConfigWriteIdentityWhiteList",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSConfigWriteIdentityWhiteListRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AWSConfigDeleteIdentityWhiteList",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/config/tidy/roletag-blacklist": {
      "description": "Configures the periodic tidying operation of the deny listed role tag entries.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "AWSConfigReadRoleTagBlackList",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AWSConfigWriteRoleTagBlackList",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSConfigWriteRoleTagBlackListRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AWSConfigDeleteRoleTagBlackList",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/config/tidy/roletag-denylist": {
      "description": "Configures the periodic tidying operation of the deny listed role tag entries.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "AWSConfigReadRoleTagDenyList",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AWSConfigWriteRoleTagDenyList",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSConfigWriteRoleTagDenyListRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AWSConfigDeleteRoleTagDenyList",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/identity-accesslist": {
      "description": "Lists the items present in the identity access list.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "get": {
        "operationId": "AWSListIdentityAccessList",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/identity-accesslist/{instance_id}": {
      "description": "Read or delete entries in the identity access list.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        },
        {
          "name": "instance_id",
          "description": "EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AWSReadIdentityAccessListFor",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AWSDeleteIdentityAccessListFor",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/identity-whitelist": {
      "description": "Lists the items present in the identity access list.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "get": {
        "operationId": "AWSListIdentityWhiteList",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/identity-whitelist/{instance_id}": {
      "description": "Read or delete entries in the identity access list.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        },
        {
          "name": "instance_id",
          "description": "EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AWSReadIdentityWhiteListFor",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AWSDeleteIdentityWhiteListFor",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/login": {
      "description": "Authenticates an EC2 instance with Vault.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "operationId": "AWSLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/role": {
      "description": "Lists all the roles that are registered with Vault.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "get": {
        "operationId": "AWSListAuthRoles",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/role/{role}": {
      "description": "Create a role and associate policies to it.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        },
        {
          "name": "role",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "AWSReadAuthRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AWSWriteAuthRole",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSWriteAuthRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AWSDeleteAuthRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/role/{role}/tag": {
      "description": "Create a tag on a role in order to be able to further restrict the capabilities of a role.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        },
        {
          "name": "role",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "AWSWriteAuthRoleTag",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSWriteAuthRoleTagRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/roles": {
      "description": "Lists all the roles that are registered with Vault.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "get": {
        "operationId": "AWSListAuthRoles2",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/roletag-blacklist": {
      "description": "Lists the deny list role tags.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "get": {
        "operationId": "AWSListRoleTagBlackList",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/roletag-blacklist/{role_tag}": {
      "description": "Blacklist a previously created role tag.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        },
        {
          "name": "role_tag",
          "description": "Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AWSReadRoleTagBlackListFor",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AWSWriteRoleTagBlackListFor",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AWSDeleteRoleTagBlackListFor",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/roletag-denylist": {
      "description": "Lists the deny list role tags.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "get": {
        "operationId": "AWSListRoleTagDenyList",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/roletag-denylist/{role_tag}": {
      "description": "Blacklist a previously created role tag.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        },
        {
          "name": "role_tag",
          "description": "Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AWSReadRoleTagDenyListFor",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AWSWriteRoleTagDenyListFor",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AWSDeleteRoleTagDenyListFor",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/tidy/identity-accesslist": {
      "description": "Clean-up the access list instance identity entries.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "post": {
        "operationId": "AWSWriteIdentityAccessListTidySettings",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSWriteIdentityAccessListTidySettingsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/tidy/identity-whitelist": {
      "description": "Clean-up the access list instance identity entries.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "post": {
        "operationId": "AWSWriteIdentityWhiteListTidySettings",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSWriteIdentityWhiteListTidySettingsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/tidy/roletag-blacklist": {
      "description": "Clean-up the deny list role tag entries.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "post": {
        "operationId": "AWSWriteRoleTagBlackListTidySettings",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSWriteRoleTagBlackListTidySettingsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{aws_mount_path}/tidy/roletag-denylist": {
      "description": "Clean-up the deny list role tag entries.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "post": {
        "operationId": "AWSWriteRoleTagDenyListTidySettings",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSWriteRoleTagDenyListTidySettingsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{azure_mount_path}/config": {
      "description": "Configures the Azure authentication backend.",
      "parameters": [
        {
          "name": "azure_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "azure"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "AzureReadAuthConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AzureWriteAuthConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AzureWriteAuthConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AzureDeleteAuthConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{azure_mount_path}/login": {
      "description": "Authenticates Azure Managed Service Identities with Vault.",
      "parameters": [
        {
          "name": "azure_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "azure"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "operationId": "AzureLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AzureLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{azure_mount_path}/role": {
      "description": "Lists all the roles registered with the backend.",
      "parameters": [
        {
          "name": "azure_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "azure"
          }
        }
      ],
      "get": {
        "operationId": "AzureListAuthRoles",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{azure_mount_path}/role/{name}": {
      "description": "Register an role with the backend.",
      "parameters": [
        {
          "name": "azure_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "azure"
          }
        },
        {
          "name": "name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "AzureReadAuthRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AzureWriteAuthRole",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AzureWriteAuthRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AzureDeleteAuthRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{centrify_mount_path}/config": {
      "description": "This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform for authenticating users.",
      "parameters": [
        {
          "name": "centrify_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "centrify"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform\nfor authenticating users.",
        "operationId": "CentrifyReadConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform\nfor authenticating users.",
        "operationId": "CentrifyWriteConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CentrifyWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{centrify_mount_path}/login": {
      "description": "Log in with a username and password.",
      "parameters": [
        {
          "name": "centrify_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "centrify"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Log in with a username and password.",
        "operationId": "CentrifyLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CentrifyLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{cert_mount_path}/certs": {
      "description": "Manage trusted certificates used for authentication.",
      "parameters": [
        {
          "name": "cert_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "cert"
          }
        }
      ],
      "x-vault-displayAttrs": {
        "navigation": true,
        "itemType": "Certificate"
      },
      "get": {
        "summary": "Manage trusted certificates used for authentication.",
        "operationId": "CertificatesList",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{cert_mount_path}/certs/{name}": {
      "description": "Manage trusted certificates used for authentication.",
      "parameters": [
        {
          "name": "cert_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "cert"
          }
        },
        {
          "name": "name",
          "description": "The name of the certificate",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-displayAttrs": {
        "itemType": "Certificate",
        "action": "Create"
      },
      "get": {
        "summary": "Manage trusted certificates used for authentication.",
        "operationId": "CertificatesRead",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage trusted certificates used for authentication.",
        "operationId": "CertificatesWrite",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CertificatesWriteRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage trusted certificates used for authentication.",
        "operationId": "CertificatesDelete",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{cert_mount_path}/config": {
      "parameters": [
        {
          "name": "cert_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "cert"
          }
        }
      ],
      "get": {
        "operationId": "CertificatesReadConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "CertificatesWriteConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CertificatesWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{cert_mount_path}/crls": {
      "description": "Manage Certificate Revocation Lists checked during authentication.",
      "parameters": [
        {
          "name": "cert_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "cert"
          }
        }
      ],
      "get": {
        "operationId": "CertificatesListCRLs",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{cert_mount_path}/crls/{name}": {
      "description": "Manage Certificate Revocation Lists checked during authentication.",
      "parameters": [
        {
          "name": "cert_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "cert"
          }
        },
        {
          "name": "name",
          "description": "The name of the certificate",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Manage Certificate Revocation Lists checked during authentication.",
        "operationId": "CertificatesReadCRL",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage Certificate Revocation Lists checked during authentication.",
        "operationId": "CertificatesWriteCRL",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CertificatesWriteCRLRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage Certificate Revocation Lists checked during authentication.",
        "operationId": "CertificatesDeleteCRL",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{cert_mount_path}/login": {
      "parameters": [
        {
          "name": "cert_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "cert"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "operationId": "CertificatesLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CertificatesLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{cf_mount_path}/config": {
      "description": "Provide Vault with the CA certificate used to issue all client certificates.",
      "parameters": [
        {
          "name": "cf_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "cf"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "CloudFoundryReadConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "CloudFoundryWriteConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CloudFoundryWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "CloudFoundryDeleteConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{cf_mount_path}/login": {
      "description": "Authenticates an entity with Vault.",
      "parameters": [
        {
          "name": "cf_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "cf"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "operationId": "CloudFoundryLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CloudFoundryLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{cf_mount_path}/roles": {
      "description": "List the existing roles in this backend.",
      "parameters": [
        {
          "name": "cf_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "cf"
          }
        }
      ],
      "get": {
        "operationId": "CloudFoundryListRoles",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{cf_mount_path}/roles/{role}": {
      "description": "Read, write and reference policies and roles that tokens can be made for.",
      "parameters": [
        {
          "name": "cf_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "cf"
          }
        },
        {
          "name": "role",
          "description": "The name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "CloudFoundryReadRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "CloudFoundryWriteRole",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CloudFoundryWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "CloudFoundryDeleteRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{gcp_mount_path}/config": {
      "description": "Configure credentials used to query the GCP IAM API to verify authenticating service accounts",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        }
      ],
      "get": {
        "summary": "Configure credentials used to query the GCP IAM API to verify authenticating service accounts",
        "operationId": "GoogleCloudReadAuthConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure credentials used to query the GCP IAM API to verify authenticating service accounts",
        "operationId": "GoogleCloudWriteAuthConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudWriteAuthConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{gcp_mount_path}/login": {
      "description": "Authenticates Google Cloud Platform entities with Vault.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "operationId": "GoogleCloudLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{gcp_mount_path}/role": {
      "description": "Lists all the roles that are registered with Vault.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        }
      ],
      "get": {
        "summary": "Lists all the roles that are registered with Vault.",
        "operationId": "GoogleCloudListRoles",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{gcp_mount_path}/role/{name}": {
      "description": "Create a GCP role with associated policies and required attributes.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Create a GCP role with associated policies and required attributes.",
        "operationId": "GoogleCloudReadRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Create a GCP role with associated policies and required attributes.",
        "operationId": "GoogleCloudWriteRole",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Create a GCP role with associated policies and required attributes.",
        "operationId": "GoogleCloudDeleteRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{gcp_mount_path}/role/{name}/labels": {
      "description": "Add or remove labels for an existing 'gce' role",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Add or remove labels for an existing 'gce' role",
        "operationId": "GoogleCloudWriteRoleLabels",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudWriteRoleLabelsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{gcp_mount_path}/role/{name}/service-accounts": {
      "description": "Add or remove service accounts for an existing `iam` role",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Add or remove service accounts for an existing `iam` role",
        "operationId": "GoogleCloudWriteRoleServiceAccounts",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudWriteRoleServiceAccountsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{gcp_mount_path}/roles": {
      "description": "Lists all the roles that are registered with Vault.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        }
      ],
      "get": {
        "summary": "Lists all the roles that are registered with Vault.",
        "operationId": "GoogleCloudListRoles2",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{github_mount_path}/config": {
      "parameters": [
        {
          "name": "github_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "github"
          }
        }
      ],
      "get": {
        "operationId": "GitHubReadConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "GitHubWriteConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GitHubWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{github_mount_path}/login": {
      "parameters": [
        {
          "name": "github_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "github"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "operationId": "GitHubLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GitHubLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{github_mount_path}/map/teams": {
      "description": "Read mappings for teams",
      "parameters": [
        {
          "name": "github_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "github"
          }
        }
      ],
      "get": {
        "summary": "Read mappings for teams",
        "operationId": "GitHubReadMapTeams",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{github_mount_path}/map/teams/{key}": {
      "description": "Read/write/delete a single teams mapping",
      "parameters": [
        {
          "name": "github_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "github"
          }
        },
        {
          "name": "key",
          "description": "Key for the teams mapping",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read/write/delete a single teams mapping",
        "operationId": "GitHubReadMapTeam",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Read/write/delete a single teams mapping",
        "operationId": "GitHubWriteMapTeam",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GitHubWriteMapTeamRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Read/write/delete a single teams mapping",
        "operationId": "GitHubDeleteMapTeam",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{github_mount_path}/map/users": {
      "description": "Read mappings for users",
      "parameters": [
        {
          "name": "github_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "github"
          }
        }
      ],
      "get": {
        "summary": "Read mappings for users",
        "operationId": "GitHubReadMapUsers",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{github_mount_path}/map/users/{key}": {
      "description": "Read/write/delete a single users mapping",
      "parameters": [
        {
          "name": "github_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "github"
          }
        },
        {
          "name": "key",
          "description": "Key for the users mapping",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read/write/delete a single users mapping",
        "operationId": "GitHubReadMapUser",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Read/write/delete a single users mapping",
        "operationId": "GitHubWriteMapUser",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GitHubWriteMapUserRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Read/write/delete a single users mapping",
        "operationId": "GitHubDeleteMapUser",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{jwt_mount_path}/config": {
      "description": "Configures the JWT authentication backend.",
      "parameters": [
        {
          "name": "jwt_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "jwt"
          }
        }
      ],
      "get": {
        "summary": "Read the current JWT authentication backend configuration.",
        "operationId": "JWTReadConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the JWT authentication backend.",
        "description": "The JWT authentication backend validates JWTs (or OIDC) using the configured\ncredentials. If using OIDC Discovery, the URL must be provided, along\nwith (optionally) the CA cert to use for the connection. If performing JWT\nvalidation locally, a set of public keys must be provided.",
        "operationId": "JWTWriteConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JWTWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{jwt_mount_path}/login": {
      "description": "Authenticates to Vault using a JWT (or OIDC) token.",
      "parameters": [
        {
          "name": "jwt_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "jwt"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Authenticates to Vault using a JWT (or OIDC) token.",
        "operationId": "JWTLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JWTLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{jwt_mount_path}/oidc/auth_url": {
      "parameters": [
        {
          "name": "jwt_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "jwt"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Request an authorization URL to start an OIDC login flow.",
        "operationId": "JWTWriteOIDCAuthURL",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JWTWriteOIDCAuthURLRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{jwt_mount_path}/oidc/callback": {
      "parameters": [
        {
          "name": "jwt_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "jwt"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Callback endpoint to complete an OIDC login.",
        "operationId": "JWTReadOIDCCallback",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Callback endpoint to handle form_posts.",
        "operationId": "JWTWriteOIDCCallback",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JWTWriteOIDCCallbackRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{jwt_mount_path}/role": {
      "description": "Lists all the roles registered with the backend.",
      "parameters": [
        {
          "name": "jwt_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "jwt"
          }
        }
      ],
      "get": {
        "summary": "Lists all the roles registered with the backend.",
        "description": "The list will contain the names of the roles.",
        "operationId": "JWTListRoles",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{jwt_mount_path}/role/{name}": {
      "description": "Register an role with the backend.",
      "parameters": [
        {
          "name": "jwt_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "jwt"
          }
        },
        {
          "name": "name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read an existing role.",
        "operationId": "JWTReadRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Register an role with the backend.",
        "description": "A role is required to authenticate with this backend. The role binds\n\t\tJWT token information with token policies and settings.\n\t\tThe bindings, token polices and token settings can all be configured\n\t\tusing this endpoint",
        "operationId": "JWTWriteRole",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JWTWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete an existing role.",
        "operationId": "JWTDeleteRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{kerberos_mount_path}/config": {
      "description": "Configures the Kerberos keytab and service account.",
      "parameters": [
        {
          "name": "kerberos_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kerberos"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "KerberosReadConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "KerberosWriteConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KerberosWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{kerberos_mount_path}/config/ldap": {
      "description": "Configure the LDAP server to connect to, along with its options.",
      "parameters": [
        {
          "name": "kerberos_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kerberos"
          }
        }
      ],
      "get": {
        "operationId": "KerberosReadLDAPConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "KerberosWriteLDAPConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KerberosWriteLDAPConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{kerberos_mount_path}/groups": {
      "description": "Manage users allowed to authenticate.",
      "parameters": [
        {
          "name": "kerberos_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kerberos"
          }
        }
      ],
      "get": {
        "operationId": "KerberosListGroups",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{kerberos_mount_path}/groups/{name}": {
      "description": "Manage users allowed to authenticate.",
      "parameters": [
        {
          "name": "kerberos_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kerberos"
          }
        },
        {
          "name": "name",
          "description": "Name of the LDAP group.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "KerberosReadGroup",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "KerberosWriteGroup",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KerberosWriteGroupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "KerberosDeleteGroup",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{kerberos_mount_path}/login": {
      "parameters": [
        {
          "name": "kerberos_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kerberos"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "operationId": "KerberosLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KerberosLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{kubernetes_mount_path}/config": {
      "description": "Configures the JWT Public Key and Kubernetes API information.",
      "parameters": [
        {
          "name": "kubernetes_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kubernetes"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Configures the JWT Public Key and Kubernetes API information.",
        "operationId": "KubernetesReadAuthConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configures the JWT Public Key and Kubernetes API information.",
        "operationId": "KubernetesWriteAuthConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KubernetesWriteAuthConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{kubernetes_mount_path}/login": {
      "description": "Authenticates Kubernetes service accounts with Vault.",
      "parameters": [
        {
          "name": "kubernetes_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kubernetes"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Authenticates Kubernetes service accounts with Vault.",
        "operationId": "KubernetesLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KubernetesLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{kubernetes_mount_path}/role": {
      "description": "Lists all the roles registered with the backend.",
      "parameters": [
        {
          "name": "kubernetes_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kubernetes"
          }
        }
      ],
      "x-vault-displayAttrs": {
        "navigation": true,
        "itemType": "Role"
      },
      "get": {
        "summary": "Lists all the roles registered with the backend.",
        "operationId": "KubernetesListAuthRoles",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{kubernetes_mount_path}/role/{name}": {
      "description": "Register an role with the backend.",
      "parameters": [
        {
          "name": "kubernetes_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kubernetes"
          }
        },
        {
          "name": "name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "x-vault-displayAttrs": {
        "itemType": "Role",
        "action": "Create"
      },
      "get": {
        "summary": "Register an role with the backend.",
        "operationId": "KubernetesReadAuthRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Register an role with the backend.",
        "operationId": "KubernetesWriteAuthRole",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KubernetesWriteAuthRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Register an role with the backend.",
        "operationId": "KubernetesDeleteAuthRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{ldap_mount_path}/config": {
      "description": "Configure the LDAP server to connect to, along with its options.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        }
      ],
      "x-vault-displayAttrs": {
        "action": "Configure"
      },
      "get": {
        "summary": "Configure the LDAP server to connect to, along with its options.",
        "operationId": "LDAPReadAuthConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the LDAP server to connect to, along with its options.",
        "operationId": "LDAPWriteAuthConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LDAPWriteAuthConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{ldap_mount_path}/groups": {
      "description": "Manage additional groups for users allowed to authenticate.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        }
      ],
      "x-vault-displayAttrs": {
        "navigation": true,
        "itemType": "Group"
      },
      "get": {
        "summary": "Manage additional groups for users allowed to authenticate.",
        "operationId": "LDAPListGroups",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{ldap_mount_path}/groups/{name}": {
      "description": "Manage additional groups for users allowed to authenticate.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        },
        {
          "name": "name",
          "description": "Name of the LDAP group.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-displayAttrs": {
        "itemType": "Group",
        "action": "Create"
      },
      "get": {
        "summary": "Manage additional groups for users allowed to authenticate.",
        "operationId": "LDAPReadGroup",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage additional groups for users allowed to authenticate.",
        "operationId": "LDAPWriteGroup",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LDAPWriteGroupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage additional groups for users allowed to authenticate.",
        "operationId": "LDAPDeleteGroup",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{ldap_mount_path}/login/{username}": {
      "description": "Log in with a username and password.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        },
        {
          "name": "username",
          "description": "DN (distinguished name) to be used for login.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Log in with a username and password.",
        "operationId": "LDAPLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LDAPLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{ldap_mount_path}/users": {
      "description": "Manage users allowed to authenticate.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        }
      ],
      "x-vault-displayAttrs": {
        "navigation": true,
        "itemType": "User"
      },
      "get": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "LDAPListUsers",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{ldap_mount_path}/users/{name}": {
      "description": "Manage users allowed to authenticate.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        },
        {
          "name": "name",
          "description": "Name of the LDAP user.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-displayAttrs": {
        "itemType": "User",
        "action": "Create"
      },
      "get": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "LDAPReadUser",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "LDAPWriteUser",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LDAPWriteUserRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "LDAPDeleteUser",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{oci_mount_path}/config": {
      "description": "Manages the configuration for the Vault Auth Plugin.",
      "parameters": [
        {
          "name": "oci_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "oci"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Manages the configuration for the Vault Auth Plugin.",
        "operationId": "OCIReadConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manages the configuration for the Vault Auth Plugin.",
        "operationId": "OCIWriteConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OCIWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manages the configuration for the Vault Auth Plugin.",
        "operationId": "OCIDeleteConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{oci_mount_path}/login": {
      "description": "Determines the role that would be used for login from a valid OCI login request",
      "parameters": [
        {
          "name": "oci_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "oci"
          }
        }
      ]
    },
    "/auth/{oci_mount_path}/login/{role}": {
      "description": "Authenticates to Vault using OCI credentials",
      "parameters": [
        {
          "name": "oci_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "oci"
          }
        },
        {
          "name": "role",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Authenticates to Vault using OCI credentials",
        "operationId": "OCILoginWithRole",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OCILoginWithRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{oci_mount_path}/role": {
      "description": "Lists all the roles that are registered with Vault.",
      "parameters": [
        {
          "name": "oci_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "oci"
          }
        }
      ],
      "get": {
        "summary": "Lists all the roles that are registered with Vault.",
        "operationId": "OCIListRoles",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{oci_mount_path}/role/{role}": {
      "description": "Create a role and associate policies to it.",
      "parameters": [
        {
          "name": "oci_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "oci"
          }
        },
        {
          "name": "role",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Create a role and associate policies to it.",
        "operationId": "OCIReadRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Create a role and associate policies to it.",
        "operationId": "OCIWriteRole",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OCIWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Create a role and associate policies to it.",
        "operationId": "OCIDeleteRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{oidc_mount_path}/config": {
      "description": "Configures the JWT authentication backend.",
      "parameters": [
        {
          "name": "oidc_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "oidc"
          }
        }
      ],
      "get": {
        "summary": "Read the current JWT authentication backend configuration.",
        "operationId": "OIDCReadAuthConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the JWT authentication backend.",
        "description": "The JWT authentication backend validates JWTs (or OIDC) using the configured\ncredentials. If using OIDC Discovery, the URL must be provided, along\nwith (optionally) the CA cert to use for the connection. If performing JWT\nvalidation locally, a set of public keys must be provided.",
        "operationId": "OIDCWriteAuthConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCWriteAuthConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{oidc_mount_path}/login": {
      "description": "Authenticates to Vault using a JWT (or OIDC) token.",
      "parameters": [
        {
          "name": "oidc_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "oidc"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Authenticates to Vault using a JWT (or OIDC) token.",
        "operationId": "OIDCLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{oidc_mount_path}/oidc/auth_url": {
      "parameters": [
        {
          "name": "oidc_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "oidc"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Request an authorization URL to start an OIDC login flow.",
        "operationId": "OIDCWriteAuthURL",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCWriteAuthURLRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{oidc_mount_path}/oidc/callback": {
      "parameters": [
        {
          "name": "oidc_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "oidc"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Callback endpoint to complete an OIDC login.",
        "operationId": "OIDCReadCallback",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Callback endpoint to handle form_posts.",
        "operationId": "OIDCWriteCallback",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCWriteCallbackRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{oidc_mount_path}/role": {
      "description": "Lists all the roles registered with the backend.",
      "parameters": [
        {
          "name": "oidc_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "oidc"
          }
        }
      ],
      "get": {
        "summary": "Lists all the roles registered with the backend.",
        "description": "The list will contain the names of the roles.",
        "operationId": "OIDCListAuthRoles",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{oidc_mount_path}/role/{name}": {
      "description": "Register an role with the backend.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "oidc_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "oidc"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read an existing role.",
        "operationId": "OIDCReadAuthRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Register an role with the backend.",
        "description": "A role is required to authenticate with this backend. The role binds\n\t\tJWT token information with token policies and settings.\n\t\tThe bindings, token polices and token settings can all be configured\n\t\tusing this endpoint",
        "operationId": "OIDCWriteAuthRole",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCWriteAuthRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete an existing role.",
        "operationId": "OIDCDeleteAuthRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{okta_mount_path}/config": {
      "description": "This endpoint allows you to configure the Okta and its configuration options. The Okta organization are the characters at the front of the URL for Okta. Example https://ORG.okta.com",
      "parameters": [
        {
          "name": "okta_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "okta"
          }
        }
      ],
      "x-vault-createSupported": true,
      "x-vault-displayAttrs": {
        "action": "Configure"
      },
      "get": {
        "summary": "This endpoint allows you to configure the Okta and its\nconfiguration options.\n\nThe Okta organization are the characters at the front of the URL for Okta.\nExample https://ORG.okta.com",
        "operationId": "OktaReadConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "This endpoint allows you to configure the Okta and its\nconfiguration options.\n\nThe Okta organization are the characters at the front of the URL for Okta.\nExample https://ORG.okta.com",
        "operationId": "OktaWriteConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OktaWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{okta_mount_path}/groups": {
      "description": "Manage users allowed to authenticate.",
      "parameters": [
        {
          "name": "okta_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "okta"
          }
        }
      ],
      "x-vault-displayAttrs": {
        "navigation": true,
        "itemType": "Group"
      },
      "get": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "OktaListGroups",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{okta_mount_path}/groups/{name}": {
      "description": "Manage users allowed to authenticate.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the Okta group.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "okta_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "okta"
          }
        }
      ],
      "x-vault-displayAttrs": {
        "itemType": "Group",
        "action": "Create"
      },
      "get": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "OktaReadGroup",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "OktaWriteGroup",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OktaWriteGroupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "OktaDeleteGroup",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{okta_mount_path}/login/{username}": {
      "description": "Log in with a username and password.",
      "parameters": [
        {
          "name": "okta_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "okta"
          }
        },
        {
          "name": "username",
          "description": "Username to be used for login.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Log in with a username and password.",
        "operationId": "OktaLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OktaLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{okta_mount_path}/users": {
      "description": "Manage additional groups for users allowed to authenticate.",
      "parameters": [
        {
          "name": "okta_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "okta"
          }
        }
      ],
      "x-vault-displayAttrs": {
        "navigation": true,
        "itemType": "User"
      },
      "get": {
        "summary": "Manage additional groups for users allowed to authenticate.",
        "operationId": "OktaListUsers",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{okta_mount_path}/users/{name}": {
      "description": "Manage additional groups for users allowed to authenticate.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the user.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "okta_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "okta"
          }
        }
      ],
      "x-vault-displayAttrs": {
        "itemType": "User",
        "action": "Create"
      },
      "get": {
        "summary": "Manage additional groups for users allowed to authenticate.",
        "operationId": "OktaReadUser",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage additional groups for users allowed to authenticate.",
        "operationId": "OktaWriteUser",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OktaWriteUserRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage additional groups for users allowed to authenticate.",
        "operationId": "OktaDeleteUser",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{okta_mount_path}/verify/{nonce}": {
      "parameters": [
        {
          "name": "nonce",
          "description": "Nonce provided during a login request to retrieve the number verification challenge for the matching request.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "okta_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "okta"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "operationId": "OktaVerify",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{radius_mount_path}/config": {
      "description": "Configure the RADIUS server to connect to, along with its options.",
      "parameters": [
        {
          "name": "radius_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "radius"
          }
        }
      ],
      "x-vault-createSupported": true,
      "x-vault-displayAttrs": {
        "action": "Configure"
      },
      "get": {
        "summary": "Configure the RADIUS server to connect to, along with its options.",
        "operationId": "RadiusReadConfig",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the RADIUS server to connect to, along with its options.",
        "operationId": "RadiusWriteConfig",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RadiusWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{radius_mount_path}/login": {
      "description": "Log in with a username and password.",
      "parameters": [
        {
          "name": "radius_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "radius"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Log in with a username and password.",
        "operationId": "RadiusLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RadiusLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{radius_mount_path}/login/{urlusername}": {
      "description": "Log in with a username and password.",
      "parameters": [
        {
          "name": "radius_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "radius"
          }
        },
        {
          "name": "urlusername",
          "description": "Username to be used for login. (URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Log in with a username and password.",
        "operationId": "RadiusLoginWithUsername",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RadiusLoginWithUsernameRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{radius_mount_path}/users": {
      "description": "Manage users allowed to authenticate.",
      "parameters": [
        {
          "name": "radius_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "radius"
          }
        }
      ],
      "x-vault-displayAttrs": {
        "navigation": true,
        "itemType": "User"
      },
      "get": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "RadiusListUsers",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{radius_mount_path}/users/{name}": {
      "description": "Manage users allowed to authenticate.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the RADIUS user.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "radius_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "radius"
          }
        }
      ],
      "x-vault-createSupported": true,
      "x-vault-displayAttrs": {
        "itemType": "User",
        "action": "Create"
      },
      "get": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "RadiusReadUser",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "RadiusWriteUser",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RadiusWriteUserRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "RadiusDeleteUser",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{token_mount_path}/accessors/": {
      "description": "List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires 'sudo' capability in addition to 'list'.",
      "parameters": [
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "List token accessors, which can then be\nbe used to iterate and discover their properties\nor revoke them. Because this can be used to\ncause a denial of service, this endpoint\nrequires 'sudo' capability in addition to\n'list'.",
        "operationId": "TokenListAccessors",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/create": {
      "description": "The token create path is used to create new tokens.",
      "parameters": [
        {
          "name": "format",
          "description": "Return json formatted output",
          "in": "query",
          "schema": {
            "type": "string"
          }
        },
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "post": {
        "summary": "The token create path is used to create new tokens.",
        "operationId": "TokenWriteCreate",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenWriteCreateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/create-orphan": {
      "description": "The token create path is used to create new orphan tokens.",
      "parameters": [
        {
          "name": "format",
          "description": "Return json formatted output",
          "in": "query",
          "schema": {
            "type": "string"
          }
        },
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "post": {
        "summary": "The token create path is used to create new orphan tokens.",
        "operationId": "TokenWriteCreateOrphan",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenWriteCreateOrphanRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/create/{role_name}": {
      "description": "This token create path is used to create new tokens adhering to the given role.",
      "parameters": [
        {
          "name": "format",
          "description": "Return json formatted output",
          "in": "query",
          "schema": {
            "type": "string"
          }
        },
        {
          "name": "role_name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "post": {
        "summary": "This token create path is used to create new tokens adhering to the given role.",
        "operationId": "TokenWriteCreateWithRole",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenWriteCreateWithRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/lookup": {
      "description": "This endpoint will lookup a token and its properties.",
      "parameters": [
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "get": {
        "summary": "This endpoint will lookup a token and its properties.",
        "operationId": "TokenReadLookup",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "This endpoint will lookup a token and its properties.",
        "operationId": "TokenWriteLookup",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenWriteLookupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/lookup-accessor": {
      "description": "This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.",
      "parameters": [
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "post": {
        "summary": "This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.",
        "operationId": "TokenWriteLookupAccessor",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenWriteLookupAccessorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/lookup-self": {
      "description": "This endpoint will lookup a token and its properties.",
      "parameters": [
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "get": {
        "summary": "This endpoint will lookup a token and its properties.",
        "operationId": "TokenReadLookupSelf",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "This endpoint will lookup a token and its properties.",
        "operationId": "TokenWriteLookupSelf",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenWriteLookupSelfRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/renew": {
      "description": "This endpoint will renew the given token and prevent expiration.",
      "parameters": [
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "post": {
        "summary": "This endpoint will renew the given token and prevent expiration.",
        "operationId": "TokenRenew",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenRenewRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/renew-accessor": {
      "description": "This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.",
      "parameters": [
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "post": {
        "summary": "This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.",
        "operationId": "TokenRenewAccessor",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenRenewAccessorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/renew-self": {
      "description": "This endpoint will renew the token used to call it and prevent expiration.",
      "parameters": [
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "post": {
        "summary": "This endpoint will renew the token used to call it and prevent expiration.",
        "operationId": "TokenRenewSelf",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenRenewSelfRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/revoke": {
      "description": "This endpoint will delete the given token and all of its child tokens.",
      "parameters": [
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "post": {
        "summary": "This endpoint will delete the given token and all of its child tokens.",
        "operationId": "TokenRevoke",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenRevokeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/revoke-accessor": {
      "description": "This endpoint will delete the token associated with the accessor and all of its child tokens.",
      "parameters": [
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "post": {
        "summary": "This endpoint will delete the token associated with the accessor and all of its child tokens.",
        "operationId": "TokenRevokeAccessor",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenRevokeAccessorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/revoke-orphan": {
      "description": "This endpoint will delete the token and orphan its child tokens.",
      "parameters": [
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "post": {
        "summary": "This endpoint will delete the token and orphan its child tokens.",
        "operationId": "TokenRevokeOrphan",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenRevokeOrphanRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/revoke-self": {
      "description": "This endpoint will delete the token used to call it and all of its child tokens.",
      "parameters": [
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "post": {
        "summary": "This endpoint will delete the token used to call it and all of its child tokens.",
        "operationId": "TokenRevokeSelf",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/roles": {
      "description": "This endpoint lists configured roles.",
      "parameters": [
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "get": {
        "summary": "This endpoint lists configured roles.",
        "operationId": "TokenListRoles",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{token_mount_path}/roles/{role_name}": {
      "parameters": [
        {
          "name": "role_name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "TokenReadRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "TokenWriteRole",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "TokenDeleteRole",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{token_mount_path}/tidy": {
      "description": "This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.",
      "parameters": [
        {
          "name": "token_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "token"
          }
        }
      ],
      "post": {
        "summary": "This endpoint performs cleanup tasks that can be run if certain error\nconditions have occurred.",
        "operationId": "TokenTidy",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{userpass_mount_path}/login/{username}": {
      "description": "Log in with a username and password.",
      "parameters": [
        {
          "name": "username",
          "description": "Username of the user.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "userpass_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "userpass"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Log in with a username and password.",
        "operationId": "UserpassLogin",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserpassLoginRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{userpass_mount_path}/users": {
      "description": "Manage users allowed to authenticate.",
      "parameters": [
        {
          "name": "userpass_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "userpass"
          }
        }
      ],
      "x-vault-displayAttrs": {
        "navigation": true,
        "itemType": "User"
      },
      "get": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "UserpassListUsers",
        "tags": [
          "auth"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{userpass_mount_path}/users/{username}": {
      "description": "Manage users allowed to authenticate.",
      "parameters": [
        {
          "name": "username",
          "description": "Username for this user.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "userpass_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "userpass"
          }
        }
      ],
      "x-vault-createSupported": true,
      "x-vault-displayAttrs": {
        "itemType": "User",
        "action": "Create"
      },
      "get": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "UserpassReadUser",
        "tags": [
          "auth"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "UserpassWriteUser",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserpassWriteUserRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage users allowed to authenticate.",
        "operationId": "UserpassDeleteUser",
        "tags": [
          "auth"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{userpass_mount_path}/users/{username}/password": {
      "description": "Reset user's password.",
      "parameters": [
        {
          "name": "username",
          "description": "Username for this user.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "userpass_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "userpass"
          }
        }
      ],
      "post": {
        "summary": "Reset user's password.",
        "operationId": "UserpassWriteUserPassword",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserpassWriteUserPasswordRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{userpass_mount_path}/users/{username}/policies": {
      "description": "Update the policies associated with the username.",
      "parameters": [
        {
          "name": "username",
          "description": "Username for this user.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "userpass_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "userpass"
          }
        }
      ],
      "post": {
        "summary": "Update the policies associated with the username.",
        "operationId": "UserpassWriteUserPolicies",
        "tags": [
          "auth"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserpassWriteUserPoliciesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/alias": {
      "description": "Create a new alias.",
      "post": {
        "summary": "Create a new alias.",
        "operationId": "AliasWrite",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AliasWriteRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/alias/id": {
      "description": "List all the alias IDs.",
      "get": {
        "summary": "List all the alias IDs.",
        "operationId": "AliasListByID",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/alias/id/{id}": {
      "description": "Update, read or delete an alias ID.",
      "parameters": [
        {
          "name": "id",
          "description": "ID of the alias",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "AliasReadByID",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "AliasWriteByID",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AliasWriteByIDRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "AliasDeleteByID",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/entity": {
      "description": "Create a new entity",
      "post": {
        "summary": "Create a new entity",
        "operationId": "EntityWrite",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityWriteRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity-alias": {
      "description": "Create a new alias.",
      "post": {
        "summary": "Create a new alias.",
        "operationId": "EntityWriteAlias",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityWriteAliasRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity-alias/id": {
      "description": "List all the alias IDs.",
      "get": {
        "summary": "List all the alias IDs.",
        "operationId": "EntityListAliasesByID",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity-alias/id/{id}": {
      "description": "Update, read or delete an alias ID.",
      "parameters": [
        {
          "name": "id",
          "description": "ID of the alias",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "EntityReadAliasByID",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "EntityWriteAliasByID",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityWriteAliasByIDRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "EntityDeleteAliasByID",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/entity/batch-delete": {
      "description": "Delete all of the entities provided",
      "post": {
        "summary": "Delete all of the entities provided",
        "operationId": "EntityBatchDelete",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityBatchDeleteRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity/id": {
      "description": "List all the entity IDs",
      "get": {
        "summary": "List all the entity IDs",
        "operationId": "EntityListByID",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity/id/{id}": {
      "description": "Update, read or delete an entity using entity ID",
      "parameters": [
        {
          "name": "id",
          "description": "ID of the entity. If set, updates the corresponding existing entity.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Update, read or delete an entity using entity ID",
        "operationId": "EntityReadByID",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update, read or delete an entity using entity ID",
        "operationId": "EntityWriteByID",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityWriteByIDRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Update, read or delete an entity using entity ID",
        "operationId": "EntityDeleteByID",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/entity/merge": {
      "description": "Merge two or more entities together",
      "post": {
        "summary": "Merge two or more entities together",
        "operationId": "EntityMerge",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityMergeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity/name": {
      "description": "List all the entity names",
      "get": {
        "summary": "List all the entity names",
        "operationId": "EntityListByName",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/entity/name/{name}": {
      "description": "Update, read or delete an entity using entity name",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the entity",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Update, read or delete an entity using entity name",
        "operationId": "EntityReadByName",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update, read or delete an entity using entity name",
        "operationId": "EntityWriteByName",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityWriteByNameRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Update, read or delete an entity using entity name",
        "operationId": "EntityDeleteByName",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/group": {
      "description": "Create a new group.",
      "post": {
        "summary": "Create a new group.",
        "operationId": "GroupWrite",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GroupWriteRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/group-alias": {
      "description": "Creates a new group alias, or updates an existing one.",
      "post": {
        "summary": "Creates a new group alias, or updates an existing one.",
        "operationId": "GroupWriteAlias",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GroupWriteAliasRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/group-alias/id": {
      "description": "List all the group alias IDs.",
      "get": {
        "summary": "List all the group alias IDs.",
        "operationId": "GroupListAliasesByID",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/group-alias/id/{id}": {
      "parameters": [
        {
          "name": "id",
          "description": "ID of the group alias.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "GroupReadAliasByID",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "GroupWriteAliasByID",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GroupWriteAliasByIDRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "GroupDeleteAliasByID",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/group/id": {
      "description": "List all the group IDs.",
      "get": {
        "summary": "List all the group IDs.",
        "operationId": "GroupListByID",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/group/id/{id}": {
      "description": "Update or delete an existing group using its ID.",
      "parameters": [
        {
          "name": "id",
          "description": "ID of the group. If set, updates the corresponding existing group.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Update or delete an existing group using its ID.",
        "operationId": "GroupReadByID",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update or delete an existing group using its ID.",
        "operationId": "GroupWriteByID",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GroupWriteByIDRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Update or delete an existing group using its ID.",
        "operationId": "GroupDeleteByID",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/group/name": {
      "get": {
        "operationId": "GroupListByName",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/group/name/{name}": {
      "parameters": [
        {
          "name": "name",
          "description": "Name of the group.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "GroupReadByName",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "GroupWriteByName",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GroupWriteByNameRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "GroupDeleteByName",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/lookup/entity": {
      "description": "Query entities based on various properties.",
      "post": {
        "summary": "Query entities based on various properties.",
        "operationId": "EntityLookup",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EntityLookupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/lookup/group": {
      "description": "Query groups based on various properties.",
      "post": {
        "summary": "Query groups based on various properties.",
        "operationId": "GroupLookup",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GroupLookupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/mfa/login-enforcement": {
      "get": {
        "summary": "List login enforcements",
        "operationId": "MFAListLoginEnforcements",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/mfa/login-enforcement/{name}": {
      "parameters": [
        {
          "name": "name",
          "description": "Name for this login enforcement configuration",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read the current login enforcement",
        "operationId": "MFAReadLoginEnforcement",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Create or update a login enforcement",
        "operationId": "MFAWriteLoginEnforcement",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MFAWriteLoginEnforcementRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete a login enforcement",
        "operationId": "MFADeleteLoginEnforcement",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/mfa/method": {
      "get": {
        "summary": "List MFA method configurations for all MFA methods",
        "operationId": "MFAMethodList",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/mfa/method/duo": {
      "get": {
        "summary": "List MFA method configurations for the given MFA method",
        "operationId": "MFAMethodListDuo",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/mfa/method/duo/{method_id}": {
      "parameters": [
        {
          "name": "method_id",
          "description": "The unique identifier for this MFA method.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read the current configuration for the given MFA method",
        "operationId": "MFAMethodReadDuo",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update or create a configuration for the given MFA method",
        "operationId": "MFAMethodWriteDuo",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MFAMethodWriteDuoRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete a configuration for the given MFA method",
        "operationId": "MFAMethodDeleteDuo",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/mfa/method/okta": {
      "get": {
        "summary": "List MFA method configurations for the given MFA method",
        "operationId": "MFAMethodListOkta",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/mfa/method/okta/{method_id}": {
      "parameters": [
        {
          "name": "method_id",
          "description": "The unique identifier for this MFA method.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read the current configuration for the given MFA method",
        "operationId": "MFAMethodReadOkta",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update or create a configuration for the given MFA method",
        "operationId": "MFAMethodWriteOkta",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MFAMethodWriteOktaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete a configuration for the given MFA method",
        "operationId": "MFAMethodDeleteOkta",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/mfa/method/pingid": {
      "get": {
        "summary": "List MFA method configurations for the given MFA method",
        "operationId": "MFAMethodListPingID",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/mfa/method/pingid/{method_id}": {
      "parameters": [
        {
          "name": "method_id",
          "description": "The unique identifier for this MFA method.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read the current configuration for the given MFA method",
        "operationId": "MFAMethodReadPingID",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update or create a configuration for the given MFA method",
        "operationId": "MFAMethodWritePingID",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MFAMethodWritePingIDRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete a configuration for the given MFA method",
        "operationId": "MFAMethodDeletePingID",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/mfa/method/totp": {
      "get": {
        "summary": "List MFA method configurations for the given MFA method",
        "operationId": "MFAMethodListTOTP",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/mfa/method/totp/admin-destroy": {
      "post": {
        "summary": "Destroys a TOTP secret for the given MFA method ID on the given entity",
        "operationId": "MFAMethodAdminDestroyTOTP",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MFAMethodAdminDestroyTOTPRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/mfa/method/totp/admin-generate": {
      "post": {
        "summary": "Update or create TOTP secret for the given method ID on the given entity.",
        "operationId": "MFAMethodAdminGenerateTOTP",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MFAMethodAdminGenerateTOTPRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/mfa/method/totp/generate": {
      "post": {
        "summary": "Update or create TOTP secret for the given method ID on the given entity.",
        "operationId": "MFAMethodGenerateTOTP",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MFAMethodGenerateTOTPRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/mfa/method/totp/{method_id}": {
      "parameters": [
        {
          "name": "method_id",
          "description": "The unique identifier for this MFA method.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read the current configuration for the given MFA method",
        "operationId": "MFAMethodReadTOTP",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update or create a configuration for the given MFA method",
        "operationId": "MFAMethodWriteTOTP",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MFAMethodWriteTOTPRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete a configuration for the given MFA method",
        "operationId": "MFAMethodDeleteTOTP",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/mfa/method/{method_id}": {
      "parameters": [
        {
          "name": "method_id",
          "description": "The unique identifier for this MFA method.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read the current configuration for the given ID regardless of the MFA method type",
        "operationId": "MFAMethodRead",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/.well-known/keys": {
      "description": "Retrieve public keys",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Retrieve public keys",
        "operationId": "OIDCReadWellKnownKeys",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/.well-known/openid-configuration": {
      "description": "Query OIDC configurations",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Query OIDC configurations",
        "operationId": "OIDCReadWellKnownOpenIDConfiguration",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/assignment": {
      "description": "List OIDC assignments",
      "get": {
        "operationId": "OIDCListAssignments",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/assignment/{name}": {
      "description": "CRUD operations for OIDC assignments.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the assignment",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "OIDCReadAssignment",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "OIDCWriteAssignment",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCWriteAssignmentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "OIDCDeleteAssignment",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/oidc/client": {
      "description": "List OIDC clients",
      "get": {
        "operationId": "OIDCListClients",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/client/{name}": {
      "description": "CRUD operations for OIDC clients.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the client.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "OIDCReadClient",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "OIDCWriteClient",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCWriteClientRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "OIDCDeleteClient",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/oidc/config": {
      "description": "OIDC configuration",
      "get": {
        "summary": "OIDC configuration",
        "operationId": "OIDCReadConfig",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "OIDC configuration",
        "operationId": "OIDCWriteConfig",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/introspect": {
      "description": "Verify the authenticity of an OIDC token",
      "post": {
        "summary": "Verify the authenticity of an OIDC token",
        "operationId": "OIDCIntrospect",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCIntrospectRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/key": {
      "description": "List OIDC keys",
      "get": {
        "summary": "List OIDC keys",
        "operationId": "OIDCListKeys",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/key/{name}": {
      "description": "CRUD operations for OIDC keys.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "CRUD operations for OIDC keys.",
        "operationId": "OIDCReadKey",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "CRUD operations for OIDC keys.",
        "operationId": "OIDCWriteKey",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCWriteKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "CRUD operations for OIDC keys.",
        "operationId": "OIDCDeleteKey",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/oidc/key/{name}/rotate": {
      "description": "Rotate a named OIDC key.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Rotate a named OIDC key.",
        "operationId": "OIDCRotateKey",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCRotateKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/provider": {
      "description": "List OIDC providers",
      "parameters": [
        {
          "name": "allowed_client_id",
          "description": "Filters the list of OIDC providers to those that allow the given client ID in their set of allowed_client_ids.",
          "in": "query",
          "schema": {
            "type": "string",
            "default": ""
          }
        }
      ],
      "get": {
        "operationId": "OIDCListProviders",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/provider/{name}": {
      "description": "CRUD operations for OIDC providers.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the provider",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "OIDCReadProvider",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "OIDCWriteProvider",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCWriteProviderRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "OIDCDeleteProvider",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/oidc/provider/{name}/.well-known/keys": {
      "description": "Retrieve public keys",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the provider",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "OIDCReadProviderWellKnownKeys",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/provider/{name}/.well-known/openid-configuration": {
      "description": "Query OIDC configurations",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the provider",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "OIDCReadProviderWellKnownOpenIDConfiguration",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/provider/{name}/authorize": {
      "description": "Provides the OIDC Authorization Endpoint.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the provider",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "OIDCReadProviderAuthorize",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "OIDCWriteProviderAuthorize",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCWriteProviderAuthorizeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/provider/{name}/token": {
      "description": "Provides the OIDC Token Endpoint.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the provider",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "OIDCWriteProviderToken",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCWriteProviderTokenRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/provider/{name}/userinfo": {
      "description": "Provides the OIDC UserInfo Endpoint.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the provider",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "OIDCReadProviderUserInfo",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "OIDCWriteProviderUserInfo",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/role": {
      "description": "List configured OIDC roles",
      "get": {
        "summary": "List configured OIDC roles",
        "operationId": "OIDCListRoles",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/role/{name}": {
      "description": "CRUD operations on OIDC Roles",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "CRUD operations on OIDC Roles",
        "operationId": "OIDCReadRole",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "CRUD operations on OIDC Roles",
        "operationId": "OIDCWriteRole",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "CRUD operations on OIDC Roles",
        "operationId": "OIDCDeleteRole",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/oidc/scope": {
      "description": "List OIDC scopes",
      "get": {
        "operationId": "OIDCListScopes",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/oidc/scope/{name}": {
      "description": "CRUD operations for OIDC scopes.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the scope",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "OIDCReadScope",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "OIDCWriteScope",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OIDCWriteScopeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "OIDCDeleteScope",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/identity/oidc/token/{name}": {
      "description": "Generate an OIDC token",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Generate an OIDC token",
        "operationId": "OIDCReadToken",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/persona": {
      "description": "Create a new alias.",
      "post": {
        "summary": "Create a new alias.",
        "operationId": "PersonaWrite",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PersonaWriteRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/persona/id": {
      "description": "List all the alias IDs.",
      "get": {
        "summary": "List all the alias IDs.",
        "operationId": "PersonaListByID",
        "tags": [
          "identity"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/identity/persona/id/{id}": {
      "description": "Update, read or delete an alias ID.",
      "parameters": [
        {
          "name": "id",
          "description": "ID of the persona",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "PersonaIDReadByID",
        "tags": [
          "identity"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "PersonaIDWriteByID",
        "tags": [
          "identity"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PersonaIDWriteByIDRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Update, read or delete an alias ID.",
        "operationId": "PersonaIDDeleteByID",
        "tags": [
          "identity"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/audit": {
      "description": "List the currently enabled audit backends.",
      "x-vault-sudo": true,
      "get": {
        "summary": "List the enabled audit devices.",
        "operationId": "ReadAuditDevices",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/audit-hash/{path}": {
      "description": "The hash of the given string via the given audit backend",
      "parameters": [
        {
          "name": "path",
          "description": "The name of the backend. Cannot be delimited. Example: \"mysql\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "The hash of the given string via the given audit backend",
        "operationId": "CalculateAuditHash",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CalculateAuditHashRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/audit/{path}": {
      "description": "Enable or disable audit backends.",
      "parameters": [
        {
          "name": "path",
          "description": "The name of the backend. Cannot be delimited. Example: \"mysql\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Enable a new audit device at the supplied path.",
        "operationId": "WriteAuditDevice",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteAuditDeviceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Disable the audit device at the given path.",
        "operationId": "DeleteAuditDevice",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/auth": {
      "description": "List the currently enabled credential backends.",
      "get": {
        "summary": "List the currently enabled credential backends.",
        "operationId": "ReadAuthMethods",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/auth/{path}": {
      "description": "Enable a new credential backend with a name.",
      "parameters": [
        {
          "name": "path",
          "description": "The path to mount to. Cannot be delimited. Example: \"user\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Read the configuration of the auth engine at the given path.",
        "operationId": "ReadAuthMethod",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Enables a new auth method.",
        "description": "After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.\n\nFor example, enable the \"foo\" auth method will make it accessible at /auth/foo.",
        "operationId": "WriteAuthMethod",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteAuthMethodRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Disable the auth method at the given auth path",
        "operationId": "DeleteAuthMethod",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/auth/{path}/tune": {
      "description": "Tune the configuration parameters for an auth path.",
      "parameters": [
        {
          "name": "path",
          "description": "Tune the configuration parameters for an auth path.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Reads the given auth path's configuration.",
        "description": "This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.",
        "operationId": "ReadAuthMethodTune",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Tune configuration parameters for a given auth path.",
        "description": "This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.",
        "operationId": "WriteAuthMethodTune",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteAuthMethodTuneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/capabilities": {
      "description": "Fetches the capabilities of the given token on the given path.",
      "post": {
        "summary": "Fetches the capabilities of the given token on the given path.",
        "operationId": "WriteCapabilities",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteCapabilitiesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/capabilities-accessor": {
      "description": "Fetches the capabilities of the token associated with the given token, on the given path.",
      "post": {
        "summary": "Fetches the capabilities of the token associated with the given token, on the given path.",
        "operationId": "WriteCapabilitiesAccessor",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteCapabilitiesAccessorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/capabilities-self": {
      "description": "Fetches the capabilities of the given token on the given path.",
      "post": {
        "summary": "Fetches the capabilities of the given token on the given path.",
        "operationId": "WriteCapabilitiesSelf",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteCapabilitiesSelfRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/config/auditing/request-headers": {
      "description": "Lists the headers configured to be audited.",
      "x-vault-sudo": true,
      "get": {
        "summary": "List the request headers that are configured to be audited.",
        "operationId": "ReadConfigAuditingRequestHeaders",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/config/auditing/request-headers/{header}": {
      "description": "Configures the headers sent to the audit logs.",
      "parameters": [
        {
          "name": "header",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "List the information for the given request header.",
        "operationId": "ReadConfigAuditingRequestHeader",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Enable auditing of a header.",
        "operationId": "WriteConfigAuditingRequestHeader",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteConfigAuditingRequestHeaderRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Disable auditing of the given request header.",
        "operationId": "DeleteConfigAuditingRequestHeader",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/config/cors": {
      "description": "This path responds to the following HTTP methods. GET / Returns the configuration of the CORS setting. POST / Sets the comma-separated list of origins that can make cross-origin requests. DELETE / Clears the CORS configuration and disables acceptance of CORS requests.",
      "x-vault-sudo": true,
      "get": {
        "summary": "Return the current CORS settings.",
        "operationId": "ReadConfigCORS",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the CORS settings.",
        "operationId": "WriteConfigCORS",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteConfigCORSRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove any CORS settings.",
        "operationId": "DeleteConfigCORS",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/config/reload/{subsystem}": {
      "parameters": [
        {
          "name": "subsystem",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Reload the given subsystem",
        "operationId": "WriteConfigReloadSubsystem",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/config/state/sanitized": {
      "get": {
        "summary": "Return a sanitized version of the Vault server configuration.",
        "description": "The sanitized output strips configuration values in the storage, HA storage, and seals stanzas, which may contain sensitive values such as API tokens. It also removes any token or secret fields in other stanzas, such as the circonus_api_token from telemetry.",
        "operationId": "ReadConfigStateSanitized",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/config/ui/headers/": {
      "description": "This path responds to the following HTTP methods. GET /<header> Returns the header value. POST /<header> Sets the header value for the UI. DELETE /<header> Clears the header value for UI. LIST / List the headers configured for the UI.",
      "x-vault-sudo": true,
      "get": {
        "summary": "Return a list of configured UI headers.",
        "operationId": "ListConfigUIHeaders",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/config/ui/headers/{header}": {
      "description": "This path responds to the following HTTP methods. GET /<header> Returns the header value. POST /<header> Sets the header value for the UI. DELETE /<header> Clears the header value for UI. LIST / List the headers configured for the UI.",
      "parameters": [
        {
          "name": "header",
          "description": "The name of the header.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Return the given UI header's configuration",
        "operationId": "ReadConfigUIHeader",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the values to be returned for the UI header.",
        "operationId": "WriteConfigUIHeader",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteConfigUIHeaderRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove a UI header.",
        "operationId": "DeleteConfigUIHeader",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/generate-root": {
      "description": "Reads, generates, or deletes a root token regeneration process.",
      "get": {
        "summary": "Read the configuration and progress of the current root generation attempt.",
        "operationId": "ReadGenerateRoot",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Initializes a new root generation attempt.",
        "description": "Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.",
        "operationId": "WriteGenerateRoot",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteGenerateRootRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Cancels any in-progress root generation attempt.",
        "operationId": "DeleteGenerateRoot",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/generate-root/attempt": {
      "description": "Reads, generates, or deletes a root token regeneration process.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Read the configuration and progress of the current root generation attempt.",
        "operationId": "ReadGenerateRootAttempt",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Initializes a new root generation attempt.",
        "description": "Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.",
        "operationId": "WriteGenerateRootAttempt",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteGenerateRootAttemptRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Cancels any in-progress root generation attempt.",
        "operationId": "DeleteGenerateRootAttempt",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/generate-root/update": {
      "description": "Reads, generates, or deletes a root token regeneration process.",
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Enter a single unseal key share to progress the root generation attempt.",
        "description": "If the threshold number of unseal key shares is reached, Vault will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.",
        "operationId": "WriteGenerateRootUpdate",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteGenerateRootUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/ha-status": {
      "description": "Provides information about the nodes in an HA cluster.",
      "get": {
        "summary": "Check the HA status of a Vault cluster",
        "operationId": "ReadHAStatus",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/health": {
      "description": "Checks the health status of the Vault.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Returns the health status of Vault.",
        "operationId": "ReadHealth",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "initialized, unsealed, and active"
          },
          "429": {
            "description": "unsealed and standby"
          },
          "472": {
            "description": "data recovery mode replication secondary and active"
          },
          "501": {
            "description": "not initialized"
          },
          "503": {
            "description": "sealed"
          }
        }
      }
    },
    "/sys/host-info": {
      "description": "Information about the host instance that this Vault server is running on.",
      "get": {
        "summary": "Information about the host instance that this Vault server is running on.",
        "description": "Information about the host instance that this Vault server is running on.\n\t\tThe information that gets collected includes host hardware information, and CPU,\n\t\tdisk, and memory utilization",
        "operationId": "ReadHostInfo",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/in-flight-req": {
      "get": {
        "summary": "reports in-flight requests",
        "description": "This path responds to the following HTTP methods.\n\t\tGET /\n\t\t\tReturns a map of in-flight requests.",
        "operationId": "ReadInFlightRequests",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/init": {
      "description": "Initializes or returns the initialization status of the Vault.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Returns the initialization status of Vault.",
        "operationId": "ReadInit",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Initialize a new Vault.",
        "description": "The Vault must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using Vault HSM.",
        "operationId": "WriteInit",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteInitRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/counters/activity": {
      "description": "Query the historical count of clients.",
      "get": {
        "summary": "Report the client count metrics, for this namespace and all child namespaces.",
        "operationId": "ReadInternalCountersActivity",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/counters/activity/export": {
      "description": "Export the historical activity of clients.",
      "get": {
        "summary": "Report the client count metrics, for this namespace and all child namespaces.",
        "operationId": "ReadInternalCountersActivityExport",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/counters/activity/monthly": {
      "description": "Count of active clients so far this month.",
      "get": {
        "summary": "Report the number of clients for this month, for this namespace and all child namespaces.",
        "operationId": "ReadInternalCountersActivityMonthly",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/counters/config": {
      "description": "Control the collection and reporting of client counts.",
      "get": {
        "summary": "Read the client count tracking configuration.",
        "operationId": "ReadInternalCountersConfig",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Enable or disable collection of client count, set retention period, or set default reporting period.",
        "operationId": "WriteInternalCountersConfig",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteInternalCountersConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/counters/entities": {
      "description": "Count of active entities in this Vault cluster.",
      "get": {
        "summary": "Backwards compatibility is not guaranteed for this API",
        "operationId": "ReadInternalCountersEntities",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/counters/requests": {
      "description": "Currently unsupported. Previously, count of requests seen by this Vault cluster over time.",
      "get": {
        "summary": "Backwards compatibility is not guaranteed for this API",
        "operationId": "ReadInternalCountersRequests",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/counters/tokens": {
      "description": "Count of active tokens in this Vault cluster.",
      "get": {
        "summary": "Backwards compatibility is not guaranteed for this API",
        "operationId": "ReadInternalCountersTokens",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/inspect/router/{tag}": {
      "description": "Information on the entries in each of the trees in the router. Inspectable trees are uuid, accessor, storage, and root.",
      "parameters": [
        {
          "name": "tag",
          "description": "Name of subtree being observed",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Expose the route entry and mount entry tables present in the router",
        "operationId": "ReadInternalInspectRouter",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/specs/openapi": {
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Generate an OpenAPI 3 document of all mounted paths.",
        "operationId": "ReadInternalSpecsOpenAPI",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/ui/feature-flags": {
      "description": "Enabled feature flags. Internal API; its location, inputs, and outputs may change.",
      "get": {
        "summary": "Lists enabled feature flags.",
        "operationId": "ReadInternalUIFeatureFlags",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/ui/mounts": {
      "description": "Information about mounts returned according to their tuned visibility. Internal API; its location, inputs, and outputs may change.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Lists all enabled and visible auth and secrets mounts.",
        "operationId": "ReadInternalUIMounts",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/ui/mounts/{path}": {
      "description": "Information about mounts returned according to their tuned visibility. Internal API; its location, inputs, and outputs may change.",
      "parameters": [
        {
          "name": "path",
          "description": "The path of the mount.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Return information about the given mount.",
        "operationId": "ReadInternalUIMount",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/ui/namespaces": {
      "description": "Information about visible child namespaces. Internal API; its location, inputs, and outputs may change.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Backwards compatibility is not guaranteed for this API",
        "operationId": "ReadInternalUINamespaces",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/internal/ui/resultant-acl": {
      "description": "Information about a token's resultant ACL. Internal API; its location, inputs, and outputs may change.",
      "get": {
        "summary": "Backwards compatibility is not guaranteed for this API",
        "operationId": "ReadInternalUIResultantACL",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/key-status": {
      "description": "Provides information about the backend encryption key.",
      "get": {
        "summary": "Provides information about the backend encryption key.",
        "operationId": "ReadKeyStatus",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leader": {
      "description": "Check the high availability status and current leader of Vault",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Returns the high availability status and current leader instance of Vault.",
        "operationId": "ReadLeader",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases": {
      "description": "List leases associated with this Vault cluster",
      "x-vault-sudo": true,
      "get": {
        "summary": "List leases associated with this Vault cluster",
        "operationId": "ReadLeases",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/count": {
      "description": "Count of leases associated with this Vault cluster",
      "get": {
        "summary": "Count of leases associated with this Vault cluster",
        "operationId": "ReadLeasesCount",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/lookup": {
      "description": "View or list lease metadata.",
      "post": {
        "summary": "Retrieve lease metadata.",
        "operationId": "WriteLeasesLookup",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteLeasesLookupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/lookup/": {
      "description": "View or list lease metadata.",
      "x-vault-sudo": true,
      "get": {
        "summary": "Returns a list of lease ids.",
        "operationId": "SysListLeasesLookup",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/lookup/{prefix}": {
      "description": "View or list lease metadata.",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to list leases under. Example: \"aws/creds/deploy\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Returns a list of lease ids.",
        "operationId": "ListLeasesLookupPrefix",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/renew": {
      "description": "Renew a lease on a secret",
      "post": {
        "summary": "Renews a lease, requesting to extend the lease.",
        "operationId": "WriteLeasesRenew",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteLeasesRenewRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/renew/{url_lease_id}": {
      "description": "Renew a lease on a secret",
      "parameters": [
        {
          "name": "url_lease_id",
          "description": "The lease identifier to renew. This is included with a lease.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Renews a lease, requesting to extend the lease.",
        "operationId": "WriteLeasesRenew2",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteLeasesRenew2Request"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/revoke": {
      "description": "Revoke a leased secret immediately",
      "post": {
        "summary": "Revokes a lease immediately.",
        "operationId": "WriteLeasesRevoke",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteLeasesRevokeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/revoke-force/{prefix}": {
      "description": "Revoke all secrets generated in a given prefix, ignoring errors.",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to revoke keys under. Example: \"prod/aws/ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Revokes all secrets or tokens generated under a given prefix immediately",
        "description": "Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.\n\nBy ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.",
        "operationId": "WriteLeasesRevokeForce",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/revoke-prefix/{prefix}": {
      "description": "Revoke all secrets generated in a given prefix",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to revoke keys under. Example: \"prod/aws/ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Revokes all secrets (via a lease ID prefix) or tokens (via the tokens' path property) generated under a given prefix immediately.",
        "operationId": "WriteLeasesRevokePrefix",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteLeasesRevokePrefixRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/revoke/{url_lease_id}": {
      "description": "Revoke a leased secret immediately",
      "parameters": [
        {
          "name": "url_lease_id",
          "description": "The lease identifier to renew. This is included with a lease.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Revokes a lease immediately.",
        "operationId": "WriteLeasesRevoke2",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteLeasesRevoke2Request"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/leases/tidy": {
      "description": "This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.",
      "post": {
        "summary": "This endpoint performs cleanup tasks that can be run if certain error\nconditions have occurred.",
        "operationId": "WriteLeasesTidy",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/lockedusers/{mount_accessor}/unlock/{alias_identifier}": {
      "description": "Unlock the locked user with given mount_accessor and alias_identifier.",
      "parameters": [
        {
          "name": "alias_identifier",
          "description": "It is the name of the alias (user). For example, if the alias belongs to userpass backend, the name should be a valid username within userpass auth method. If the alias belongs to an approle auth method, the name should be a valid RoleID",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "mount_accessor",
          "description": "MountAccessor is the identifier of the mount entry to which the user belongs",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Unlocks the user with given mount_accessor and alias_identifier",
        "operationId": "SysWriteLockedusersMountAccessorUnlockAliasIdentifier",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/loggers": {
      "get": {
        "summary": "Read the log level for all existing loggers.",
        "operationId": "ReadLoggers",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Modify the log level for all existing loggers.",
        "operationId": "WriteLoggers",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteLoggersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Revert the all loggers to use log level provided in config.",
        "operationId": "DeleteLoggers",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/loggers/{name}": {
      "parameters": [
        {
          "name": "name",
          "description": "The name of the logger to be modified.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read the log level for a single logger.",
        "operationId": "ReadLogger",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Modify the log level of a single logger.",
        "operationId": "WriteLogger",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteLoggerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Revert a single logger to use log level provided in config.",
        "operationId": "DeleteLogger",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/metrics": {
      "description": "Export the metrics aggregated for telemetry purpose.",
      "parameters": [
        {
          "name": "format",
          "description": "Format to export metrics into. Currently accepts only \"prometheus\".",
          "in": "query",
          "schema": {
            "type": "string"
          }
        }
      ],
      "get": {
        "summary": "Export the metrics aggregated for telemetry purpose.",
        "operationId": "ReadMetrics",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/mfa/validate": {
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Validates the login for the given MFA methods. Upon successful validation, it returns an auth response containing the client token",
        "operationId": "MFAValidate",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MFAValidateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/monitor": {
      "parameters": [
        {
          "name": "log_format",
          "description": "Output format of logs. Supported values are \"standard\" and \"json\". The default is \"standard\".",
          "in": "query",
          "schema": {
            "type": "string",
            "default": "standard"
          }
        },
        {
          "name": "log_level",
          "description": "Log level to view system logs at. Currently supported values are \"trace\", \"debug\", \"info\", \"warn\", \"error\".",
          "in": "query",
          "schema": {
            "type": "string"
          }
        }
      ],
      "get": {
        "operationId": "Monitor",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/mounts": {
      "description": "List the currently mounted backends.",
      "get": {
        "summary": "List the currently mounted backends.",
        "operationId": "ReadMounts",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/mounts/{path}": {
      "description": "Mount a new backend at a new path.",
      "parameters": [
        {
          "name": "path",
          "description": "The path to mount to. Example: \"aws/east\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read the configuration of the secret engine at the given path.",
        "operationId": "ReadMount",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Enable a new secrets engine at the given path.",
        "operationId": "WriteMount",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteMountRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Disable the mount point specified at the given path.",
        "operationId": "DeleteMount",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/mounts/{path}/tune": {
      "description": "Tune backend configuration parameters for this mount.",
      "parameters": [
        {
          "name": "path",
          "description": "The path to mount to. Example: \"aws/east\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Tune backend configuration parameters for this mount.",
        "operationId": "ReadMountsConfig",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Tune backend configuration parameters for this mount.",
        "operationId": "WriteMountsConfig",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteMountsConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/plugins/catalog": {
      "description": "Lists all the plugins known to Vault",
      "get": {
        "summary": "Lists all the plugins known to Vault",
        "operationId": "ReadPluginsCatalog",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/plugins/catalog/{name}": {
      "description": "Configures the plugins known to Vault",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the plugin",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Return the configuration data for the plugin with the given name.",
        "operationId": "SysReadPluginsCatalogName",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Register a new plugin, or updates an existing one with the supplied name.",
        "operationId": "SysWritePluginsCatalogName",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SysWritePluginsCatalogNameRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove the plugin with the given name.",
        "operationId": "SysDeletePluginsCatalogName",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/plugins/catalog/{type}": {
      "description": "Configures the plugins known to Vault",
      "parameters": [
        {
          "name": "type",
          "description": "The type of the plugin, may be auth, secret, or database",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "List the plugins in the catalog.",
        "operationId": "ListPluginsCatalogByType",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/plugins/catalog/{type}/{name}": {
      "description": "Configures the plugins known to Vault",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the plugin",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "type",
          "description": "The type of the plugin, may be auth, secret, or database",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Return the configuration data for the plugin with the given name.",
        "operationId": "ReadPluginsCatalogByTypeByName",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Register a new plugin, or updates an existing one with the supplied name.",
        "operationId": "WritePluginsCatalogByTypeByName",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WritePluginsCatalogByTypeByNameRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove the plugin with the given name.",
        "operationId": "DeletePluginsCatalogByTypeByName",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/plugins/reload/backend": {
      "description": "Reload mounts that use a particular backend plugin.",
      "post": {
        "summary": "Reload mounted plugin backends.",
        "description": "Either the plugin name (`plugin`) or the desired plugin backend mounts (`mounts`) must be provided, but not both. In the case that the plugin name is provided, all mounted paths that use that plugin backend will be reloaded.  If (`scope`) is provided and is (`global`), the plugin(s) are reloaded globally.",
        "operationId": "WritePluginsReloadBackend",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WritePluginsReloadBackendRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/policies/acl": {
      "description": "List the configured access control policies.",
      "get": {
        "summary": "List the configured access control policies.",
        "operationId": "ListPoliciesACL",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/policies/acl/{name}": {
      "description": "Read, Modify, or Delete an access control policy.",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the policy. Example: \"ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve information about the named ACL policy.",
        "operationId": "ReadPoliciesACL",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Add a new or update an existing ACL policy.",
        "operationId": "WritePoliciesACL",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WritePoliciesACLRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the ACL policy with the given name.",
        "operationId": "DeletePoliciesACL",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/policies/password": {
      "get": {
        "summary": "List the existing password policies.",
        "operationId": "ListPoliciesPassword",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/policies/password/{name}": {
      "description": "Read, Modify, or Delete a password policy.",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the password policy.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve an existing password policy.",
        "operationId": "ReadPoliciesPassword",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Add a new or update an existing password policy.",
        "operationId": "WritePoliciesPassword",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WritePoliciesPasswordRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete a password policy.",
        "operationId": "DeletePoliciesPassword",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/policies/password/{name}/generate": {
      "description": "Generate a password from an existing password policy.",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the password policy.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Generate a password from an existing password policy.",
        "operationId": "ReadPoliciesPasswordGenerate",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/policy": {
      "description": "List the configured access control policies.",
      "get": {
        "summary": "List the configured access control policies.",
        "operationId": "ReadPolicies",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/policy/{name}": {
      "description": "Read, Modify, or Delete an access control policy.",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the policy. Example: \"ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the policy body for the named policy.",
        "operationId": "ReadPolicy",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Add a new or update an existing policy.",
        "operationId": "WritePolicy",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WritePolicyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the policy with the given name.",
        "operationId": "DeletePolicy",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/pprof/": {
      "get": {
        "summary": "Returns an HTML page listing the available profiles.",
        "description": "Returns an HTML page listing the available \nprofiles. This should be mainly accessed via browsers or applications that can \nrender pages.",
        "operationId": "PprofRead",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/allocs": {
      "get": {
        "summary": "Returns a sampling of all past memory allocations.",
        "description": "Returns a sampling of all past memory allocations.",
        "operationId": "PprofReadAllocs",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/block": {
      "get": {
        "summary": "Returns stack traces that led to blocking on synchronization primitives",
        "description": "Returns stack traces that led to blocking on synchronization primitives",
        "operationId": "PprofReadBlock",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/cmdline": {
      "get": {
        "summary": "Returns the running program's command line.",
        "description": "Returns the running program's command line, with arguments separated by NUL bytes.",
        "operationId": "PprofReadCmdline",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/goroutine": {
      "get": {
        "summary": "Returns stack traces of all current goroutines.",
        "description": "Returns stack traces of all current goroutines.",
        "operationId": "PprofReadGoroutine",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/heap": {
      "get": {
        "summary": "Returns a sampling of memory allocations of live object.",
        "description": "Returns a sampling of memory allocations of live object.",
        "operationId": "PprofReadHeap",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/mutex": {
      "get": {
        "summary": "Returns stack traces of holders of contended mutexes",
        "description": "Returns stack traces of holders of contended mutexes",
        "operationId": "PprofReadMutex",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/profile": {
      "get": {
        "summary": "Returns a pprof-formatted cpu profile payload.",
        "description": "Returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.",
        "operationId": "PprofReadProfile",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/symbol": {
      "get": {
        "summary": "Returns the program counters listed in the request.",
        "description": "Returns the program counters listed in the request.",
        "operationId": "PprofReadSymbol",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/threadcreate": {
      "get": {
        "summary": "Returns stack traces that led to the creation of new OS threads",
        "description": "Returns stack traces that led to the creation of new OS threads",
        "operationId": "PprofReadThreadcreate",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/pprof/trace": {
      "get": {
        "summary": "Returns the execution trace in binary form.",
        "description": "Returns  the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.",
        "operationId": "PprofReadTrace",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/quotas/config": {
      "description": "Create, update and read the quota configuration.",
      "get": {
        "operationId": "ReadQuotasConfig",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "WriteQuotasConfig",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteQuotasConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/quotas/rate-limit": {
      "description": "Lists the names of all the rate limit quotas.",
      "get": {
        "operationId": "ListQuotasRateLimits",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/quotas/rate-limit/{name}": {
      "description": "Get, create or update rate limit resource quota for an optional namespace or mount.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the quota rule.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "ReadQuotasRateLimit",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "WriteQuotasRateLimit",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteQuotasRateLimitRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "DeleteQuotasRateLimit",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/raw": {
      "description": "Write, Read, and Delete data directly in the Storage backend.",
      "x-vault-sudo": true,
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read the value of the key at the given path.",
        "operationId": "ReadRaw",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the value of the key at the given path.",
        "operationId": "WriteRaw",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteRawRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the key with given path.",
        "operationId": "DeleteRaw",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/raw/{path}": {
      "description": "Write, Read, and Delete data directly in the Storage backend.",
      "parameters": [
        {
          "name": "path",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read the value of the key at the given path.",
        "operationId": "ReadRawPath",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the value of the key at the given path.",
        "operationId": "WriteRawPath",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteRawPathRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the key with given path.",
        "operationId": "DeleteRawPath",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/rekey/backup": {
      "description": "Allows fetching or deleting the backup of the rotated unseal keys.",
      "get": {
        "summary": "Return the backup copy of PGP-encrypted unseal keys.",
        "operationId": "ReadRekeyBackup",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the backup copy of PGP-encrypted unseal keys.",
        "operationId": "DeleteRekeyBackup",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/rekey/init": {
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Reads the configuration and progress of the current rekey attempt.",
        "operationId": "ReadRekeyInit",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Initializes a new rekey attempt.",
        "description": "Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.",
        "operationId": "WriteRekeyInit",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteRekeyInitRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Cancels any in-progress rekey.",
        "description": "This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.",
        "operationId": "DeleteRekeyInit",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/rekey/recovery-key-backup": {
      "description": "Allows fetching or deleting the backup of the rotated unseal keys.",
      "get": {
        "summary": "Allows fetching or deleting the backup of the rotated unseal keys.",
        "operationId": "ReadRekeyRecoveryKeyBackup",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Allows fetching or deleting the backup of the rotated unseal keys.",
        "operationId": "DeleteRekeyRecoveryKeyBackup",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/rekey/update": {
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Enter a single unseal key share to progress the rekey of the Vault.",
        "operationId": "WriteRekeyUpdate",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteRekeyUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/rekey/verify": {
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Read the configuration and progress of the current rekey verification attempt.",
        "operationId": "ReadRekeyVerify",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Enter a single new key share to progress the rekey verification operation.",
        "operationId": "WriteRekeyVerify",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteRekeyVerifyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Cancel any in-progress rekey verification operation.",
        "description": "This clears any progress made and resets the nonce. Unlike a `DELETE` against `sys/rekey/init`, this only resets the current verification operation, not the entire rekey atttempt.",
        "operationId": "DeleteRekeyVerify",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/remount": {
      "description": "Move the mount point of an already-mounted backend, within or across namespaces",
      "x-vault-sudo": true,
      "post": {
        "summary": "Initiate a mount migration",
        "operationId": "Remount",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RemountRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/remount/status/{migration_id}": {
      "description": "Check the status of a mount move operation",
      "parameters": [
        {
          "name": "migration_id",
          "description": "The ID of the migration operation",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Check status of a mount migration",
        "operationId": "ReadRemountStatus",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/renew": {
      "description": "Renew a lease on a secret",
      "post": {
        "summary": "Renews a lease, requesting to extend the lease.",
        "operationId": "Renew",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RenewRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/renew/{url_lease_id}": {
      "description": "Renew a lease on a secret",
      "parameters": [
        {
          "name": "url_lease_id",
          "description": "The lease identifier to renew. This is included with a lease.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Renews a lease, requesting to extend the lease.",
        "operationId": "RenewFor",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RenewForRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/replication/status": {
      "x-vault-unauthenticated": true,
      "get": {
        "operationId": "ReadReplicationStatus",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/revoke": {
      "description": "Revoke a leased secret immediately",
      "post": {
        "summary": "Revokes a lease immediately.",
        "operationId": "Revoke",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RevokeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/revoke-force/{prefix}": {
      "description": "Revoke all secrets generated in a given prefix, ignoring errors.",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to revoke keys under. Example: \"prod/aws/ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Revokes all secrets or tokens generated under a given prefix immediately",
        "description": "Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.\n\nBy ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.",
        "operationId": "RevokeForce",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/revoke-prefix/{prefix}": {
      "description": "Revoke all secrets generated in a given prefix",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to revoke keys under. Example: \"prod/aws/ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Revokes all secrets (via a lease ID prefix) or tokens (via the tokens' path property) generated under a given prefix immediately.",
        "operationId": "RevokePrefix",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RevokePrefixRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/revoke/{url_lease_id}": {
      "description": "Revoke a leased secret immediately",
      "parameters": [
        {
          "name": "url_lease_id",
          "description": "The lease identifier to renew. This is included with a lease.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Revokes a lease immediately.",
        "operationId": "RevokeLease",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RevokeLeaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/rotate": {
      "description": "Rotates the backend encryption key used to persist data.",
      "x-vault-sudo": true,
      "post": {
        "summary": "Rotates the backend encryption key used to persist data.",
        "operationId": "Rotate",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/rotate/config": {
      "description": "Configures settings related to the backend encryption key management.",
      "get": {
        "operationId": "ReadRotateConfig",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "WriteRotateConfig",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WriteRotateConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/seal": {
      "description": "Seals the Vault.",
      "post": {
        "summary": "Seal the Vault.",
        "operationId": "Seal",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/seal-status": {
      "description": "Returns the seal status of the Vault.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Check the seal status of a Vault.",
        "operationId": "ReadSealStatus",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/step-down": {
      "post": {
        "summary": "Cause the node to give up active status.",
        "description": "This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again.",
        "operationId": "StepDownLeader",
        "tags": [
          "system"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/sys/tools/hash": {
      "description": "Generate a hash sum for input data",
      "post": {
        "summary": "Generate a hash sum for input data",
        "operationId": "ToolsHash",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ToolsHashRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/tools/hash/{urlalgorithm}": {
      "description": "Generate a hash sum for input data",
      "parameters": [
        {
          "name": "urlalgorithm",
          "description": "Algorithm to use (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate a hash sum for input data",
        "operationId": "ToolsHashWith",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ToolsHashWithRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/tools/random": {
      "description": "Generate random bytes",
      "post": {
        "summary": "Generate random bytes",
        "operationId": "ToolsGenerateRandom",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ToolsGenerateRandomRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/tools/random/{source}": {
      "description": "Generate random bytes",
      "parameters": [
        {
          "name": "source",
          "description": "Which system to source random data from, ether \"platform\", \"seal\", or \"all\".",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "platform"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate random bytes",
        "operationId": "ToolsGenerateRandomSource",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ToolsGenerateRandomSourceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/tools/random/{source}/{urlbytes}": {
      "description": "Generate random bytes",
      "parameters": [
        {
          "name": "source",
          "description": "Which system to source random data from, ether \"platform\", \"seal\", or \"all\".",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "platform"
          },
          "required": true
        },
        {
          "name": "urlbytes",
          "description": "The number of bytes to generate (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate random bytes",
        "operationId": "ToolsGenerateRandomSourceBytes",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ToolsGenerateRandomSourceBytesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/tools/random/{urlbytes}": {
      "description": "Generate random bytes",
      "parameters": [
        {
          "name": "urlbytes",
          "description": "The number of bytes to generate (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate random bytes",
        "operationId": "SysWriteToolsRandomUrlbytes",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SysWriteToolsRandomUrlbytesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/unseal": {
      "description": "Unseals the Vault.",
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Unseal the Vault.",
        "operationId": "Unseal",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnsealRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/version-history/": {
      "description": "List historical version changes sorted by installation time in ascending order.",
      "get": {
        "summary": "Returns map of historical version change entries",
        "operationId": "ListVersionHistory",
        "tags": [
          "system"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/wrapping/lookup": {
      "description": "Looks up the properties of a response-wrapped token.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Look up wrapping properties for the requester's token.",
        "operationId": "WrappingReadLookup",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Look up wrapping properties for the given token.",
        "operationId": "WrappingWriteLookup",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WrappingWriteLookupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/wrapping/rewrap": {
      "description": "Rotates a response-wrapped token.",
      "post": {
        "summary": "Rotates a response-wrapped token.",
        "operationId": "WrappingRewrap",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WrappingRewrapRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/wrapping/unwrap": {
      "description": "Unwraps a response-wrapped token.",
      "post": {
        "summary": "Unwraps a response-wrapped token.",
        "operationId": "WrappingUnwrap",
        "tags": [
          "system"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WrappingUnwrapRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/sys/wrapping/wrap": {
      "description": "Response-wraps an arbitrary JSON object.",
      "post": {
        "summary": "Response-wraps an arbitrary JSON object.",
        "operationId": "WrappingWrap",
        "tags": [
          "system"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ad_mount_path}/config": {
      "description": "Configure the AD server to connect to, along with password options.",
      "parameters": [
        {
          "name": "ad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ad"
          }
        }
      ],
      "get": {
        "summary": "Configure the AD server to connect to, along with password options.",
        "operationId": "ActiveDirectoryReadConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the AD server to connect to, along with password options.",
        "operationId": "ActiveDirectoryWriteConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ActiveDirectoryWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Configure the AD server to connect to, along with password options.",
        "operationId": "ActiveDirectoryDeleteConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{ad_mount_path}/creds/{name}": {
      "description": "Retrieve a role's creds by role name.",
      "parameters": [
        {
          "name": "ad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ad"
          }
        },
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "ActiveDirectoryReadCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ad_mount_path}/library": {
      "description": "List the name of each set of service accounts currently stored.",
      "parameters": [
        {
          "name": "ad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ad"
          }
        }
      ],
      "get": {
        "operationId": "ActiveDirectoryListLibraries",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ad_mount_path}/library/manage/{name}/check-in": {
      "description": "Force checking service accounts in to the library.",
      "parameters": [
        {
          "name": "ad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ad"
          }
        },
        {
          "name": "name",
          "description": "Name of the set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Check service accounts in to the library.",
        "operationId": "ActiveDirectoryCheckInManageLibrary",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ActiveDirectoryCheckInManageLibraryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ad_mount_path}/library/{name}": {
      "description": "Build a library of service accounts that can be checked out.",
      "parameters": [
        {
          "name": "ad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ad"
          }
        },
        {
          "name": "name",
          "description": "Name of the set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read a library set.",
        "operationId": "ActiveDirectoryReadLibrary",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update a library set.",
        "operationId": "ActiveDirectoryWriteLibrary",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ActiveDirectoryWriteLibraryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete a library set.",
        "operationId": "ActiveDirectoryDeleteLibrary",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{ad_mount_path}/library/{name}/check-in": {
      "description": "Check service accounts in to the library.",
      "parameters": [
        {
          "name": "ad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ad"
          }
        },
        {
          "name": "name",
          "description": "Name of the set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Check service accounts in to the library.",
        "operationId": "ActiveDirectoryCheckInLibrary",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ActiveDirectoryCheckInLibraryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ad_mount_path}/library/{name}/check-out": {
      "description": "Check a service account out from the library.",
      "parameters": [
        {
          "name": "ad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ad"
          }
        },
        {
          "name": "name",
          "description": "Name of the set",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Check a service account out from the library.",
        "operationId": "ActiveDirectoryCheckOutLibrary",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ActiveDirectoryCheckOutLibraryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ad_mount_path}/library/{name}/status": {
      "description": "Check the status of the service accounts in a library.",
      "parameters": [
        {
          "name": "ad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ad"
          }
        },
        {
          "name": "name",
          "description": "Name of the set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Check the status of the service accounts in a library set.",
        "operationId": "ActiveDirectoryReadLibraryStatus",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ad_mount_path}/roles": {
      "description": "List the name of each role currently stored.",
      "parameters": [
        {
          "name": "ad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ad"
          }
        }
      ],
      "get": {
        "summary": "List the name of each role currently stored.",
        "operationId": "ActiveDirectoryListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ad_mount_path}/roles/{name}": {
      "description": "Manage roles to build links between Vault and Active Directory service accounts.",
      "parameters": [
        {
          "name": "ad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ad"
          }
        },
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Manage roles to build links between Vault and Active Directory service accounts.",
        "operationId": "ActiveDirectoryReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage roles to build links between Vault and Active Directory service accounts.",
        "operationId": "ActiveDirectoryWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ActiveDirectoryWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage roles to build links between Vault and Active Directory service accounts.",
        "operationId": "ActiveDirectoryDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{ad_mount_path}/rotate-role/{name}": {
      "description": "Request to rotate the role's credentials.",
      "parameters": [
        {
          "name": "ad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ad"
          }
        },
        {
          "name": "name",
          "description": "Name of the static role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "operationId": "ActiveDirectoryRotateRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ad_mount_path}/rotate-root": {
      "description": "Request to rotate the role's credentials.",
      "parameters": [
        {
          "name": "ad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ad"
          }
        }
      ],
      "post": {
        "operationId": "ActiveDirectoryRotateRoot",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{alicloud_mount_path}/config": {
      "description": "Configure the access key and secret to use for RAM and STS calls.",
      "parameters": [
        {
          "name": "alicloud_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "alicloud"
          }
        }
      ],
      "get": {
        "summary": "Configure the access key and secret to use for RAM and STS calls.",
        "operationId": "AliCloudReadConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the access key and secret to use for RAM and STS calls.",
        "operationId": "AliCloudWriteConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AliCloudWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Configure the access key and secret to use for RAM and STS calls.",
        "operationId": "AliCloudDeleteConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{alicloud_mount_path}/creds/{name}": {
      "description": "Generate an API key or STS credential using the given role's configuration.'",
      "parameters": [
        {
          "name": "alicloud_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "alicloud"
          }
        },
        {
          "name": "name",
          "description": "The name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Generate an API key or STS credential using the given role's configuration.'",
        "operationId": "AliCloudReadCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{alicloud_mount_path}/role": {
      "description": "List the existing roles in this backend.",
      "parameters": [
        {
          "name": "alicloud_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "alicloud"
          }
        }
      ],
      "get": {
        "summary": "List the existing roles in this backend.",
        "operationId": "AliCloudListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{alicloud_mount_path}/role/{name}": {
      "description": "Read, write and reference policies and roles that API keys or STS credentials can be made for.",
      "parameters": [
        {
          "name": "alicloud_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "alicloud"
          }
        },
        {
          "name": "name",
          "description": "The name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read, write and reference policies and roles that API keys or STS credentials can be made for.",
        "operationId": "AliCloudReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Read, write and reference policies and roles that API keys or STS credentials can be made for.",
        "operationId": "AliCloudWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AliCloudWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Read, write and reference policies and roles that API keys or STS credentials can be made for.",
        "operationId": "AliCloudDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{aws_mount_path}/config/lease": {
      "description": "Configure the default lease information for generated credentials.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "get": {
        "summary": "Configure the default lease information for generated credentials.",
        "operationId": "AWSConfigReadLease",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the default lease information for generated credentials.",
        "operationId": "AWSConfigWriteLease",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSConfigWriteLeaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{aws_mount_path}/config/root": {
      "description": "Configure the root credentials that are used to manage IAM.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "get": {
        "summary": "Configure the root credentials that are used to manage IAM.",
        "operationId": "AWSConfigReadRootIAMCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the root credentials that are used to manage IAM.",
        "operationId": "AWSConfigWriteRootIAMCredentials",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSConfigWriteRootIAMCredentialsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{aws_mount_path}/config/rotate-root": {
      "description": "Request to rotate the AWS credentials used by Vault",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "post": {
        "operationId": "AWSConfigRotateRootIAMCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{aws_mount_path}/creds": {
      "description": "Generate AWS credentials from a specific Vault role.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "get": {
        "summary": "Generate AWS credentials from a specific Vault role.",
        "operationId": "AWSReadCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Generate AWS credentials from a specific Vault role.",
        "operationId": "AWSWriteCredentials",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSWriteCredentialsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{aws_mount_path}/roles": {
      "description": "List the existing roles in this backend",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        }
      ],
      "get": {
        "summary": "List the existing roles in this backend",
        "operationId": "AWSListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{aws_mount_path}/roles/{name}": {
      "description": "Read, write and reference IAM policies that access keys can be made for.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        },
        {
          "name": "name",
          "description": "Name of the policy",
          "in": "path",
          "schema": {
            "type": "string",
            "x-vault-displayAttrs": {
              "name": "Policy Name"
            }
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read, write and reference IAM policies that access keys can be made for.",
        "operationId": "AWSReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Read, write and reference IAM policies that access keys can be made for.",
        "operationId": "AWSWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Read, write and reference IAM policies that access keys can be made for.",
        "operationId": "AWSDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{aws_mount_path}/sts/{name}": {
      "description": "Generate AWS credentials from a specific Vault role.",
      "parameters": [
        {
          "name": "aws_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "aws"
          }
        },
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Generate AWS credentials from a specific Vault role.",
        "operationId": "AWSReadSecurityTokenService",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Generate AWS credentials from a specific Vault role.",
        "operationId": "AWSWriteSecurityTokenService",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AWSWriteSecurityTokenServiceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{azure_mount_path}/config": {
      "description": "Configure the Azure Secret backend.",
      "parameters": [
        {
          "name": "azure_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "azure"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "AzureReadConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "AzureWriteConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AzureWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "AzureDeleteConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{azure_mount_path}/creds/{role}": {
      "description": "Request Service Principal credentials for a given Vault role.",
      "parameters": [
        {
          "name": "azure_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "azure"
          }
        },
        {
          "name": "role",
          "description": "Name of the Vault role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "AzureReadCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{azure_mount_path}/roles": {
      "description": "List existing roles.",
      "parameters": [
        {
          "name": "azure_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "azure"
          }
        }
      ],
      "get": {
        "summary": "List existing roles.",
        "operationId": "AzureListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{azure_mount_path}/roles/{name}": {
      "description": "Manage the Vault roles used to generate Azure credentials.",
      "parameters": [
        {
          "name": "azure_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "azure"
          }
        },
        {
          "name": "name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Manage the Vault roles used to generate Azure credentials.",
        "operationId": "AzureReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage the Vault roles used to generate Azure credentials.",
        "operationId": "AzureWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AzureWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage the Vault roles used to generate Azure credentials.",
        "operationId": "AzureDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{azure_mount_path}/rotate-root": {
      "description": "Attempt to rotate the root credentials used to communicate with Azure.",
      "parameters": [
        {
          "name": "azure_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "azure"
          }
        }
      ],
      "post": {
        "operationId": "AzureRotateRoot",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{consul_mount_path}/config/access": {
      "parameters": [
        {
          "name": "consul_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "consul"
          }
        }
      ],
      "get": {
        "operationId": "ConsulReadAccessConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "ConsulWriteAccessConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConsulWriteAccessConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{consul_mount_path}/creds/{role}": {
      "parameters": [
        {
          "name": "consul_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "consul"
          }
        },
        {
          "name": "role",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "ConsulReadCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{consul_mount_path}/roles": {
      "parameters": [
        {
          "name": "consul_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "consul"
          }
        }
      ],
      "get": {
        "operationId": "ConsulListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{consul_mount_path}/roles/{name}": {
      "parameters": [
        {
          "name": "consul_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "consul"
          }
        },
        {
          "name": "name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "ConsulReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "ConsulWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConsulWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "ConsulDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{cubbyhole_mount_path}/{path}": {
      "description": "Pass-through secret storage to a token-specific cubbyhole in the storage backend, allowing you to read/write arbitrary data into secret storage.",
      "parameters": [
        {
          "name": "cubbyhole_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "cubbyhole"
          }
        },
        {
          "name": "path",
          "description": "Specifies the path of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Retrieve the secret at the specified location.",
        "operationId": "CubbyholeRead",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Store a secret at the specified location.",
        "operationId": "CubbyholeWrite",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Deletes the secret at the specified location.",
        "operationId": "CubbyholeDelete",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{gcp_mount_path}/config": {
      "description": "Configure the GCP backend.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        }
      ],
      "get": {
        "operationId": "GoogleCloudReadConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "GoogleCloudWriteConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcp_mount_path}/config/rotate-root": {
      "description": "Request to rotate the GCP credentials used by Vault",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        }
      ],
      "post": {
        "operationId": "GoogleCloudRotateRoot",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcp_mount_path}/key/{roleset}": {
      "description": "Generate a service account private key secret.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "roleset",
          "description": "Required. Name of the role set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "GoogleCloudReadKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "GoogleCloudWriteKey",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudWriteKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcp_mount_path}/roleset/{name}": {
      "description": "Read/write sets of IAM roles to be given to generated credentials for specified GCP resources.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "name",
          "description": "Required. Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "GoogleCloudReadRoleset",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "GoogleCloudWriteRoleset",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudWriteRolesetRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "GoogleCloudDeleteRoleset",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{gcp_mount_path}/roleset/{name}/rotate": {
      "description": "Rotates or recreates the service account bound to a roleset.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "GoogleCloudRotateRoleset",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcp_mount_path}/roleset/{name}/rotate-key": {
      "description": "Rotate the service account key used to generate access tokens for a roleset.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "GoogleCloudRotateRolesetKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcp_mount_path}/roleset/{roleset}/key": {
      "description": "Generate a service account private key secret.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "roleset",
          "description": "Required. Name of the role set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "GoogleCloudReadRolesetKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "GoogleCloudWriteRolesetKey",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudWriteRolesetKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcp_mount_path}/roleset/{roleset}/token": {
      "description": "Generate an OAuth2 access token secret.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "roleset",
          "description": "Required. Name of the role set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "GoogleCloudReadRolesetToken",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "GoogleCloudWriteRolesetToken",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcp_mount_path}/rolesets": {
      "description": "List existing rolesets.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        }
      ],
      "get": {
        "operationId": "GoogleCloudListRolesets",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcp_mount_path}/static-account/{name}": {
      "description": "Register and manage a GCP service account to generate credentials under",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "name",
          "description": "Required. Name to refer to this static account in Vault. Cannot be updated.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "GoogleCloudReadStaticAccount",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "GoogleCloudWriteStaticAccount",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudWriteStaticAccountRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "GoogleCloudDeleteStaticAccount",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{gcp_mount_path}/static-account/{name}/key": {
      "description": "Generate a service account private key secret.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "name",
          "description": "Required. Name of the static account.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "GoogleCloudReadStaticAccountKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "GoogleCloudWriteStaticAccountKey",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudWriteStaticAccountKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcp_mount_path}/static-account/{name}/rotate-key": {
      "description": "Rotate the key used to generate access tokens for a static account",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "name",
          "description": "Name of the account.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "GoogleCloudRotateStaticAccountKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcp_mount_path}/static-account/{name}/token": {
      "description": "Generate an OAuth2 access token secret.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "name",
          "description": "Required. Name of the static account.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "GoogleCloudReadStaticAccountToken",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "GoogleCloudWriteStaticAccountToken",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcp_mount_path}/static-accounts": {
      "description": "List created static accounts.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        }
      ],
      "get": {
        "operationId": "GoogleCloudListStaticAccounts",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcp_mount_path}/token/{roleset}": {
      "description": "Generate an OAuth2 access token secret.",
      "parameters": [
        {
          "name": "gcp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcp"
          }
        },
        {
          "name": "roleset",
          "description": "Required. Name of the role set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "GoogleCloudReadToken",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "GoogleCloudWriteToken",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/config": {
      "description": "Configure the GCP KMS secrets engine",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Configure the GCP KMS secrets engine",
        "operationId": "GoogleCloudKMSReadConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the GCP KMS secrets engine",
        "operationId": "GoogleCloudKMSWriteConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudKMSWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Configure the GCP KMS secrets engine",
        "operationId": "GoogleCloudKMSDeleteConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/decrypt/{key}": {
      "description": "Decrypt a ciphertext value using a named key",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        },
        {
          "name": "key",
          "description": "Name of the key in Vault to use for decryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Decrypt a ciphertext value using a named key",
        "operationId": "GoogleCloudKMSDecrypt",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudKMSDecryptRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/encrypt/{key}": {
      "description": "Encrypt a plaintext value using a named key",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        },
        {
          "name": "key",
          "description": "Name of the key in Vault to use for encryption. This key must already exist in Vault and must map back to a Google Cloud KMS key.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Encrypt a plaintext value using a named key",
        "operationId": "GoogleCloudKMSEncrypt",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudKMSEncryptRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/keys": {
      "description": "List named keys",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        }
      ],
      "get": {
        "summary": "List named keys",
        "operationId": "GoogleCloudKMSListKeys",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/keys/config/{key}": {
      "description": "Configure the key in Vault",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        },
        {
          "name": "key",
          "description": "Name of the key in Vault.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Configure the key in Vault",
        "operationId": "GoogleCloudKMSReadKeyConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the key in Vault",
        "operationId": "GoogleCloudKMSWriteKeyConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudKMSWriteKeyConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/keys/deregister/{key}": {
      "description": "Deregister an existing key in Vault",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        },
        {
          "name": "key",
          "description": "Name of the key to deregister in Vault. If the key exists in Google Cloud KMS, it will be left untouched.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Deregister an existing key in Vault",
        "operationId": "GoogleCloudKMSDeregisterKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/keys/register/{key}": {
      "description": "Register an existing crypto key in Google Cloud KMS",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        },
        {
          "name": "key",
          "description": "Name of the key to register in Vault. This will be the named used to refer to the underlying crypto key when encrypting or decrypting data.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Register an existing crypto key in Google Cloud KMS",
        "operationId": "GoogleCloudKMSRegisterKey",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudKMSRegisterKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/keys/rotate/{key}": {
      "description": "Rotate a crypto key to a new primary version",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        },
        {
          "name": "key",
          "description": "Name of the key to rotate. This key must already be registered with Vault and point to a valid Google Cloud KMS crypto key.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Rotate a crypto key to a new primary version",
        "operationId": "GoogleCloudKMSRotateKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/keys/trim/{key}": {
      "description": "Delete old crypto key versions from Google Cloud KMS",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        },
        {
          "name": "key",
          "description": "Name of the key in Vault.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Delete old crypto key versions from Google Cloud KMS",
        "operationId": "GoogleCloudKMSTrimKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/keys/{key}": {
      "description": "Interact with crypto keys in Vault and Google Cloud KMS",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        },
        {
          "name": "key",
          "description": "Name of the key in Vault.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Interact with crypto keys in Vault and Google Cloud KMS",
        "operationId": "GoogleCloudKMSReadKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Interact with crypto keys in Vault and Google Cloud KMS",
        "operationId": "GoogleCloudKMSWriteKey",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudKMSWriteKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Interact with crypto keys in Vault and Google Cloud KMS",
        "operationId": "GoogleCloudKMSDeleteKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/pubkey/{key}": {
      "description": "Retrieve the public key associated with the named key",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        },
        {
          "name": "key",
          "description": "Name of the key for which to get the public key. This key must already exist in Vault and Google Cloud KMS.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the public key associated with the named key",
        "operationId": "GoogleCloudKMSReadPubkey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/reencrypt/{key}": {
      "description": "Re-encrypt existing ciphertext data to a new version",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        },
        {
          "name": "key",
          "description": "Name of the key to use for encryption. This key must already exist in Vault and Google Cloud KMS.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Re-encrypt existing ciphertext data to a new version",
        "operationId": "GoogleCloudKMSReencrypt",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudKMSReencryptRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/sign/{key}": {
      "description": "Signs a message or digest using a named key",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        },
        {
          "name": "key",
          "description": "Name of the key in Vault to use for signing. This key must already exist in Vault and must map back to a Google Cloud KMS key.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Signs a message or digest using a named key",
        "operationId": "GoogleCloudKMSSign",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudKMSSignRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{gcpkms_mount_path}/verify/{key}": {
      "description": "Verify a signature using a named key",
      "parameters": [
        {
          "name": "gcpkms_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "gcpkms"
          }
        },
        {
          "name": "key",
          "description": "Name of the key in Vault to use for verification. This key must already exist in Vault and must map back to a Google Cloud KMS key.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Verify a signature using a named key",
        "operationId": "GoogleCloudKMSVerify",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GoogleCloudKMSVerifyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{kubernetes_mount_path}/config": {
      "description": "Configure the Kubernetes secret engine plugin.",
      "parameters": [
        {
          "name": "kubernetes_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kubernetes"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "KubernetesReadConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "KubernetesWriteConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KubernetesWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "KubernetesDeleteConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{kubernetes_mount_path}/creds/{name}": {
      "description": "Request Kubernetes service account credentials for a given Vault role.",
      "parameters": [
        {
          "name": "kubernetes_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kubernetes"
          }
        },
        {
          "name": "name",
          "description": "Name of the Vault role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "KubernetesWriteCredentials",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KubernetesWriteCredentialsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{kubernetes_mount_path}/roles": {
      "description": "List the existing roles in this secrets engine.",
      "parameters": [
        {
          "name": "kubernetes_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kubernetes"
          }
        }
      ],
      "get": {
        "operationId": "KubernetesListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{kubernetes_mount_path}/roles/{name}": {
      "description": "Manage the roles that can be created with this secrets engine.",
      "parameters": [
        {
          "name": "kubernetes_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kubernetes"
          }
        },
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "KubernetesReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "KubernetesWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KubernetesWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "KubernetesDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{kv_mount_path}/{path}": {
      "description": "Pass-through secret storage to the storage backend, allowing you to read/write arbitrary data into secret storage.",
      "parameters": [
        {
          "name": "kv_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "kv"
          }
        },
        {
          "name": "path",
          "description": "Location of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Pass-through secret storage to the storage backend, allowing you to\nread/write arbitrary data into secret storage.",
        "operationId": "KVv1Read",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Pass-through secret storage to the storage backend, allowing you to\nread/write arbitrary data into secret storage.",
        "operationId": "KVv1Write",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Pass-through secret storage to the storage backend, allowing you to\nread/write arbitrary data into secret storage.",
        "operationId": "KVv1Delete",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{ldap_mount_path}/config": {
      "description": "Configure the LDAP secrets engine plugin.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "LDAPReadConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "LDAPWriteConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LDAPWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "LDAPDeleteConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{ldap_mount_path}/creds/{name}": {
      "description": "Request LDAP credentials for a dynamic role. These credentials are created within the LDAP system when querying this endpoint.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        },
        {
          "name": "name",
          "description": "Name of the dynamic role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "LDAPReadCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ldap_mount_path}/library": {
      "description": "List the name of each set of service accounts currently stored.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        }
      ],
      "get": {
        "operationId": "LDAPListLibraries",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ldap_mount_path}/library/manage/{name}/check-in": {
      "description": "Force checking service accounts in to the library.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        },
        {
          "name": "name",
          "description": "Name of the set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Check service accounts in to the library.",
        "operationId": "LDAPCheckInManageLibrary",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LDAPCheckInManageLibraryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ldap_mount_path}/library/{name}": {
      "description": "Build a library of service accounts that can be checked out.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        },
        {
          "name": "name",
          "description": "Name of the set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read a library set.",
        "operationId": "LDAPReadLibrary",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update a library set.",
        "operationId": "LDAPWriteLibrary",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LDAPWriteLibraryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete a library set.",
        "operationId": "LDAPDeleteLibrary",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{ldap_mount_path}/library/{name}/check-in": {
      "description": "Check service accounts in to the library.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        },
        {
          "name": "name",
          "description": "Name of the set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Check service accounts in to the library.",
        "operationId": "LDAPCheckInLibrary",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LDAPCheckInLibraryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ldap_mount_path}/library/{name}/check-out": {
      "description": "Check a service account out from the library.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        },
        {
          "name": "name",
          "description": "Name of the set",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Check a service account out from the library.",
        "operationId": "LDAPCheckOutLibrary",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LDAPCheckOutLibraryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ldap_mount_path}/library/{name}/status": {
      "description": "Check the status of the service accounts in a library.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        },
        {
          "name": "name",
          "description": "Name of the set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Check the status of the service accounts in a library set.",
        "operationId": "LDAPReadLibraryStatus",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ldap_mount_path}/role": {
      "description": "List all the dynamic roles Vault is currently managing in LDAP.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        }
      ],
      "get": {
        "operationId": "LDAPListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ldap_mount_path}/role/{name}": {
      "description": "Manage the static roles that can be created with this backend.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        },
        {
          "name": "name",
          "description": "Name of the role (lowercase)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "LDAPReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "LDAPWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LDAPWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "LDAPDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{ldap_mount_path}/rotate-role/{name}": {
      "description": "Request to rotate the credentials for a static user account.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        },
        {
          "name": "name",
          "description": "Name of the static role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "operationId": "LDAPRotateRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ldap_mount_path}/rotate-root": {
      "description": "Request to rotate the root credentials Vault uses for the LDAP administrator account.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "operationId": "LDAPRotateRoot",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ldap_mount_path}/static-cred/{name}": {
      "description": "Request LDAP credentials for a certain static role. These credentials are rotated periodically.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        },
        {
          "name": "name",
          "description": "Name of the static role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "operationId": "LDAPReadStaticCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ldap_mount_path}/static-role": {
      "description": "This path lists all the static roles Vault is currently managing within the LDAP system.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        }
      ],
      "get": {
        "operationId": "LDAPListStaticRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ldap_mount_path}/static-role/{name}": {
      "description": "Manage the static roles that can be created with this backend.",
      "parameters": [
        {
          "name": "ldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ldap"
          }
        },
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "LDAPReadStaticRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "LDAPWriteStaticRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LDAPWriteStaticRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "LDAPDeleteStaticRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{mongodbatlas_mount_path}/config": {
      "description": "Configure the credentials that are used to manage Database Users.",
      "parameters": [
        {
          "name": "mongodbatlas_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "mongodbatlas"
          }
        }
      ],
      "get": {
        "summary": "Configure the  credentials that are used to manage Database Users.",
        "operationId": "MongoDBAtlasReadConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the  credentials that are used to manage Database Users.",
        "operationId": "MongoDBAtlasWriteConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MongoDBAtlasWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{mongodbatlas_mount_path}/creds/{name}": {
      "description": "Generate MongoDB Atlas Programmatic API from a specific Vault role.",
      "parameters": [
        {
          "name": "mongodbatlas_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "mongodbatlas"
          }
        },
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Generate MongoDB Atlas Programmatic API from a specific Vault role.",
        "operationId": "MongoDBAtlasReadCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Generate MongoDB Atlas Programmatic API from a specific Vault role.",
        "operationId": "MongoDBAtlasWriteCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{mongodbatlas_mount_path}/roles": {
      "description": "List the existing roles in this backend",
      "parameters": [
        {
          "name": "mongodbatlas_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "mongodbatlas"
          }
        }
      ],
      "get": {
        "summary": "List the existing roles in this backend",
        "operationId": "MongoDBAtlasListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{mongodbatlas_mount_path}/roles/{name}": {
      "description": "Manage the roles used to generate MongoDB Atlas Programmatic API Keys.",
      "parameters": [
        {
          "name": "mongodbatlas_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "mongodbatlas"
          }
        },
        {
          "name": "name",
          "description": "Name of the Roles",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Manage the roles used to generate MongoDB Atlas Programmatic API Keys.",
        "operationId": "MongoDBAtlasReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage the roles used to generate MongoDB Atlas Programmatic API Keys.",
        "operationId": "MongoDBAtlasWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MongoDBAtlasWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage the roles used to generate MongoDB Atlas Programmatic API Keys.",
        "operationId": "MongoDBAtlasDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{nomad_mount_path}/config/access": {
      "parameters": [
        {
          "name": "nomad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "nomad"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "NomadReadAccessConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "NomadWriteAccessConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NomadWriteAccessConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "NomadDeleteAccessConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{nomad_mount_path}/config/lease": {
      "description": "Configure the lease parameters for generated tokens",
      "parameters": [
        {
          "name": "nomad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "nomad"
          }
        }
      ],
      "get": {
        "summary": "Configure the lease parameters for generated tokens",
        "operationId": "NomadReadLeaseConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the lease parameters for generated tokens",
        "operationId": "NomadWriteLeaseConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NomadWriteLeaseConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Configure the lease parameters for generated tokens",
        "operationId": "NomadDeleteLeaseConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{nomad_mount_path}/creds/{name}": {
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "nomad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "nomad"
          }
        }
      ],
      "get": {
        "operationId": "NomadReadCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{nomad_mount_path}/role": {
      "parameters": [
        {
          "name": "nomad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "nomad"
          }
        }
      ],
      "get": {
        "operationId": "NomadListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{nomad_mount_path}/role/{name}": {
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "nomad_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "nomad"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "NomadReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "NomadWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NomadWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "NomadDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{openldap_mount_path}/config": {
      "description": "Configure the LDAP secrets engine plugin.",
      "parameters": [
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "OpenLDAPReadConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "OpenLDAPWriteConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OpenLDAPWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "OpenLDAPDeleteConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{openldap_mount_path}/creds/{name}": {
      "description": "Request LDAP credentials for a dynamic role. These credentials are created within the LDAP system when querying this endpoint.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the dynamic role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "get": {
        "operationId": "OpenLDAPReadCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{openldap_mount_path}/library": {
      "description": "List the name of each set of service accounts currently stored.",
      "parameters": [
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "get": {
        "operationId": "OpenLDAPListLibraries",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{openldap_mount_path}/library/manage/{name}/check-in": {
      "description": "Force checking service accounts in to the library.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "post": {
        "summary": "Check service accounts in to the library.",
        "operationId": "OpenLDAPCheckInManageLibrary",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OpenLDAPCheckInManageLibraryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{openldap_mount_path}/library/{name}": {
      "description": "Build a library of service accounts that can be checked out.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read a library set.",
        "operationId": "OpenLDAPReadLibrary",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update a library set.",
        "operationId": "OpenLDAPWriteLibrary",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OpenLDAPWriteLibraryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete a library set.",
        "operationId": "OpenLDAPDeleteLibrary",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{openldap_mount_path}/library/{name}/check-in": {
      "description": "Check service accounts in to the library.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "post": {
        "summary": "Check service accounts in to the library.",
        "operationId": "OpenLDAPCheckInLibrary",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OpenLDAPCheckInLibraryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{openldap_mount_path}/library/{name}/check-out": {
      "description": "Check a service account out from the library.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the set",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "post": {
        "summary": "Check a service account out from the library.",
        "operationId": "OpenLDAPCheckOutLibrary",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OpenLDAPCheckOutLibraryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{openldap_mount_path}/library/{name}/status": {
      "description": "Check the status of the service accounts in a library.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the set.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "get": {
        "summary": "Check the status of the service accounts in a library set.",
        "operationId": "OpenLDAPReadLibraryStatus",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{openldap_mount_path}/role": {
      "description": "List all the dynamic roles Vault is currently managing in LDAP.",
      "parameters": [
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "get": {
        "operationId": "OpenLDAPListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{openldap_mount_path}/role/{name}": {
      "description": "Manage the static roles that can be created with this backend.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role (lowercase)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "OpenLDAPReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "OpenLDAPWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OpenLDAPWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "OpenLDAPDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{openldap_mount_path}/rotate-role/{name}": {
      "description": "Request to rotate the credentials for a static user account.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the static role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "operationId": "OpenLDAPRotateRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{openldap_mount_path}/rotate-root": {
      "description": "Request to rotate the root credentials Vault uses for the LDAP administrator account.",
      "parameters": [
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "operationId": "OpenLDAPRotateRoot",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{openldap_mount_path}/static-cred/{name}": {
      "description": "Request LDAP credentials for a certain static role. These credentials are rotated periodically.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the static role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "get": {
        "operationId": "OpenLDAPReadStaticCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{openldap_mount_path}/static-role": {
      "description": "This path lists all the static roles Vault is currently managing within the LDAP system.",
      "parameters": [
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "get": {
        "operationId": "OpenLDAPListStaticRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{openldap_mount_path}/static-role/{name}": {
      "description": "Manage the static roles that can be created with this backend.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "openldap_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "openldap"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "OpenLDAPReadStaticRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "OpenLDAPWriteStaticRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OpenLDAPWriteStaticRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "OpenLDAPDeleteStaticRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{pki_mount_path}//delta": {
      "description": "Fetch a CA, CRL, CA Chain, or non-revoked certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PkiReadDelta",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}//delta/pem": {
      "description": "Fetch a CA, CRL, CA Chain, or non-revoked certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PkiReadDeltaPem",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}//der": {
      "description": "Fetch an issuer's Certificate Revocation Log (CRL).",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PkiReadDer",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}//json": {
      "description": "Fetch a single issuer certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PkiReadJson",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "PkiWriteJson",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PkiWriteJsonRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "PkiDeleteJson",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{pki_mount_path}//pem": {
      "description": "Fetch a CA, CRL, CA Chain, or non-revoked certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PkiReadPem",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/bundle": {
      "description": "Import the specified issuing certificates.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIBundleWrite",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIBundleWriteRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/ca": {
      "description": "Fetch a CA, CRL, CA Chain, or non-revoked certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "operationId": "PKIReadCA",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/ca/pem": {
      "description": "Fetch a CA, CRL, CA Chain, or non-revoked certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "operationId": "PKIReadCAPem",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/ca_chain": {
      "description": "Fetch a CA, CRL, CA Chain, or non-revoked certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "operationId": "PKIReadCAChain",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/cert": {
      "description": "Import the specified issuing certificates.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIWriteCerts",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteCertsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/cert/ca_chain": {
      "description": "Fetch a CA, CRL, CA Chain, or non-revoked certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "operationId": "PKIReadCertCAChain",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/cert/{serial}": {
      "description": "Fetch a CA, CRL, CA Chain, or non-revoked certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        },
        {
          "name": "serial",
          "description": "Certificate serial number, in colon- or hyphen-separated octal",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "operationId": "PKIReadCert",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/cert/{serial}/raw": {
      "description": "Fetch a CA, CRL, CA Chain, or non-revoked certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        },
        {
          "name": "serial",
          "description": "Certificate serial number, in colon- or hyphen-separated octal",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "operationId": "PKIReadCertRaw",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/cert/{serial}/raw/pem": {
      "description": "Fetch a CA, CRL, CA Chain, or non-revoked certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        },
        {
          "name": "serial",
          "description": "Certificate serial number, in colon- or hyphen-separated octal",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "operationId": "PKIReadCertRawPem",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/certs": {
      "description": "Fetch a CA, CRL, CA Chain, or non-revoked certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIListCerts",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/certs/revoked": {
      "description": "List all revoked serial numbers within the local cluster",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIListCertsRevoked",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/config/auto-tidy": {
      "description": "Modifies the current configuration for automatic tidy execution.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIReadAutoTidyConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "PKIWriteAutoTidyConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteAutoTidyConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/config/ca": {
      "description": "Set the CA certificate and private key used for generated credentials.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIWriteCAConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteCAConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/config/cluster": {
      "description": "Set cluster-local configuration, including address to this PR cluster.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIReadClusterConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "PKIWriteClusterConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteClusterConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/config/crl": {
      "description": "Configure the CRL expiration.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIReadCRLConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "PKIWriteCRLConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteCRLConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/config/issuers": {
      "description": "Read and set the default issuer certificate for signing.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIReadIssuersConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "PKIWriteIssuersConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteIssuersConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/config/keys": {
      "description": "Read and set the default key used for signing",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIReadKeysConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "PKIWriteKeysConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteKeysConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/config/urls": {
      "description": "Set the URLs for the issuing CA, CRL distribution points, and OCSP servers.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIReadURLConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "PKIWriteURLConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteURLConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/crl": {
      "description": "Fetch a CA, CRL, CA Chain, or non-revoked certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "operationId": "PKIReadCRL",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/crl/rotate": {
      "description": "Force a rebuild of the CRL.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIReadCRLRotate",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/crl/rotate-delta": {
      "description": "Force a rebuild of the delta CRL.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIReadCRLRotateDelta",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/delta-crl": {
      "description": "Fetch a CA, CRL, CA Chain, or non-revoked certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIReadDeltaCRL",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/intermediate/cross-sign": {
      "description": "Generate a new CSR and private key used for signing.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIWriteIntermediateCrossSign",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteIntermediateCrossSignRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/intermediate/generate/{exported}": {
      "description": "Generate a new CSR and private key used for signing.",
      "parameters": [
        {
          "name": "exported",
          "description": "Must be \"internal\", \"exported\" or \"kms\". If set to \"exported\", the generated private key will be returned. This is your *only* chance to retrieve the private key!",
          "in": "path",
          "schema": {
            "type": "string",
            "enum": [
              "internal",
              "external",
              "kms"
            ]
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIWriteIntermediateGenerate",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteIntermediateGenerateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/intermediate/set-signed": {
      "description": "Provide the signed intermediate CA cert.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIWriteIntermediateSetSigned",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteIntermediateSetSignedRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/internal|exported": {
      "description": "Generate a new private key used for signing.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIWriteInternalExported",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteInternalExportedRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/issue/{role}": {
      "description": "Request a certificate using a certain role with the provided details.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        },
        {
          "name": "role",
          "description": "The desired role with configuration for this request",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "PKIWriteIssueRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteIssueRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/issuer/{issuer_ref}/issue/{role}": {
      "description": "Request a certificate using a certain role with the provided details.",
      "parameters": [
        {
          "name": "issuer_ref",
          "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "default"
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        },
        {
          "name": "role",
          "description": "The desired role with configuration for this request",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "PKIIssuerIssueRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIIssuerIssueRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/issuer/{issuer_ref}/resign-crls": {
      "description": "Combine and sign with the provided issuer different CRLs",
      "parameters": [
        {
          "name": "issuer_ref",
          "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "default"
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIIssuerResignCRLs",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIIssuerResignCRLsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/issuer/{issuer_ref}/revoke": {
      "description": "Revoke the specified issuer certificate.",
      "parameters": [
        {
          "name": "issuer_ref",
          "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "default"
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIIssuerRevoke",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/issuer/{issuer_ref}/sign-intermediate": {
      "description": "Issue an intermediate CA certificate based on the provided CSR.",
      "parameters": [
        {
          "name": "issuer_ref",
          "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "default"
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIIssuerSignIntermediate",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIIssuerSignIntermediateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/issuer/{issuer_ref}/sign-revocation-list": {
      "description": "Generate and sign a CRL based on the provided parameters.",
      "parameters": [
        {
          "name": "issuer_ref",
          "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "default"
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIIssuerSignRevocationList",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIIssuerSignRevocationListRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/issuer/{issuer_ref}/sign-self-issued": {
      "description": "Re-issue a self-signed certificate based on the provided certificate.",
      "parameters": [
        {
          "name": "issuer_ref",
          "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "default"
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIIssuerSignSelfIssued",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIIssuerSignSelfIssuedRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/issuer/{issuer_ref}/sign-verbatim": {
      "description": "Issue a certificate directly based on the provided CSR.",
      "parameters": [
        {
          "name": "issuer_ref",
          "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "default"
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIIssuerSignVerbatim",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIIssuerSignVerbatimRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/issuer/{issuer_ref}/sign-verbatim/{role}": {
      "description": "Issue a certificate directly based on the provided CSR.",
      "parameters": [
        {
          "name": "issuer_ref",
          "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "default"
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        },
        {
          "name": "role",
          "description": "The desired role with configuration for this request",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "PKIIssuerSignVerbatimRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIIssuerSignVerbatimRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/issuer/{issuer_ref}/sign/{role}": {
      "description": "Request certificates using a certain role with the provided details.",
      "parameters": [
        {
          "name": "issuer_ref",
          "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "default"
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        },
        {
          "name": "role",
          "description": "The desired role with configuration for this request",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "PKIIssuerSignRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIIssuerSignRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/issuers": {
      "description": "Fetch a list of CA certificates.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIIssuersList",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/issuers/generate/intermediate/{exported}": {
      "description": "Generate a new CSR and private key used for signing.",
      "parameters": [
        {
          "name": "exported",
          "description": "Must be \"internal\", \"exported\" or \"kms\". If set to \"exported\", the generated private key will be returned. This is your *only* chance to retrieve the private key!",
          "in": "path",
          "schema": {
            "type": "string",
            "enum": [
              "internal",
              "external",
              "kms"
            ]
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIIssuersGenerateIntermediate",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIIssuersGenerateIntermediateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/issuers/generate/root/{exported}": {
      "description": "Generate a new CA certificate and private key used for signing.",
      "parameters": [
        {
          "name": "exported",
          "description": "Must be \"internal\", \"exported\" or \"kms\". If set to \"exported\", the generated private key will be returned. This is your *only* chance to retrieve the private key!",
          "in": "path",
          "schema": {
            "type": "string",
            "enum": [
              "internal",
              "external",
              "kms"
            ]
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIIssuersGenerateRoot",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIIssuersGenerateRootRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/key/{key_ref}": {
      "description": "Fetch a single issuer key",
      "parameters": [
        {
          "name": "key_ref",
          "description": "Reference to key; either \"default\" for the configured default key, an identifier of a key, or the name assigned to the key.",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "default"
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIReadKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "PKIWriteKey",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "PKIDeleteKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{pki_mount_path}/keys": {
      "description": "Fetch a list of all issuer keys",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIListKeys",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/keys/import": {
      "description": "Import the specified key.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIImportKeys",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIImportKeysRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/kms": {
      "description": "Generate a new private key used for signing.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIWriteKMS",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteKMSRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/ocsp": {
      "description": "Query a certificate's revocation status through OCSP'",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "operationId": "PKIWriteOCSP",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/ocsp/{req}": {
      "description": "Query a certificate's revocation status through OCSP'",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        },
        {
          "name": "req",
          "description": "base-64 encoded ocsp request",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "operationId": "PKIReadOCSPReq",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/revoke": {
      "description": "Revoke a certificate by serial number or with explicit certificate. When calling /revoke-with-key, the private key corresponding to the certificate must be provided to authenticate the request.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIRevoke",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIRevokeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/revoke-with-key": {
      "description": "Revoke a certificate by serial number or with explicit certificate. When calling /revoke-with-key, the private key corresponding to the certificate must be provided to authenticate the request.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIRevokeWithKey",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIRevokeWithKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/roles": {
      "description": "List the existing roles in this backend",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/roles/{name}": {
      "description": "Manage the roles that can be created with this backend.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKIReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "PKIWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "PKIDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{pki_mount_path}/root": {
      "description": "Deletes the root CA key to allow a new one to be generated.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "x-vault-sudo": true,
      "delete": {
        "operationId": "PKIDeleteRoot",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{pki_mount_path}/root/generate/{exported}": {
      "description": "Generate a new CA certificate and private key used for signing.",
      "parameters": [
        {
          "name": "exported",
          "description": "Must be \"internal\", \"exported\" or \"kms\". If set to \"exported\", the generated private key will be returned. This is your *only* chance to retrieve the private key!",
          "in": "path",
          "schema": {
            "type": "string",
            "enum": [
              "internal",
              "external",
              "kms"
            ]
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIGenerateRoot",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIGenerateRootRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/root/replace": {
      "description": "Read and set the default issuer certificate for signing.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIReplaceRoot",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIReplaceRootRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/root/rotate/{exported}": {
      "description": "Generate a new CA certificate and private key used for signing.",
      "parameters": [
        {
          "name": "exported",
          "description": "Must be \"internal\", \"exported\" or \"kms\". If set to \"exported\", the generated private key will be returned. This is your *only* chance to retrieve the private key!",
          "in": "path",
          "schema": {
            "type": "string",
            "enum": [
              "internal",
              "external",
              "kms"
            ]
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIRotateRoot",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIRotateRootRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/root/sign-intermediate": {
      "description": "Issue an intermediate CA certificate based on the provided CSR.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKIRootSignIntermediate",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIRootSignIntermediateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/root/sign-self-issued": {
      "description": "Re-issue a self-signed certificate based on the provided certificate.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "operationId": "PKIRootSignSelfIssued",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKIRootSignSelfIssuedRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/sign-verbatim": {
      "description": "Issue a certificate directly based on the provided CSR.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKISignVerbatim",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKISignVerbatimRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/sign-verbatim/{role}": {
      "description": "Issue a certificate directly based on the provided CSR.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        },
        {
          "name": "role",
          "description": "The desired role with configuration for this request",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "PKISignVerbatimRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKISignVerbatimRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/sign/{role}": {
      "description": "Request certificates using a certain role with the provided details.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        },
        {
          "name": "role",
          "description": "The desired role with configuration for this request",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "operationId": "PKISignRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKISignRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/tidy": {
      "description": "Tidy up the backend by removing expired certificates, revocation information, or both.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKITidy",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PKITidyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/tidy-cancel": {
      "description": "Cancels a currently running tidy operation.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "post": {
        "operationId": "PKITidyCancel",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/tidy-status": {
      "description": "Returns the status of the tidy operation.",
      "parameters": [
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PKITidyStatus",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/{issuer_ref}/crl/pem|/der|/delta/pem": {
      "description": "Fetch an issuer's Certificate Revocation Log (CRL).",
      "parameters": [
        {
          "name": "issuer_ref",
          "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "default"
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PkiReadIssuerRefCrlPemDerDeltaPem",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{pki_mount_path}/{issuer_ref}/der|/pem": {
      "description": "Fetch a single issuer certificate.",
      "parameters": [
        {
          "name": "issuer_ref",
          "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "default"
          },
          "required": true
        },
        {
          "name": "pki_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "pki"
          }
        }
      ],
      "get": {
        "operationId": "PkiReadIssuerRefDerPem",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "PkiWriteIssuerRefDerPem",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PkiWriteIssuerRefDerPemRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "PkiDeleteIssuerRefDerPem",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{rabbitmq_mount_path}/config/connection": {
      "description": "Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API.",
      "parameters": [
        {
          "name": "rabbitmq_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "rabbitmq"
          }
        }
      ],
      "post": {
        "summary": "Configure the connection URI, username, and password to talk to RabbitMQ management HTTP API.",
        "operationId": "RabbitMQWriteConnectionConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RabbitMQWriteConnectionConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{rabbitmq_mount_path}/config/lease": {
      "description": "Configure the lease parameters for generated credentials",
      "parameters": [
        {
          "name": "rabbitmq_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "rabbitmq"
          }
        }
      ],
      "get": {
        "summary": "Configure the lease parameters for generated credentials",
        "operationId": "RabbitMQReadLeaseConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the lease parameters for generated credentials",
        "operationId": "RabbitMQWriteLeaseConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RabbitMQWriteLeaseConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{rabbitmq_mount_path}/creds/{name}": {
      "description": "Request RabbitMQ credentials for a certain role.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "rabbitmq_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "rabbitmq"
          }
        }
      ],
      "get": {
        "summary": "Request RabbitMQ credentials for a certain role.",
        "operationId": "RabbitMQReadCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{rabbitmq_mount_path}/roles": {
      "description": "Manage the roles that can be created with this backend.",
      "parameters": [
        {
          "name": "rabbitmq_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "rabbitmq"
          }
        }
      ],
      "get": {
        "summary": "Manage the roles that can be created with this backend.",
        "operationId": "RabbitMQListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{rabbitmq_mount_path}/roles/{name}": {
      "description": "Manage the roles that can be created with this backend.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "rabbitmq_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "rabbitmq"
          }
        }
      ],
      "get": {
        "summary": "Manage the roles that can be created with this backend.",
        "operationId": "RabbitMQReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage the roles that can be created with this backend.",
        "operationId": "RabbitMQWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RabbitMQWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage the roles that can be created with this backend.",
        "operationId": "RabbitMQDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{secret_mount_path}/.*": {
      "parameters": [
        {
          "name": "secret_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "secret"
          }
        }
      ]
    },
    "/{secret_mount_path}/config": {
      "description": "Configures settings for the KV store",
      "parameters": [
        {
          "name": "secret_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "secret"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read the backend level settings.",
        "operationId": "KVv2ReadConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure backend level settings that are applied to every key in the key-value store.",
        "operationId": "KVv2WriteConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KVv2WriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{secret_mount_path}/data/{path}": {
      "description": "Write, Patch, Read, and Delete data in the Key-Value Store.",
      "parameters": [
        {
          "name": "path",
          "description": "Location of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "secret_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "secret"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Write, Patch, Read, and Delete data in the Key-Value Store.",
        "operationId": "KVv2Read",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Write, Patch, Read, and Delete data in the Key-Value Store.",
        "operationId": "KVv2Write",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KVv2WriteRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Write, Patch, Read, and Delete data in the Key-Value Store.",
        "operationId": "KVv2Delete",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{secret_mount_path}/delete/{path}": {
      "description": "Marks one or more versions as deleted in the KV store.",
      "parameters": [
        {
          "name": "path",
          "description": "Location of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "secret_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "secret"
          }
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Marks one or more versions as deleted in the KV store.",
        "operationId": "KVv2DeleteVersions",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KVv2DeleteVersionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{secret_mount_path}/destroy/{path}": {
      "description": "Permanently removes one or more versions in the KV store",
      "parameters": [
        {
          "name": "path",
          "description": "Location of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "secret_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "secret"
          }
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Permanently removes one or more versions in the KV store",
        "operationId": "KVv2DestroyVersions",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KVv2DestroyVersionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{secret_mount_path}/metadata/{path}": {
      "description": "Configures settings for the KV store",
      "parameters": [
        {
          "name": "path",
          "description": "Location of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "secret_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "secret"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Configures settings for the KV store",
        "operationId": "KVv2ReadMetadata",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configures settings for the KV store",
        "operationId": "KVv2WriteMetadata",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KVv2WriteMetadataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Configures settings for the KV store",
        "operationId": "KVv2DeleteMetadata",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{secret_mount_path}/subkeys/{path}": {
      "description": "Read the structure of a secret entry from the Key-Value store with the values removed.",
      "parameters": [
        {
          "name": "path",
          "description": "Location of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "secret_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "secret"
          }
        }
      ],
      "get": {
        "summary": "Read the structure of a secret entry from the Key-Value store with the values removed.",
        "operationId": "KVv2ReadSubkeys",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{secret_mount_path}/undelete/{path}": {
      "description": "Undeletes one or more versions from the KV store.",
      "parameters": [
        {
          "name": "path",
          "description": "Location of the secret.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "secret_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "secret"
          }
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Undeletes one or more versions from the KV store.",
        "operationId": "KVv2UndeleteVersions",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/KVv2UndeleteVersionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ssh_mount_path}/config/ca": {
      "description": "Set the SSH private key used for signing certificates.",
      "parameters": [
        {
          "name": "ssh_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ssh"
          }
        }
      ],
      "get": {
        "summary": "Set the SSH private key used for signing certificates.",
        "operationId": "SSHReadCAConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Set the SSH private key used for signing certificates.",
        "operationId": "SSHWriteCAConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SSHWriteCAConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Set the SSH private key used for signing certificates.",
        "operationId": "SSHDeleteCAConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{ssh_mount_path}/config/zeroaddress": {
      "description": "Assign zero address as default CIDR block for select roles.",
      "parameters": [
        {
          "name": "ssh_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ssh"
          }
        }
      ],
      "get": {
        "summary": "Assign zero address as default CIDR block for select roles.",
        "operationId": "SSHReadZeroAddressConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Assign zero address as default CIDR block for select roles.",
        "operationId": "SSHWriteZeroAddressConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SSHWriteZeroAddressConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Assign zero address as default CIDR block for select roles.",
        "operationId": "SSHDeleteZeroAddressConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{ssh_mount_path}/creds/{role}": {
      "description": "Creates a credential for establishing SSH connection with the remote host.",
      "parameters": [
        {
          "name": "role",
          "description": "[Required] Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "ssh_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ssh"
          }
        }
      ],
      "post": {
        "summary": "Creates a credential for establishing SSH connection with the remote host.",
        "operationId": "SSHWriteCredentials",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SSHWriteCredentialsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ssh_mount_path}/issue/{role}": {
      "description": "Request a certificate using a certain role with the provided details.",
      "parameters": [
        {
          "name": "role",
          "description": "The desired role with configuration for this request.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "ssh_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ssh"
          }
        }
      ],
      "post": {
        "operationId": "SSHWriteIssue",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SSHWriteIssueRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ssh_mount_path}/keys/{key_name}": {
      "description": "Register a shared private key with Vault.",
      "parameters": [
        {
          "name": "key_name",
          "description": "[Required] Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "ssh_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ssh"
          }
        }
      ],
      "post": {
        "summary": "Register a shared private key with Vault.",
        "operationId": "SSHWriteKeys",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SSHWriteKeysRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Register a shared private key with Vault.",
        "operationId": "SSHDeleteKeys",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{ssh_mount_path}/lookup": {
      "description": "List all the roles associated with the given IP address.",
      "parameters": [
        {
          "name": "ssh_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ssh"
          }
        }
      ],
      "post": {
        "summary": "List all the roles associated with the given IP address.",
        "operationId": "SSHLookup",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SSHLookupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ssh_mount_path}/public_key": {
      "description": "Retrieve the public key.",
      "parameters": [
        {
          "name": "ssh_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ssh"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Retrieve the public key.",
        "operationId": "SSHReadPublicKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ssh_mount_path}/roles": {
      "description": "Manage the 'roles' that can be created with this backend.",
      "parameters": [
        {
          "name": "ssh_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ssh"
          }
        }
      ],
      "get": {
        "summary": "Manage the 'roles' that can be created with this backend.",
        "operationId": "SSHListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ssh_mount_path}/roles/{role}": {
      "description": "Manage the 'roles' that can be created with this backend.",
      "parameters": [
        {
          "name": "role",
          "description": "[Required for all types] Name of the role being created.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "ssh_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ssh"
          }
        }
      ],
      "get": {
        "summary": "Manage the 'roles' that can be created with this backend.",
        "operationId": "SSHReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage the 'roles' that can be created with this backend.",
        "operationId": "SSHWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SSHWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage the 'roles' that can be created with this backend.",
        "operationId": "SSHDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{ssh_mount_path}/sign/{role}": {
      "description": "Request signing an SSH key using a certain role with the provided details.",
      "parameters": [
        {
          "name": "role",
          "description": "The desired role with configuration for this request.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "ssh_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ssh"
          }
        }
      ],
      "post": {
        "summary": "Request signing an SSH key using a certain role with the provided details.",
        "operationId": "SSHSign",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SSHSignRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{ssh_mount_path}/verify": {
      "description": "Validate the OTP provided by Vault SSH Agent.",
      "parameters": [
        {
          "name": "ssh_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "ssh"
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Validate the OTP provided by Vault SSH Agent.",
        "operationId": "SSHVerify",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SSHVerifyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{terraform_mount_path}/config": {
      "description": "Configure the Terraform Cloud / Enterprise backend.",
      "parameters": [
        {
          "name": "terraform_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "terraform"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "TerraformReadConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "TerraformWriteConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TerraformWriteConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "TerraformDeleteConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{terraform_mount_path}/creds/{name}": {
      "description": "Generate a Terraform Cloud or Enterprise API token from a specific Vault role.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "terraform_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "terraform"
          }
        }
      ],
      "get": {
        "summary": "Generate a Terraform Cloud or Enterprise API token from a specific Vault role.",
        "operationId": "TerraformReadCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Generate a Terraform Cloud or Enterprise API token from a specific Vault role.",
        "operationId": "TerraformWriteCredentials",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{terraform_mount_path}/role": {
      "description": "List the existing roles in Terraform Cloud / Enterprise backend",
      "parameters": [
        {
          "name": "terraform_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "terraform"
          }
        }
      ],
      "get": {
        "operationId": "TerraformListRoles",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{terraform_mount_path}/role/{name}": {
      "description": "Manages the Vault role for generating Terraform Cloud / Enterprise tokens.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "terraform_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "terraform"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "operationId": "TerraformReadRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "operationId": "TerraformWriteRole",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TerraformWriteRoleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "operationId": "TerraformDeleteRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{terraform_mount_path}/rotate-role/{name}": {
      "description": "Request to rotate the credentials for a team or organization.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the team or organization role",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "terraform_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "terraform"
          }
        }
      ],
      "post": {
        "operationId": "TerraformRotateRole",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{totp_mount_path}/code/{name}": {
      "description": "Request time-based one-time use password or validate a password for a certain key .",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "totp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "totp"
          }
        }
      ],
      "get": {
        "summary": "Request time-based one-time use password or validate a password for a certain key .",
        "operationId": "TOTPReadCode",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Request time-based one-time use password or validate a password for a certain key .",
        "operationId": "TOTPWriteCode",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TOTPWriteCodeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{totp_mount_path}/keys": {
      "description": "Manage the keys that can be created with this backend.",
      "parameters": [
        {
          "name": "totp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "totp"
          }
        }
      ],
      "get": {
        "summary": "Manage the keys that can be created with this backend.",
        "operationId": "TOTPListKeys",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{totp_mount_path}/keys/{name}": {
      "description": "Manage the keys that can be created with this backend.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "totp_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "totp"
          }
        }
      ],
      "get": {
        "summary": "Manage the keys that can be created with this backend.",
        "operationId": "TOTPReadKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Manage the keys that can be created with this backend.",
        "operationId": "TOTPWriteKey",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TOTPWriteKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Manage the keys that can be created with this backend.",
        "operationId": "TOTPDeleteKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{transit_mount_path}/backup/{name}": {
      "description": "Backup the named key",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "get": {
        "summary": "Backup the named key",
        "operationId": "TransitBackup",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/cache-config": {
      "description": "Configure caching strategy",
      "parameters": [
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "x-vault-createSupported": true,
      "get": {
        "summary": "Returns the size of the active cache",
        "operationId": "TransitReadCacheConfig",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configures a new cache of the specified size",
        "operationId": "TransitWriteCacheConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitWriteCacheConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/config/keys": {
      "description": "Configuration common across all keys",
      "parameters": [
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "get": {
        "summary": "Configuration common across all keys",
        "operationId": "TransitReadConfigKeys",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configuration common across all keys",
        "operationId": "TransitWriteConfigKeys",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitWriteConfigKeysRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/datakey/{plaintext}/{name}": {
      "description": "Generate a data key",
      "parameters": [
        {
          "name": "name",
          "description": "The backend key used for encrypting the data key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "plaintext",
          "description": "\"plaintext\" will return the key in both plaintext and ciphertext; \"wrapped\" will return the ciphertext only.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Generate a data key",
        "operationId": "TransitGenerateDataKey",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitGenerateDataKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/decrypt/{name}": {
      "description": "Decrypt a ciphertext value using a named key",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Decrypt a ciphertext value using a named key",
        "operationId": "TransitDecrypt",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitDecryptRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/encrypt/{name}": {
      "description": "Encrypt a plaintext value or a batch of plaintext blocks using a named key",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "x-vault-createSupported": true,
      "post": {
        "summary": "Encrypt a plaintext value or a batch of plaintext\nblocks using a named key",
        "operationId": "TransitEncrypt",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitEncryptRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/export/{type}/{name}": {
      "description": "Export named encryption or signing key",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        },
        {
          "name": "type",
          "description": "Type of key to export (encryption-key, signing-key, hmac-key)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Export named encryption or signing key",
        "operationId": "TransitExport",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/export/{type}/{name}/{version}": {
      "description": "Export named encryption or signing key",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        },
        {
          "name": "type",
          "description": "Type of key to export (encryption-key, signing-key, hmac-key)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "version",
          "description": "Version of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Export named encryption or signing key",
        "operationId": "TransitExportVersion",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/hash": {
      "description": "Generate a hash sum for input data",
      "parameters": [
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Generate a hash sum for input data",
        "operationId": "TransitHash",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitHashRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/hash/{urlalgorithm}": {
      "description": "Generate a hash sum for input data",
      "parameters": [
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        },
        {
          "name": "urlalgorithm",
          "description": "Algorithm to use (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate a hash sum for input data",
        "operationId": "TransitHashWithAlgorithm",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitHashWithAlgorithmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/hmac/{name}": {
      "description": "Generate an HMAC for input data using the named key",
      "parameters": [
        {
          "name": "name",
          "description": "The key to use for the HMAC function",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Generate an HMAC for input data using the named key",
        "operationId": "TransitGenerateHMAC",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitGenerateHMACRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/hmac/{name}/{urlalgorithm}": {
      "description": "Generate an HMAC for input data using the named key",
      "parameters": [
        {
          "name": "name",
          "description": "The key to use for the HMAC function",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        },
        {
          "name": "urlalgorithm",
          "description": "Algorithm to use (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate an HMAC for input data using the named key",
        "operationId": "TransitGenerateHMACWithAlgorithm",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitGenerateHMACWithAlgorithmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/keys": {
      "description": "Managed named encryption keys",
      "parameters": [
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "get": {
        "summary": "Managed named encryption keys",
        "operationId": "TransitListKeys",
        "tags": [
          "secrets"
        ],
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/keys/{name}": {
      "description": "Managed named encryption keys",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "get": {
        "summary": "Managed named encryption keys",
        "operationId": "TransitReadKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Managed named encryption keys",
        "operationId": "TransitWriteKey",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitWriteKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Managed named encryption keys",
        "operationId": "TransitDeleteKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/{transit_mount_path}/keys/{name}/config": {
      "description": "Configure a named encryption key",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Configure a named encryption key",
        "operationId": "TransitWriteKeyConfig",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitWriteKeyConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/keys/{name}/import": {
      "description": "Imports an externally-generated key into a new transit key",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Imports an externally-generated key into a new transit key",
        "operationId": "TransitImportKey",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitImportKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/keys/{name}/import_version": {
      "description": "Imports an externally-generated key into an existing imported key",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Imports an externally-generated key into an existing imported key",
        "operationId": "TransitImportKeyVersion",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitImportKeyVersionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/keys/{name}/rotate": {
      "description": "Rotate named encryption key",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Rotate named encryption key",
        "operationId": "TransitRotateKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/keys/{name}/trim": {
      "description": "Trim key versions of a named key",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Trim key versions of a named key",
        "operationId": "TransitTrimKey",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitTrimKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/random": {
      "description": "Generate random bytes",
      "parameters": [
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Generate random bytes",
        "operationId": "TransitGenerateRandom",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitGenerateRandomRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/random/{source}": {
      "description": "Generate random bytes",
      "parameters": [
        {
          "name": "source",
          "description": "Which system to source random data from, ether \"platform\", \"seal\", or \"all\".",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "platform"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Generate random bytes",
        "operationId": "TransitGenerateRandomSource",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitGenerateRandomSourceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/random/{source}/{urlbytes}": {
      "description": "Generate random bytes",
      "parameters": [
        {
          "name": "source",
          "description": "Which system to source random data from, ether \"platform\", \"seal\", or \"all\".",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "platform"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        },
        {
          "name": "urlbytes",
          "description": "The number of bytes to generate (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate random bytes",
        "operationId": "TransitGenerateRandomSourceBytes",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitGenerateRandomSourceBytesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/random/{urlbytes}": {
      "description": "Generate random bytes",
      "parameters": [
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        },
        {
          "name": "urlbytes",
          "description": "The number of bytes to generate (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate random bytes",
        "operationId": "TransitWriteRandomUrlbytes",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitWriteRandomUrlbytesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/restore": {
      "description": "Restore the named key",
      "parameters": [
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Restore the named key",
        "operationId": "TransitRestore",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitRestoreRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/restore/{name}": {
      "description": "Restore the named key",
      "parameters": [
        {
          "name": "name",
          "description": "If set, this will be the name of the restored key.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Restore the named key",
        "operationId": "TransitRestoreKey",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitRestoreKeyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/rewrap/{name}": {
      "description": "Rewrap ciphertext",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the key",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Rewrap ciphertext",
        "operationId": "TransitRewrap",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitRewrapRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/sign/{name}": {
      "description": "Generate a signature for input data using the named key",
      "parameters": [
        {
          "name": "name",
          "description": "The key to use",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Generate a signature for input data using the named key",
        "operationId": "TransitSign",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitSignRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/sign/{name}/{urlalgorithm}": {
      "description": "Generate a signature for input data using the named key",
      "parameters": [
        {
          "name": "name",
          "description": "The key to use",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        },
        {
          "name": "urlalgorithm",
          "description": "Hash algorithm to use (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate a signature for input data using the named key",
        "operationId": "TransitSignWithAlgorithm",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitSignWithAlgorithmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/verify/{name}": {
      "description": "Verify a signature or HMAC for input data created using the named key",
      "parameters": [
        {
          "name": "name",
          "description": "The key to use",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "post": {
        "summary": "Verify a signature or HMAC for input data created using the named key",
        "operationId": "TransitVerify",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitVerifyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/verify/{name}/{urlalgorithm}": {
      "description": "Verify a signature or HMAC for input data created using the named key",
      "parameters": [
        {
          "name": "name",
          "description": "The key to use",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        },
        {
          "name": "urlalgorithm",
          "description": "Hash algorithm to use (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Verify a signature or HMAC for input data created using the named key",
        "operationId": "TransitVerifyWithAlgorithm",
        "tags": [
          "secrets"
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransitVerifyWithAlgorithmRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/{transit_mount_path}/wrapping_key": {
      "description": "Returns the public key to use for wrapping imported keys",
      "parameters": [
        {
          "name": "transit_mount_path",
          "description": "Path where the backend was mounted; the endpoint path will be offset by the mount path",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "transit"
          }
        }
      ],
      "get": {
        "summary": "Returns the public key to use for wrapping imported keys",
        "operationId": "TransitReadWrappingKey",
        "tags": [
          "secrets"
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AWSConfigWriteCertificateRequest": {
        "type": "object",
        "properties": {
          "aws_public_cert": {
            "type": "string",
            "description": "Base64 encoded AWS Public cert required to verify PKCS7 signature of the EC2 instance metadata."
          },
          "type": {
            "type": "string",
            "description": "Takes the value of either \"pkcs7\" or \"identity\", indicating the type of document which can be verified using the given certificate. The reason is that the PKCS#7 document will have a DSA digest and the identity signature will have an RSA signature, and accordingly the public certificates to verify those also vary. Defaults to \"pkcs7\".",
            "default": "pkcs7"
          }
        }
      },
      "AWSConfigWriteClientRequest": {
        "type": "object",
        "properties": {
          "access_key": {
            "type": "string",
            "description": "AWS Access Key ID for the account used to make AWS API requests.",
            "default": ""
          },
          "allowed_sts_header_values": {
            "type": "array",
            "description": "List of additional headers that are allowed to be in AWS STS request headers",
            "items": {
              "type": "string"
            }
          },
          "endpoint": {
            "type": "string",
            "description": "URL to override the default generated endpoint for making AWS EC2 API calls.",
            "default": ""
          },
          "iam_endpoint": {
            "type": "string",
            "description": "URL to override the default generated endpoint for making AWS IAM API calls.",
            "default": ""
          },
          "iam_server_id_header_value": {
            "type": "string",
            "description": "Value to require in the X-Vault-AWS-IAM-Server-ID request header",
            "default": ""
          },
          "max_retries": {
            "type": "integer",
            "description": "Maximum number of retries for recoverable exceptions of AWS APIs",
            "default": -1
          },
          "secret_key": {
            "type": "string",
            "description": "AWS Secret Access Key for the account used to make AWS API requests.",
            "default": ""
          },
          "sts_endpoint": {
            "type": "string",
            "description": "URL to override the default generated endpoint for making AWS STS API calls.",
            "default": ""
          },
          "sts_region": {
            "type": "string",
            "description": "The region ID for the sts_endpoint, if set.",
            "default": ""
          }
        }
      },
      "AWSConfigWriteIdentityAccessListRequest": {
        "type": "object",
        "properties": {
          "disable_periodic_tidy": {
            "type": "boolean",
            "description": "If set to 'true', disables the periodic tidying of the 'identity-accesslist/<instance_id>' entries.",
            "default": false
          },
          "safety_buffer": {
            "type": "integer",
            "description": "The amount of extra time that must have passed beyond the identity's expiration, before it is removed from the backend storage.",
            "format": "seconds",
            "default": 259200
          }
        }
      },
      "AWSConfigWriteIdentityRequest": {
        "type": "object",
        "properties": {
          "ec2_alias": {
            "type": "string",
            "description": "Configure how the AWS auth method generates entity alias when using EC2 auth. Valid values are \"role_id\", \"instance_id\", and \"image_id\". Defaults to \"role_id\".",
            "default": "instance_id"
          },
          "ec2_metadata": {
            "type": "array",
            "description": "The metadata to include on the aliases and audit logs generated by this plugin. When set to 'default', includes: account_id, auth_type. These fields are available to add: ami_id, instance_id, region. Not editing this field means the 'default' fields are included. Explicitly setting this field to empty overrides the 'default' and means no metadata will be included. If not using 'default', explicit fields must be sent like: 'field1,field2'.",
            "items": {
              "type": "string"
            },
            "default": [
              "default"
            ],
            "x-vault-displayAttrs": {
              "name": "ec2_metadata",
              "value": "field1,field2"
            }
          },
          "iam_alias": {
            "type": "string",
            "description": "Configure how the AWS auth method generates entity aliases when using IAM auth. Valid values are \"role_id\", \"unique_id\", and \"full_arn\". Defaults to \"role_id\".",
            "default": "unique_id"
          },
          "iam_metadata": {
            "type": "array",
            "description": "The metadata to include on the aliases and audit logs generated by this plugin. When set to 'default', includes: account_id, auth_type. These fields are available to add: canonical_arn, client_arn, client_user_id, inferred_aws_region, inferred_entity_id, inferred_entity_type. Not editing this field means the 'default' fields are included. Explicitly setting this field to empty overrides the 'default' and means no metadata will be included. If not using 'default', explicit fields must be sent like: 'field1,field2'.",
            "items": {
              "type": "string"
            },
            "default": [
              "default"
            ],
            "x-vault-displayAttrs": {
              "name": "iam_metadata",
              "value": "field1,field2"
            }
          }
        }
      },
      "AWSConfigWriteIdentityWhiteListRequest": {
        "type": "object",
        "properties": {
          "disable_periodic_tidy": {
            "type": "boolean",
            "description": "If set to 'true', disables the periodic tidying of the 'identity-accesslist/<instance_id>' entries.",
            "default": false
          },
          "safety_buffer": {
            "type": "integer",
            "description": "The amount of extra time that must have passed beyond the identity's expiration, before it is removed from the backend storage.",
            "format": "seconds",
            "default": 259200
          }
        }
      },
      "AWSConfigWriteLeaseRequest": {
        "type": "object",
        "properties": {
          "lease": {
            "type": "string",
            "description": "Default lease for roles."
          },
          "lease_max": {
            "type": "string",
            "description": "Maximum time a credential is valid for."
          }
        }
      },
      "AWSConfigWriteRoleTagBlackListRequest": {
        "type": "object",
        "properties": {
          "disable_periodic_tidy": {
            "type": "boolean",
            "description": "If set to 'true', disables the periodic tidying of deny listed entries.",
            "default": false
          },
          "safety_buffer": {
            "type": "integer",
            "description": "The amount of extra time that must have passed beyond the roletag expiration, before it is removed from the backend storage. Defaults to 4320h (180 days).",
            "format": "seconds",
            "default": 15552000
          }
        }
      },
      "AWSConfigWriteRoleTagDenyListRequest": {
        "type": "object",
        "properties": {
          "disable_periodic_tidy": {
            "type": "boolean",
            "description": "If set to 'true', disables the periodic tidying of deny listed entries.",
            "default": false
          },
          "safety_buffer": {
            "type": "integer",
            "description": "The amount of extra time that must have passed beyond the roletag expiration, before it is removed from the backend storage. Defaults to 4320h (180 days).",
            "format": "seconds",
            "default": 15552000
          }
        }
      },
      "AWSConfigWriteRootIAMCredentialsRequest": {
        "type": "object",
        "properties": {
          "access_key": {
            "type": "string",
            "description": "Access key with permission to create new keys."
          },
          "iam_endpoint": {
            "type": "string",
            "description": "Endpoint to custom IAM server URL"
          },
          "max_retries": {
            "type": "integer",
            "description": "Maximum number of retries for recoverable exceptions of AWS APIs",
            "default": -1
          },
          "region": {
            "type": "string",
            "description": "Region for API calls."
          },
          "secret_key": {
            "type": "string",
            "description": "Secret key with permission to create new keys."
          },
          "sts_endpoint": {
            "type": "string",
            "description": "Endpoint to custom STS server URL"
          },
          "username_template": {
            "type": "string",
            "description": "Template to generate custom IAM usernames"
          }
        }
      },
      "AWSConfigWriteSecurityTokenServiceAccountRequest": {
        "type": "object",
        "properties": {
          "sts_role": {
            "type": "string",
            "description": "AWS ARN for STS role to be assumed when interacting with the account specified. The Vault server must have permissions to assume this role."
          }
        }
      },
      "AWSLoginRequest": {
        "type": "object",
        "properties": {
          "iam_http_request_method": {
            "type": "string",
            "description": "HTTP method to use for the AWS request when auth_type is iam. This must match what has been signed in the presigned request. Currently, POST is the only supported value"
          },
          "iam_request_body": {
            "type": "string",
            "description": "Base64-encoded request body when auth_type is iam. This must match the request body included in the signature."
          },
          "iam_request_headers": {
            "type": "string",
            "description": "Key/value pairs of headers for use in the sts:GetCallerIdentity HTTP requests headers when auth_type is iam. Can be either a Base64-encoded, JSON-serialized string, or a JSON object of key/value pairs. This must at a minimum include the headers over which AWS has included a signature."
          },
          "iam_request_url": {
            "type": "string",
            "description": "Base64-encoded full URL against which to make the AWS request when using iam auth_type."
          },
          "identity": {
            "type": "string",
            "description": "Base64 encoded EC2 instance identity document. This needs to be supplied along with the 'signature' parameter. If using 'curl' for fetching the identity document, consider using the option '-w 0' while piping the output to 'base64' binary."
          },
          "nonce": {
            "type": "string",
            "description": "The nonce to be used for subsequent login requests when auth_type is ec2. If this parameter is not specified at all and if reauthentication is allowed, then the backend will generate a random nonce, attaches it to the instance's identity access list entry and returns the nonce back as part of auth metadata. This value should be used with further login requests, to establish client authenticity. Clients can choose to set a custom nonce if preferred, in which case, it is recommended that clients provide a strong nonce. If a nonce is provided but with an empty value, it indicates intent to disable reauthentication. Note that, when 'disallow_reauthentication' option is enabled on either the role or the role tag, the 'nonce' holds no significance."
          },
          "pkcs7": {
            "type": "string",
            "description": "PKCS7 signature of the identity document when using an auth_type of ec2."
          },
          "role": {
            "type": "string",
            "description": "Name of the role against which the login is being attempted. If 'role' is not specified, then the login endpoint looks for a role bearing the name of the AMI ID of the EC2 instance that is trying to login. If a matching role is not found, login fails."
          },
          "signature": {
            "type": "string",
            "description": "Base64 encoded SHA256 RSA signature of the instance identity document. This needs to be supplied along with 'identity' parameter."
          }
        }
      },
      "AWSWriteAuthRoleRequest": {
        "type": "object",
        "properties": {
          "allow_instance_migration": {
            "type": "boolean",
            "description": "If set, allows migration of the underlying instance where the client resides. This keys off of pendingTime in the metadata document, so essentially, this disables the client nonce check whenever the instance is migrated to a new host and pendingTime is newer than the previously-remembered time. Use with caution. This is only checked when auth_type is ec2.",
            "default": false
          },
          "auth_type": {
            "type": "string",
            "description": "The auth_type permitted to authenticate to this role. Must be one of iam or ec2 and cannot be changed after role creation."
          },
          "bound_account_id": {
            "type": "array",
            "description": "If set, defines a constraint on the EC2 instances that the account ID in its identity document to match one of the IDs specified by this parameter. This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance.",
            "items": {
              "type": "string"
            }
          },
          "bound_ami_id": {
            "type": "array",
            "description": "If set, defines a constraint on the EC2 instances that they should be using one of the AMI IDs specified by this parameter. This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance.",
            "items": {
              "type": "string"
            }
          },
          "bound_ec2_instance_id": {
            "type": "array",
            "description": "If set, defines a constraint on the EC2 instances to have one of the given instance IDs. Can be a list or comma-separated string of EC2 instance IDs. This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance.",
            "items": {
              "type": "string"
            }
          },
          "bound_iam_instance_profile_arn": {
            "type": "array",
            "description": "If set, defines a constraint on the EC2 instances to be associated with an IAM instance profile ARN which has a prefix that matches one of the values specified by this parameter. The value is prefix-matched (as though it were a glob ending in '*'). This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance.",
            "items": {
              "type": "string"
            }
          },
          "bound_iam_principal_arn": {
            "type": "array",
            "description": "ARN of the IAM principals to bind to this role. Only applicable when auth_type is iam.",
            "items": {
              "type": "string"
            }
          },
          "bound_iam_role_arn": {
            "type": "array",
            "description": "If set, defines a constraint on the authenticating EC2 instance that it must match one of the IAM role ARNs specified by this parameter. The value is prefix-matched (as though it were a glob ending in '*'). The configured IAM user or EC2 instance role must be allowed to execute the 'iam:GetInstanceProfile' action if this is specified. This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance.",
            "items": {
              "type": "string"
            }
          },
          "bound_region": {
            "type": "array",
            "description": "If set, defines a constraint on the EC2 instances that the region in its identity document match one of the regions specified by this parameter. This is only applicable when auth_type is ec2.",
            "items": {
              "type": "string"
            }
          },
          "bound_subnet_id": {
            "type": "array",
            "description": "If set, defines a constraint on the EC2 instance to be associated with the subnet ID that matches one of the values specified by this parameter. This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance.",
            "items": {
              "type": "string"
            }
          },
          "bound_vpc_id": {
            "type": "array",
            "description": "If set, defines a constraint on the EC2 instance to be associated with a VPC ID that matches one of the value specified by this parameter. This is only applicable when auth_type is ec2 or inferred_entity_type is ec2_instance.",
            "items": {
              "type": "string"
            }
          },
          "disallow_reauthentication": {
            "type": "boolean",
            "description": "If set, only allows a single token to be granted per instance ID. In order to perform a fresh login, the entry in the access list for the instance ID needs to be cleared using 'auth/aws-ec2/identity-accesslist/<instance_id>' endpoint. This is only applicable when auth_type is ec2.",
            "default": false
          },
          "inferred_aws_region": {
            "type": "string",
            "description": "When auth_type is iam and inferred_entity_type is set, the region to assume the inferred entity exists in."
          },
          "inferred_entity_type": {
            "type": "string",
            "description": "When auth_type is iam, the AWS entity type to infer from the authenticated principal. The only supported value is ec2_instance, which will extract the EC2 instance ID from the authenticated role and apply the following restrictions specific to EC2 instances: bound_ami_id, bound_account_id, bound_iam_role_arn, bound_iam_instance_profile_arn, bound_vpc_id, bound_subnet_id. The configured EC2 client must be able to find the inferred instance ID in the results, and the instance must be running. If unable to determine the EC2 instance ID or unable to find the EC2 instance ID among running instances, then authentication will fail."
          },
          "max_ttl": {
            "type": "integer",
            "description": "Use \"token_max_ttl\" instead. If this and \"token_max_ttl\" are both specified, only \"token_max_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "period": {
            "type": "integer",
            "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "resolve_aws_unique_ids": {
            "type": "boolean",
            "description": "If set, resolve all AWS IAM ARNs into AWS's internal unique IDs. When an IAM entity (e.g., user, role, or instance profile) is deleted, then all references to it within the role will be invalidated, which prevents a new IAM entity from being created with the same name and matching the role's IAM binds. Once set, this cannot be unset.",
            "default": true
          },
          "role_tag": {
            "type": "string",
            "description": "If set, enables the role tags for this role. The value set for this field should be the 'key' of the tag on the EC2 instance. The 'value' of the tag should be generated using 'role/<role>/tag' endpoint. Defaults to an empty string, meaning that role tags are disabled. This is only allowed if auth_type is ec2.",
            "default": ""
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Use \"token_ttl\" instead. If this and \"token_ttl\" are both specified, only \"token_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          }
        }
      },
      "AWSWriteAuthRoleTagRequest": {
        "type": "object",
        "properties": {
          "allow_instance_migration": {
            "type": "boolean",
            "description": "If set, allows migration of the underlying instance where the client resides. This keys off of pendingTime in the metadata document, so essentially, this disables the client nonce check whenever the instance is migrated to a new host and pendingTime is newer than the previously-remembered time. Use with caution.",
            "default": false
          },
          "disallow_reauthentication": {
            "type": "boolean",
            "description": "If set, only allows a single token to be granted per instance ID. In order to perform a fresh login, the entry in access list for the instance ID needs to be cleared using the 'auth/aws-ec2/identity-accesslist/<instance_id>' endpoint.",
            "default": false
          },
          "instance_id": {
            "type": "string",
            "description": "Instance ID for which this tag is intended for. If set, the created tag can only be used by the instance with the given ID."
          },
          "max_ttl": {
            "type": "integer",
            "description": "If set, specifies the maximum allowed token lifetime.",
            "format": "seconds",
            "default": 0
          },
          "policies": {
            "type": "array",
            "description": "Policies to be associated with the tag. If set, must be a subset of the role's policies. If set, but set to an empty value, only the 'default' policy will be given to issued tokens.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AWSWriteCredentialsRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the role"
          },
          "role_arn": {
            "type": "string",
            "description": "ARN of role to assume when credential_type is assumed_role"
          },
          "role_session_name": {
            "type": "string",
            "description": "Session name to use when assuming role. Max chars: 64"
          },
          "ttl": {
            "type": "integer",
            "description": "Lifetime of the returned credentials in seconds",
            "format": "seconds",
            "default": 3600
          }
        }
      },
      "AWSWriteIdentityAccessListTidySettingsRequest": {
        "type": "object",
        "properties": {
          "safety_buffer": {
            "type": "integer",
            "description": "The amount of extra time that must have passed beyond the identity's expiration, before it is removed from the backend storage.",
            "format": "seconds",
            "default": 259200
          }
        }
      },
      "AWSWriteIdentityWhiteListTidySettingsRequest": {
        "type": "object",
        "properties": {
          "safety_buffer": {
            "type": "integer",
            "description": "The amount of extra time that must have passed beyond the identity's expiration, before it is removed from the backend storage.",
            "format": "seconds",
            "default": 259200
          }
        }
      },
      "AWSWriteRoleRequest": {
        "type": "object",
        "properties": {
          "arn": {
            "type": "string",
            "description": "Use role_arns or policy_arns instead.",
            "deprecated": true
          },
          "credential_type": {
            "type": "string",
            "description": "Type of credential to retrieve. Must be one of assumed_role, iam_user, or federation_token"
          },
          "default_sts_ttl": {
            "type": "integer",
            "description": "Default TTL for assumed_role and federation_token credential types when no TTL is explicitly requested with the credentials",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Default STS TTL"
            }
          },
          "iam_groups": {
            "type": "array",
            "description": "Names of IAM groups that generated IAM users will be added to. For a credential type of assumed_role or federation_token, the policies sent to the corresponding AWS call (sts:AssumeRole or sts:GetFederation) will be the policies from each group in iam_groups combined with the policy_document and policy_arns parameters.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IAM Groups",
              "value": "group1,group2"
            }
          },
          "iam_tags": {
            "type": "object",
            "description": "IAM tags to be set for any users created by this role. These must be presented as Key-Value pairs. This can be represented as a map or a list of equal sign delimited key pairs.",
            "format": "kvpairs",
            "x-vault-displayAttrs": {
              "name": "IAM Tags",
              "value": "[key1=value1, key2=value2]"
            }
          },
          "max_sts_ttl": {
            "type": "integer",
            "description": "Max allowed TTL for assumed_role and federation_token credential types",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Max STS TTL"
            }
          },
          "permissions_boundary_arn": {
            "type": "string",
            "description": "ARN of an IAM policy to attach as a permissions boundary on IAM user credentials; only valid when credential_type isiam_user",
            "x-vault-displayAttrs": {
              "name": "Permissions Boundary ARN"
            }
          },
          "policy": {
            "type": "string",
            "description": "Use policy_document instead.",
            "deprecated": true
          },
          "policy_arns": {
            "type": "array",
            "description": "ARNs of AWS policies. Behavior varies by credential_type. When credential_type is iam_user, then it will attach the specified policies to the generated IAM user. When credential_type is assumed_role or federation_token, the policies will be passed as the PolicyArns parameter, acting as a filter on permissions available.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Policy ARNs"
            }
          },
          "policy_document": {
            "type": "string",
            "description": "JSON-encoded IAM policy document. Behavior varies by credential_type. When credential_type is iam_user, then it will attach the contents of the policy_document to the IAM user generated. When credential_type is assumed_role or federation_token, this will be passed in as the Policy parameter to the AssumeRole or GetFederationToken API call, acting as a filter on permissions available."
          },
          "role_arns": {
            "type": "array",
            "description": "ARNs of AWS roles allowed to be assumed. Only valid when credential_type is assumed_role",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Role ARNs"
            }
          },
          "user_path": {
            "type": "string",
            "description": "Path for IAM User. Only valid when credential_type is iam_user",
            "default": "/",
            "x-vault-displayAttrs": {
              "name": "User Path",
              "value": "/"
            }
          }
        }
      },
      "AWSWriteRoleTagBlackListTidySettingsRequest": {
        "type": "object",
        "properties": {
          "safety_buffer": {
            "type": "integer",
            "description": "The amount of extra time that must have passed beyond the roletag expiration, before it is removed from the backend storage.",
            "format": "seconds",
            "default": 259200
          }
        }
      },
      "AWSWriteRoleTagDenyListTidySettingsRequest": {
        "type": "object",
        "properties": {
          "safety_buffer": {
            "type": "integer",
            "description": "The amount of extra time that must have passed beyond the roletag expiration, before it is removed from the backend storage.",
            "format": "seconds",
            "default": 259200
          }
        }
      },
      "AWSWriteSecurityTokenServiceRequest": {
        "type": "object",
        "properties": {
          "role_arn": {
            "type": "string",
            "description": "ARN of role to assume when credential_type is assumed_role"
          },
          "role_session_name": {
            "type": "string",
            "description": "Session name to use when assuming role. Max chars: 64"
          },
          "ttl": {
            "type": "integer",
            "description": "Lifetime of the returned credentials in seconds",
            "format": "seconds",
            "default": 3600
          }
        }
      },
      "ActiveDirectoryCheckInLibraryRequest": {
        "type": "object",
        "properties": {
          "service_account_names": {
            "type": "array",
            "description": "The username/logon name for the service accounts to check in.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ActiveDirectoryCheckInManageLibraryRequest": {
        "type": "object",
        "properties": {
          "service_account_names": {
            "type": "array",
            "description": "The username/logon name for the service accounts to check in.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ActiveDirectoryCheckOutLibraryRequest": {
        "type": "object",
        "properties": {
          "ttl": {
            "type": "integer",
            "description": "The length of time before the check-out will expire, in seconds.",
            "format": "seconds"
          }
        }
      },
      "ActiveDirectoryWriteConfigRequest": {
        "type": "object",
        "properties": {
          "anonymous_group_search": {
            "type": "boolean",
            "description": "Use anonymous binds when performing LDAP group searches (if true the initial credentials will still be used for the initial connection test).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Anonymous group search"
            }
          },
          "binddn": {
            "type": "string",
            "description": "LDAP DN for searching for the user DN (optional)",
            "x-vault-displayAttrs": {
              "name": "Name of Object to bind (binddn)"
            }
          },
          "bindpass": {
            "type": "string",
            "description": "LDAP password for searching for the user DN (optional)",
            "x-vault-displayAttrs": {
              "sensitive": true
            }
          },
          "case_sensitive_names": {
            "type": "boolean",
            "description": "If true, case sensitivity will be used when comparing usernames and groups for matching policies."
          },
          "certificate": {
            "type": "string",
            "description": "CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "CA certificate",
              "editType": "file"
            }
          },
          "client_tls_cert": {
            "type": "string",
            "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "Client certificate",
              "editType": "file"
            }
          },
          "client_tls_key": {
            "type": "string",
            "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "Client key",
              "editType": "file"
            }
          },
          "deny_null_bind": {
            "type": "boolean",
            "description": "Denies an unauthenticated LDAP bind request if the user's password is empty; defaults to true",
            "default": true
          },
          "discoverdn": {
            "type": "boolean",
            "description": "Use anonymous bind to discover the bind DN of a user (optional)",
            "x-vault-displayAttrs": {
              "name": "Discover DN"
            }
          },
          "formatter": {
            "type": "string",
            "description": "Text to insert the password into, ex. \"customPrefix{{PASSWORD}}customSuffix\".",
            "deprecated": true
          },
          "groupattr": {
            "type": "string",
            "description": "LDAP attribute to follow on objects returned by <groupfilter> in order to enumerate user group membership. Examples: \"cn\" or \"memberOf\", etc. Default: cn",
            "default": "cn",
            "x-vault-displayAttrs": {
              "name": "Group Attribute",
              "value": "cn"
            }
          },
          "groupdn": {
            "type": "string",
            "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org)",
            "x-vault-displayAttrs": {
              "name": "Group DN"
            }
          },
          "groupfilter": {
            "type": "string",
            "description": "Go template for querying group membership of user (optional) The template can access the following context variables: UserDN, Username Example: (&(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})) Default: (|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))",
            "default": "(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))",
            "x-vault-displayAttrs": {
              "name": "Group Filter"
            }
          },
          "insecure_tls": {
            "type": "boolean",
            "description": "Skip LDAP server SSL Certificate verification - VERY insecure (optional)",
            "x-vault-displayAttrs": {
              "name": "Insecure TLS"
            }
          },
          "last_rotation_tolerance": {
            "type": "integer",
            "description": "The number of seconds after a Vault rotation where, if Active Directory shows a later rotation, it should be considered out-of-band.",
            "format": "seconds",
            "default": 5
          },
          "length": {
            "type": "integer",
            "description": "The desired length of passwords that Vault generates.",
            "default": 64,
            "deprecated": true
          },
          "max_ttl": {
            "type": "integer",
            "description": "In seconds, the maximum password time-to-live.",
            "format": "seconds"
          },
          "password_policy": {
            "type": "string",
            "description": "Name of the password policy to use to generate passwords."
          },
          "request_timeout": {
            "type": "integer",
            "description": "Timeout, in seconds, for the connection when making requests against the server before returning back an error.",
            "format": "seconds",
            "default": "90s"
          },
          "starttls": {
            "type": "boolean",
            "description": "Issue a StartTLS command after establishing unencrypted connection (optional)",
            "x-vault-displayAttrs": {
              "name": "Issue StartTLS"
            }
          },
          "tls_max_version": {
            "type": "string",
            "description": "Maximum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'",
            "enum": [
              "tls10",
              "tls11",
              "tls12",
              "tls13"
            ],
            "default": "tls12",
            "x-vault-displayAttrs": {
              "name": "Maximum TLS Version"
            }
          },
          "tls_min_version": {
            "type": "string",
            "description": "Minimum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'",
            "enum": [
              "tls10",
              "tls11",
              "tls12",
              "tls13"
            ],
            "default": "tls12",
            "x-vault-displayAttrs": {
              "name": "Minimum TLS Version"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "In seconds, the default password time-to-live.",
            "format": "seconds"
          },
          "upndomain": {
            "type": "string",
            "description": "Enables userPrincipalDomain login with [username]@UPNDomain (optional)",
            "x-vault-displayAttrs": {
              "name": "User Principal (UPN) Domain"
            }
          },
          "url": {
            "type": "string",
            "description": "LDAP URL to connect to (default: ldap://127.0.0.1). Multiple URLs can be specified by concatenating them with commas; they will be tried in-order.",
            "default": "ldap://127.0.0.1",
            "x-vault-displayAttrs": {
              "name": "URL"
            }
          },
          "use_pre111_group_cn_behavior": {
            "type": "boolean",
            "description": "In Vault 1.1.1 a fix for handling group CN values of different cases unfortunately introduced a regression that could cause previously defined groups to not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for matching group CNs will be used. This is only needed in some upgrade scenarios for backwards compatibility. It is enabled by default if the config is upgraded but disabled by default on new configurations."
          },
          "use_token_groups": {
            "type": "boolean",
            "description": "If true, use the Active Directory tokenGroups constructed attribute of the user to find the group memberships. This will find all security groups including nested ones.",
            "default": false
          },
          "userattr": {
            "type": "string",
            "description": "Attribute used for users (default: cn)",
            "default": "cn",
            "x-vault-displayAttrs": {
              "name": "User Attribute",
              "value": "cn"
            }
          },
          "userdn": {
            "type": "string",
            "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)",
            "x-vault-displayAttrs": {
              "name": "User DN"
            }
          },
          "userfilter": {
            "type": "string",
            "description": "Go template for LDAP user search filer (optional) The template can access the following context variables: UserAttr, Username Default: ({{.UserAttr}}={{.Username}})",
            "default": "({{.UserAttr}}={{.Username}})",
            "x-vault-displayAttrs": {
              "name": "User Search Filter"
            }
          },
          "username_as_alias": {
            "type": "boolean",
            "description": "If true, sets the alias name to the username",
            "default": false
          }
        }
      },
      "ActiveDirectoryWriteLibraryRequest": {
        "type": "object",
        "properties": {
          "disable_check_in_enforcement": {
            "type": "boolean",
            "description": "Disable the default behavior of requiring that check-ins are performed by the entity that checked them out.",
            "default": false
          },
          "max_ttl": {
            "type": "integer",
            "description": "In seconds, the max amount of time a check-out's renewals should last. Defaults to 24 hours.",
            "format": "seconds",
            "default": 86400
          },
          "service_account_names": {
            "type": "array",
            "description": "The username/logon name for the service accounts with which this set will be associated.",
            "items": {
              "type": "string"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "In seconds, the amount of time a check-out should last. Defaults to 24 hours.",
            "format": "seconds",
            "default": 86400
          }
        }
      },
      "ActiveDirectoryWriteRoleRequest": {
        "type": "object",
        "properties": {
          "service_account_name": {
            "type": "string",
            "description": "The username/logon name for the service account with which this role will be associated."
          },
          "ttl": {
            "type": "integer",
            "description": "In seconds, the default password time-to-live.",
            "format": "seconds"
          }
        }
      },
      "AliCloudLoginRequest": {
        "type": "object",
        "properties": {
          "identity_request_headers": {
            "type": "string",
            "description": "The request headers. This must include the headers over which AliCloud has included a signature."
          },
          "identity_request_url": {
            "type": "string",
            "description": "Base64-encoded full URL against which to make the AliCloud request."
          },
          "role": {
            "type": "string",
            "description": "Name of the role against which the login is being attempted. If 'role' is not specified, then the login endpoint looks for a role name in the ARN returned by the GetCallerIdentity request. If a matching role is not found, login fails."
          }
        },
        "required": [
          "role"
        ]
      },
      "AliCloudWriteAuthRoleRequest": {
        "type": "object",
        "properties": {
          "arn": {
            "type": "string",
            "description": "ARN of the RAM to bind to this role."
          },
          "bound_cidrs": {
            "type": "array",
            "description": "Use \"token_bound_cidrs\" instead. If this and \"token_bound_cidrs\" are both specified, only \"token_bound_cidrs\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "max_ttl": {
            "type": "integer",
            "description": "Use \"token_max_ttl\" instead. If this and \"token_max_ttl\" are both specified, only \"token_max_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "period": {
            "type": "integer",
            "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Use \"token_ttl\" instead. If this and \"token_ttl\" are both specified, only \"token_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          }
        }
      },
      "AliCloudWriteConfigRequest": {
        "type": "object",
        "properties": {
          "access_key": {
            "type": "string",
            "description": "Access key with appropriate permissions."
          },
          "secret_key": {
            "type": "string",
            "description": "Secret key with appropriate permissions."
          }
        }
      },
      "AliCloudWriteRoleRequest": {
        "type": "object",
        "properties": {
          "inline_policies": {
            "type": "string",
            "description": "JSON of policies to be dynamically applied to users of this role."
          },
          "max_ttl": {
            "type": "integer",
            "description": "The maximum allowed lifetime of tokens issued using this role.",
            "format": "seconds"
          },
          "remote_policies": {
            "type": "array",
            "description": "The name and type of each remote policy to be applied. Example: \"name:AliyunRDSReadOnlyAccess,type:System\".",
            "items": {
              "type": "string"
            }
          },
          "role_arn": {
            "type": "string",
            "description": "ARN of the role to be assumed. If provided, inline_policies and remote_policies should be blank. At creation time, this role must have configured trusted actors, and the access key and secret that will be used to assume the role (in /config) must qualify as a trusted actor."
          },
          "ttl": {
            "type": "integer",
            "description": "Duration in seconds after which the issued token should expire. Defaults to 0, in which case the value will fallback to the system/mount defaults.",
            "format": "seconds"
          }
        }
      },
      "AliasWriteByIDRequest": {
        "type": "object",
        "properties": {
          "canonical_id": {
            "type": "string",
            "description": "Entity ID to which this alias should be tied to"
          },
          "entity_id": {
            "type": "string",
            "description": "Entity ID to which this alias should be tied to. This field is deprecated in favor of 'canonical_id'."
          },
          "mount_accessor": {
            "type": "string",
            "description": "Mount accessor to which this alias belongs to"
          },
          "name": {
            "type": "string",
            "description": "Name of the alias"
          }
        }
      },
      "AliasWriteRequest": {
        "type": "object",
        "properties": {
          "canonical_id": {
            "type": "string",
            "description": "Entity ID to which this alias belongs to"
          },
          "entity_id": {
            "type": "string",
            "description": "Entity ID to which this alias belongs to. This field is deprecated in favor of 'canonical_id'."
          },
          "id": {
            "type": "string",
            "description": "ID of the alias"
          },
          "mount_accessor": {
            "type": "string",
            "description": "Mount accessor to which this alias belongs to"
          },
          "name": {
            "type": "string",
            "description": "Name of the alias"
          }
        }
      },
      "AppRoleListRolesResponse": {
        "type": "object",
        "properties": {
          "keys": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AppRoleListSecretIDResponse": {
        "type": "object",
        "properties": {
          "keys": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AppRoleLoginRequest": {
        "type": "object",
        "properties": {
          "role_id": {
            "type": "string",
            "description": "Unique identifier of the Role. Required to be supplied when the 'bind_secret_id' constraint is set."
          },
          "secret_id": {
            "type": "string",
            "description": "SecretID belong to the App role",
            "default": ""
          }
        }
      },
      "AppRoleReadBindSecretIDResponse": {
        "type": "object",
        "properties": {
          "bind_secret_id": {
            "type": "boolean",
            "description": "Impose secret_id to be presented when logging in using this role. Defaults to 'true'."
          }
        }
      },
      "AppRoleReadBoundCIDRListResponse": {
        "type": "object",
        "properties": {
          "bound_cidr_list": {
            "type": "array",
            "description": "Deprecated: Please use \"secret_id_bound_cidrs\" instead. Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          }
        }
      },
      "AppRoleReadLocalSecretIDsResponse": {
        "type": "object",
        "properties": {
          "local_secret_ids": {
            "type": "boolean",
            "description": "If true, the secret identifiers generated using this role will be cluster local. This can only be set during role creation and once set, it can't be reset later"
          }
        }
      },
      "AppRoleReadPeriodResponse": {
        "type": "object",
        "properties": {
          "period": {
            "type": "integer",
            "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds"
          }
        }
      },
      "AppRoleReadPoliciesResponse": {
        "type": "object",
        "properties": {
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AppRoleReadRoleIDResponse": {
        "type": "object",
        "properties": {
          "role_id": {
            "type": "string",
            "description": "Identifier of the role. Defaults to a UUID."
          }
        }
      },
      "AppRoleReadRoleResponse": {
        "type": "object",
        "properties": {
          "bind_secret_id": {
            "type": "boolean",
            "description": "Impose secret ID to be presented when logging in using this role."
          },
          "local_secret_ids": {
            "type": "boolean",
            "description": "If true, the secret identifiers generated using this role will be cluster local. This can only be set during role creation and once set, it can't be reset later"
          },
          "period": {
            "type": "integer",
            "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "secret_id_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation.",
            "items": {
              "type": "string"
            }
          },
          "secret_id_num_uses": {
            "type": "integer",
            "description": "Number of times a secret ID can access the role, after which the secret ID will expire."
          },
          "secret_id_ttl": {
            "type": "integer",
            "description": "Duration in seconds after which the issued secret ID expires.",
            "format": "seconds"
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds"
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds"
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens"
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited"
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value.",
            "format": "seconds"
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds"
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service"
          }
        }
      },
      "AppRoleReadSecretIDBoundCIDRsResponse": {
        "type": "object",
        "properties": {
          "secret_id_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AppRoleReadSecretIDNumUsesResponse": {
        "type": "object",
        "properties": {
          "secret_id_num_uses": {
            "type": "integer",
            "description": "Number of times a secret ID can access the role, after which the SecretID will expire. Defaults to 0 meaning that the secret ID is of unlimited use."
          }
        }
      },
      "AppRoleReadSecretIDTTLResponse": {
        "type": "object",
        "properties": {
          "secret_id_ttl": {
            "type": "integer",
            "description": "Duration in seconds after which the issued secret ID should expire. Defaults to 0, meaning no expiration.",
            "format": "seconds"
          }
        }
      },
      "AppRoleReadTokenBoundCIDRsResponse": {
        "type": "object",
        "properties": {
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. Should be a subset of the token CIDR blocks listed on the role, if any.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AppRoleReadTokenMaxTTLResponse": {
        "type": "object",
        "properties": {
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds"
          }
        }
      },
      "AppRoleReadTokenNumUsesResponse": {
        "type": "object",
        "properties": {
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited"
          }
        }
      },
      "AppRoleReadTokenTTLResponse": {
        "type": "object",
        "properties": {
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds"
          }
        }
      },
      "AppRoleWriteBindSecretIDRequest": {
        "type": "object",
        "properties": {
          "bind_secret_id": {
            "type": "boolean",
            "description": "Impose secret_id to be presented when logging in using this role.",
            "default": true
          }
        }
      },
      "AppRoleWriteBoundCIDRListRequest": {
        "type": "object",
        "properties": {
          "bound_cidr_list": {
            "type": "array",
            "description": "Deprecated: Please use \"secret_id_bound_cidrs\" instead. Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AppRoleWriteCustomSecretIDRequest": {
        "type": "object",
        "properties": {
          "cidr_list": {
            "type": "array",
            "description": "Comma separated string or list of CIDR blocks enforcing secret IDs to be used from specific set of IP addresses. If 'bound_cidr_list' is set on the role, then the list of CIDR blocks listed here should be a subset of the CIDR blocks listed on the role.",
            "items": {
              "type": "string"
            }
          },
          "metadata": {
            "type": "string",
            "description": "Metadata to be tied to the SecretID. This should be a JSON formatted string containing metadata in key value pairs."
          },
          "num_uses": {
            "type": "integer",
            "description": "Number of times this SecretID can be used, after which the SecretID expires. Overrides secret_id_num_uses role option when supplied. May not be higher than role's secret_id_num_uses."
          },
          "secret_id": {
            "type": "string",
            "description": "SecretID to be attached to the role."
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. Should be a subset of the token CIDR blocks listed on the role, if any.",
            "items": {
              "type": "string"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Duration in seconds after which this SecretID expires. Overrides secret_id_ttl role option when supplied. May not be longer than role's secret_id_ttl.",
            "format": "seconds"
          }
        }
      },
      "AppRoleWriteCustomSecretIDResponse": {
        "type": "object",
        "properties": {
          "secret_id": {
            "type": "string",
            "description": "Secret ID attached to the role."
          },
          "secret_id_accessor": {
            "type": "string",
            "description": "Accessor of the secret ID"
          },
          "secret_id_num_uses": {
            "type": "integer",
            "description": "Number of times a secret ID can access the role, after which the secret ID will expire."
          },
          "secret_id_ttl": {
            "type": "integer",
            "description": "Duration in seconds after which the issued secret ID expires.",
            "format": "seconds"
          }
        }
      },
      "AppRoleWritePeriodRequest": {
        "type": "object",
        "properties": {
          "period": {
            "type": "integer",
            "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds"
          }
        }
      },
      "AppRoleWritePoliciesRequest": {
        "type": "object",
        "properties": {
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AppRoleWriteRoleIDRequest": {
        "type": "object",
        "properties": {
          "role_id": {
            "type": "string",
            "description": "Identifier of the role. Defaults to a UUID."
          }
        }
      },
      "AppRoleWriteRoleRequest": {
        "type": "object",
        "properties": {
          "bind_secret_id": {
            "type": "boolean",
            "description": "Impose secret_id to be presented when logging in using this role. Defaults to 'true'.",
            "default": true
          },
          "bound_cidr_list": {
            "type": "array",
            "description": "Use \"secret_id_bound_cidrs\" instead.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "local_secret_ids": {
            "type": "boolean",
            "description": "If set, the secret IDs generated using this role will be cluster local. This can only be set during role creation and once set, it can't be reset later."
          },
          "period": {
            "type": "integer",
            "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "role_id": {
            "type": "string",
            "description": "Identifier of the role. Defaults to a UUID."
          },
          "secret_id_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation.",
            "items": {
              "type": "string"
            }
          },
          "secret_id_num_uses": {
            "type": "integer",
            "description": "Number of times a SecretID can access the role, after which the SecretID will expire. Defaults to 0 meaning that the the secret_id is of unlimited use."
          },
          "secret_id_ttl": {
            "type": "integer",
            "description": "Duration in seconds after which the issued SecretID should expire. Defaults to 0, meaning no expiration.",
            "format": "seconds"
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          }
        }
      },
      "AppRoleWriteSecretIDAccessorDestroyRequest": {
        "type": "object",
        "properties": {
          "secret_id_accessor": {
            "type": "string",
            "description": "Accessor of the SecretID"
          }
        }
      },
      "AppRoleWriteSecretIDAccessorLookupRequest": {
        "type": "object",
        "properties": {
          "secret_id_accessor": {
            "type": "string",
            "description": "Accessor of the SecretID"
          }
        }
      },
      "AppRoleWriteSecretIDAccessorLookupResponse": {
        "type": "object",
        "properties": {
          "cidr_list": {
            "type": "array",
            "description": "List of CIDR blocks enforcing secret IDs to be used from specific set of IP addresses. If 'bound_cidr_list' is set on the role, then the list of CIDR blocks listed here should be a subset of the CIDR blocks listed on the role.",
            "items": {
              "type": "string"
            }
          },
          "creation_time": {
            "type": "string",
            "format": "date-time"
          },
          "expiration_time": {
            "type": "string",
            "format": "date-time"
          },
          "last_updated_time": {
            "type": "string",
            "format": "date-time"
          },
          "metadata": {
            "type": "object",
            "format": "map"
          },
          "secret_id_accessor": {
            "type": "string",
            "description": "Accessor of the secret ID"
          },
          "secret_id_num_uses": {
            "type": "integer",
            "description": "Number of times a secret ID can access the role, after which the secret ID will expire."
          },
          "secret_id_ttl": {
            "type": "integer",
            "description": "Duration in seconds after which the issued secret ID expires.",
            "format": "seconds"
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "List of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. Should be a subset of the token CIDR blocks listed on the role, if any.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AppRoleWriteSecretIDBoundCIDRsRequest": {
        "type": "object",
        "properties": {
          "secret_id_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can perform the login operation.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AppRoleWriteSecretIDDestroyRequest": {
        "type": "object",
        "properties": {
          "secret_id": {
            "type": "string",
            "description": "SecretID attached to the role."
          }
        }
      },
      "AppRoleWriteSecretIDLookupRequest": {
        "type": "object",
        "properties": {
          "secret_id": {
            "type": "string",
            "description": "SecretID attached to the role."
          }
        }
      },
      "AppRoleWriteSecretIDLookupResponse": {
        "type": "object",
        "properties": {
          "cidr_list": {
            "type": "array",
            "description": "List of CIDR blocks enforcing secret IDs to be used from specific set of IP addresses. If 'bound_cidr_list' is set on the role, then the list of CIDR blocks listed here should be a subset of the CIDR blocks listed on the role.",
            "items": {
              "type": "string"
            }
          },
          "creation_time": {
            "type": "string",
            "format": "date-time"
          },
          "expiration_time": {
            "type": "string",
            "format": "date-time"
          },
          "last_updated_time": {
            "type": "string",
            "format": "date-time"
          },
          "metadata": {
            "type": "object",
            "format": "map"
          },
          "secret_id_accessor": {
            "type": "string",
            "description": "Accessor of the secret ID"
          },
          "secret_id_num_uses": {
            "type": "integer",
            "description": "Number of times a secret ID can access the role, after which the secret ID will expire."
          },
          "secret_id_ttl": {
            "type": "integer",
            "description": "Duration in seconds after which the issued secret ID expires.",
            "format": "seconds"
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "List of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token. Should be a subset of the token CIDR blocks listed on the role, if any.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AppRoleWriteSecretIDNumUsesRequest": {
        "type": "object",
        "properties": {
          "secret_id_num_uses": {
            "type": "integer",
            "description": "Number of times a SecretID can access the role, after which the SecretID will expire."
          }
        }
      },
      "AppRoleWriteSecretIDRequest": {
        "type": "object",
        "properties": {
          "cidr_list": {
            "type": "array",
            "description": "Comma separated string or list of CIDR blocks enforcing secret IDs to be used from specific set of IP addresses. If 'bound_cidr_list' is set on the role, then the list of CIDR blocks listed here should be a subset of the CIDR blocks listed on the role.",
            "items": {
              "type": "string"
            }
          },
          "metadata": {
            "type": "string",
            "description": "Metadata to be tied to the SecretID. This should be a JSON formatted string containing the metadata in key value pairs."
          },
          "num_uses": {
            "type": "integer",
            "description": "Number of times this SecretID can be used, after which the SecretID expires. Overrides secret_id_num_uses role option when supplied. May not be higher than role's secret_id_num_uses."
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Duration in seconds after which this SecretID expires. Overrides secret_id_ttl role option when supplied. May not be longer than role's secret_id_ttl.",
            "format": "seconds"
          }
        }
      },
      "AppRoleWriteSecretIDResponse": {
        "type": "object",
        "properties": {
          "secret_id": {
            "type": "string",
            "description": "Secret ID attached to the role."
          },
          "secret_id_accessor": {
            "type": "string",
            "description": "Accessor of the secret ID"
          },
          "secret_id_num_uses": {
            "type": "integer",
            "description": "Number of times a secret ID can access the role, after which the secret ID will expire."
          },
          "secret_id_ttl": {
            "type": "integer",
            "description": "Duration in seconds after which the issued secret ID expires.",
            "format": "seconds"
          }
        }
      },
      "AppRoleWriteSecretIDTTLRequest": {
        "type": "object",
        "properties": {
          "secret_id_ttl": {
            "type": "integer",
            "description": "Duration in seconds after which the issued SecretID should expire. Defaults to 0, meaning no expiration.",
            "format": "seconds"
          }
        }
      },
      "AppRoleWriteTokenBoundCIDRsRequest": {
        "type": "object",
        "properties": {
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "AppRoleWriteTokenMaxTTLRequest": {
        "type": "object",
        "properties": {
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds"
          }
        }
      },
      "AppRoleWriteTokenNumUsesRequest": {
        "type": "object",
        "properties": {
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited"
          }
        }
      },
      "AppRoleWriteTokenTTLRequest": {
        "type": "object",
        "properties": {
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds"
          }
        }
      },
      "AzureLoginRequest": {
        "type": "object",
        "properties": {
          "jwt": {
            "type": "string",
            "description": "A signed JWT"
          },
          "resource_group_name": {
            "type": "string",
            "description": "The resource group from the instance."
          },
          "role": {
            "type": "string",
            "description": "The token role."
          },
          "subscription_id": {
            "type": "string",
            "description": "The subscription id for the instance."
          },
          "vm_name": {
            "type": "string",
            "description": "The name of the virtual machine. This value is ignored if vmss_name is specified."
          },
          "vmss_name": {
            "type": "string",
            "description": "The name of the virtual machine scale set the instance is in."
          }
        }
      },
      "AzureWriteAuthConfigRequest": {
        "type": "object",
        "properties": {
          "client_id": {
            "type": "string",
            "description": "The OAuth2 client id to connection to Azure. This value can also be provided with the AZURE_CLIENT_ID environment variable.",
            "x-vault-displayAttrs": {
              "name": "Client ID"
            }
          },
          "client_secret": {
            "type": "string",
            "description": "The OAuth2 client secret to connection to Azure. This value can also be provided with the AZURE_CLIENT_SECRET environment variable."
          },
          "environment": {
            "type": "string",
            "description": "The Azure environment name. If not provided, AzurePublicCloud is used. This value can also be provided with the AZURE_ENVIRONMENT environment variable."
          },
          "resource": {
            "type": "string",
            "description": "The resource URL for the vault application in Azure Active Directory. This value can also be provided with the AZURE_AD_RESOURCE environment variable."
          },
          "tenant_id": {
            "type": "string",
            "description": "The tenant id for the Azure Active Directory. This is sometimes referred to as Directory ID in AD. This value can also be provided with the AZURE_TENANT_ID environment variable.",
            "x-vault-displayAttrs": {
              "name": "Tenant ID"
            }
          }
        }
      },
      "AzureWriteAuthRoleRequest": {
        "type": "object",
        "properties": {
          "bound_group_ids": {
            "type": "array",
            "description": "Comma-separated list of group ids that login is restricted to.",
            "items": {
              "type": "string"
            }
          },
          "bound_locations": {
            "type": "array",
            "description": "Comma-separated list of locations that login is restricted to.",
            "items": {
              "type": "string"
            }
          },
          "bound_resource_groups": {
            "type": "array",
            "description": "Comma-separated list of resource groups that login is restricted to.",
            "items": {
              "type": "string"
            }
          },
          "bound_scale_sets": {
            "type": "array",
            "description": "Comma-separated list of scale sets that login is restricted to.",
            "items": {
              "type": "string"
            }
          },
          "bound_service_principal_ids": {
            "type": "array",
            "description": "Comma-separated list of service principal ids that login is restricted to.",
            "items": {
              "type": "string"
            }
          },
          "bound_subscription_ids": {
            "type": "array",
            "description": "Comma-separated list of subscription ids that login is restricted to.",
            "items": {
              "type": "string"
            }
          },
          "max_ttl": {
            "type": "integer",
            "description": "Use \"token_max_ttl\" instead. If this and \"token_max_ttl\" are both specified, only \"token_max_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "num_uses": {
            "type": "integer",
            "description": "Use \"token_num_uses\" instead. If this and \"token_num_uses\" are both specified, only \"token_num_uses\" will be used.",
            "deprecated": true
          },
          "period": {
            "type": "integer",
            "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Use \"token_ttl\" instead. If this and \"token_ttl\" are both specified, only \"token_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          }
        }
      },
      "AzureWriteConfigRequest": {
        "type": "object",
        "properties": {
          "client_id": {
            "type": "string",
            "description": "The OAuth2 client id to connect to Azure. This value can also be provided with the AZURE_CLIENT_ID environment variable."
          },
          "client_secret": {
            "type": "string",
            "description": "The OAuth2 client secret to connect to Azure. This value can also be provided with the AZURE_CLIENT_SECRET environment variable."
          },
          "environment": {
            "type": "string",
            "description": "The Azure environment name. If not provided, AzurePublicCloud is used. This value can also be provided with the AZURE_ENVIRONMENT environment variable."
          },
          "password_policy": {
            "type": "string",
            "description": "Name of the password policy to use to generate passwords for dynamic credentials."
          },
          "root_password_ttl": {
            "type": "integer",
            "description": "The TTL of the root password in Azure. This can be either a number of seconds or a time formatted duration (ex: 24h, 48ds)",
            "format": "seconds",
            "default": 15768000000000000
          },
          "subscription_id": {
            "type": "string",
            "description": "The subscription id for the Azure Active Directory. This value can also be provided with the AZURE_SUBSCRIPTION_ID environment variable."
          },
          "tenant_id": {
            "type": "string",
            "description": "The tenant id for the Azure Active Directory. This value can also be provided with the AZURE_TENANT_ID environment variable."
          }
        }
      },
      "AzureWriteRoleRequest": {
        "type": "object",
        "properties": {
          "application_object_id": {
            "type": "string",
            "description": "Application Object ID to use for static service principal credentials."
          },
          "azure_groups": {
            "type": "string",
            "description": "JSON list of Azure groups to add the service principal to."
          },
          "azure_roles": {
            "type": "string",
            "description": "JSON list of Azure roles to assign."
          },
          "max_ttl": {
            "type": "integer",
            "description": "Maximum time a service principal. If not set or set to 0, will use system default.",
            "format": "seconds"
          },
          "permanently_delete": {
            "type": "boolean",
            "description": "Indicates whether new application objects should be permanently deleted. If not set, objects will not be permanently deleted.",
            "default": false
          },
          "ttl": {
            "type": "integer",
            "description": "Default lease for generated credentials. If not set or set to 0, will use system default.",
            "format": "seconds"
          }
        }
      },
      "CalculateAuditHashRequest": {
        "type": "object",
        "properties": {
          "input": {
            "type": "string"
          }
        }
      },
      "CentrifyLoginRequest": {
        "type": "object",
        "properties": {
          "mode": {
            "type": "string",
            "description": "Auth mode ('ro' for resource owner, 'cc' for credential client).",
            "default": "ro"
          },
          "password": {
            "type": "string",
            "description": "Password for this user."
          },
          "username": {
            "type": "string",
            "description": "Username of the user."
          }
        }
      },
      "CentrifyWriteConfigRequest": {
        "type": "object",
        "properties": {
          "app_id": {
            "type": "string",
            "description": "OAuth2 App ID",
            "default": "vault_io_integration"
          },
          "client_id": {
            "type": "string",
            "description": "OAuth2 Client ID"
          },
          "client_secret": {
            "type": "string",
            "description": "OAuth2 Client Secret"
          },
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "scope": {
            "type": "string",
            "description": "OAuth2 App Scope",
            "default": "vault_io_integration"
          },
          "service_url": {
            "type": "string",
            "description": "Service URL (https://<tenant>.my.centrify.com)"
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          }
        }
      },
      "CertificatesLoginRequest": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the certificate role to authenticate against."
          }
        }
      },
      "CertificatesWriteCRLRequest": {
        "type": "object",
        "properties": {
          "crl": {
            "type": "string",
            "description": "The public CRL that should be trusted to attest to certificates' validity statuses. May be DER or PEM encoded. Note: the expiration time is ignored; if the CRL is no longer valid, delete it using the same name as specified here."
          },
          "url": {
            "type": "string",
            "description": "The URL of a CRL distribution point. Only one of 'crl' or 'url' parameters should be specified."
          }
        }
      },
      "CertificatesWriteConfigRequest": {
        "type": "object",
        "properties": {
          "disable_binding": {
            "type": "boolean",
            "description": "If set, during renewal, skips the matching of presented client identity with the client identity used during login. Defaults to false.",
            "default": false
          },
          "enable_identity_alias_metadata": {
            "type": "boolean",
            "description": "If set, metadata of the certificate including the metadata corresponding to allowed_metadata_extensions will be stored in the alias. Defaults to false.",
            "default": false
          },
          "ocsp_cache_size": {
            "type": "integer",
            "description": "The size of the in memory OCSP response cache, shared by all configured certs",
            "default": 100
          }
        }
      },
      "CertificatesWriteRequest": {
        "type": "object",
        "properties": {
          "allowed_common_names": {
            "type": "array",
            "description": "A comma-separated list of names. At least one must exist in the Common Name. Supports globbing.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "group": "Constraints"
            }
          },
          "allowed_dns_sans": {
            "type": "array",
            "description": "A comma-separated list of DNS names. At least one must exist in the SANs. Supports globbing.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Allowed DNS SANs",
              "group": "Constraints"
            }
          },
          "allowed_email_sans": {
            "type": "array",
            "description": "A comma-separated list of Email Addresses. At least one must exist in the SANs. Supports globbing.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Allowed Email SANs",
              "group": "Constraints"
            }
          },
          "allowed_metadata_extensions": {
            "type": "array",
            "description": "A comma-separated string or array of oid extensions. Upon successful authentication, these extensions will be added as metadata if they are present in the certificate. The metadata key will be the string consisting of the oid numbers separated by a dash (-) instead of a dot (.) to allow usage in ACL templates.",
            "items": {
              "type": "string"
            }
          },
          "allowed_names": {
            "type": "array",
            "description": "A comma-separated list of names. At least one must exist in either the Common Name or SANs. Supports globbing. This parameter is deprecated, please use allowed_common_names, allowed_dns_sans, allowed_email_sans, allowed_uri_sans.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "group": "Constraints"
            }
          },
          "allowed_organizational_units": {
            "type": "array",
            "description": "A comma-separated list of Organizational Units names. At least one must exist in the OU field.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "group": "Constraints"
            }
          },
          "allowed_uri_sans": {
            "type": "array",
            "description": "A comma-separated list of URIs. At least one must exist in the SANs. Supports globbing.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Allowed URI SANs",
              "group": "Constraints"
            }
          },
          "bound_cidrs": {
            "type": "array",
            "description": "Use \"token_bound_cidrs\" instead. If this and \"token_bound_cidrs\" are both specified, only \"token_bound_cidrs\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "certificate": {
            "type": "string",
            "description": "The public certificate that should be trusted. Must be x509 PEM encoded.",
            "x-vault-displayAttrs": {
              "editType": "file"
            }
          },
          "display_name": {
            "type": "string",
            "description": "The display name to use for clients using this certificate."
          },
          "lease": {
            "type": "integer",
            "description": "Use \"token_ttl\" instead. If this and \"token_ttl\" are both specified, only \"token_ttl\" will be used.",
            "deprecated": true
          },
          "max_ttl": {
            "type": "integer",
            "description": "Use \"token_max_ttl\" instead. If this and \"token_max_ttl\" are both specified, only \"token_max_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "ocsp_ca_certificates": {
            "type": "string",
            "description": "Any additional CA certificates needed to communicate with OCSP servers",
            "x-vault-displayAttrs": {
              "editType": "file"
            }
          },
          "ocsp_enabled": {
            "type": "boolean",
            "description": "Whether to attempt OCSP verification of certificates at login"
          },
          "ocsp_fail_open": {
            "type": "boolean",
            "description": "If set to true, if an OCSP revocation cannot be made successfully, login will proceed rather than failing. If false, failing to get an OCSP status fails the request.",
            "default": false
          },
          "ocsp_query_all_servers": {
            "type": "boolean",
            "description": "If set to true, rather than accepting the first successful OCSP response, query all servers and consider the certificate valid only if all servers agree.",
            "default": false
          },
          "ocsp_servers_override": {
            "type": "array",
            "description": "A comma-separated list of OCSP server addresses. If unset, the OCSP server is determined from the AuthorityInformationAccess extension on the certificate being inspected.",
            "items": {
              "type": "string"
            }
          },
          "period": {
            "type": "integer",
            "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "required_extensions": {
            "type": "array",
            "description": "A comma-separated string or array of extensions formatted as \"oid:value\". Expects the extension value to be some type of ASN1 encoded string. All values much match. Supports globbing on \"value\".",
            "items": {
              "type": "string"
            }
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Use \"token_ttl\" instead. If this and \"token_ttl\" are both specified, only \"token_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          }
        }
      },
      "CloudFoundryLoginRequest": {
        "type": "object",
        "properties": {
          "cf_instance_cert": {
            "type": "string",
            "description": "The full body of the file available at the CF_INSTANCE_CERT path on the CF instance.",
            "x-vault-displayAttrs": {
              "name": "CF_INSTANCE_CERT Contents"
            }
          },
          "role": {
            "type": "string",
            "description": "The name of the role to authenticate against.",
            "x-vault-displayAttrs": {
              "name": "Role Name",
              "value": "internally-defined-role"
            }
          },
          "signature": {
            "type": "string",
            "description": "The signature generated by the client certificate's private key.",
            "x-vault-displayAttrs": {
              "name": "Signature"
            }
          },
          "signing_time": {
            "type": "string",
            "description": "The date and time used to construct the signature.",
            "x-vault-displayAttrs": {
              "name": "Signing Time",
              "value": "2006-01-02T15:04:05Z"
            }
          }
        },
        "required": [
          "role",
          "cf_instance_cert",
          "signing_time",
          "signature"
        ]
      },
      "CloudFoundryWriteConfigRequest": {
        "type": "object",
        "properties": {
          "cf_api_addr": {
            "type": "string",
            "description": "CF’s API address.",
            "x-vault-displayAttrs": {
              "name": "CF API Address",
              "value": "https://api.10.244.0.34.xip.io"
            }
          },
          "cf_api_mutual_tls_certificate": {
            "type": "string",
            "description": "The PEM-format certificates that are presented for mutual TLS with the CloudFoundry API. If not set, mutual TLS is not used",
            "x-vault-displayAttrs": {
              "name": "CF API Mutual TLS Certificate",
              "value": "-----BEGIN CERTIFICATE----- ... -----END CERTIFICATE-----"
            }
          },
          "cf_api_mutual_tls_key": {
            "type": "string",
            "description": "The PEM-format private key that are used for mutual TLS with the CloudFoundry API. If not set, mutual TLS is not used",
            "x-vault-displayAttrs": {
              "name": "CF API Mutual TLS Key",
              "value": "-----BEGIN RSA PRIVATE KEY----- ... -----END RSA PRIVATE KEY-----"
            }
          },
          "cf_api_trusted_certificates": {
            "type": "array",
            "description": "The PEM-format CA certificates that are acceptable for the CF API to present.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "CF API Trusted IdentityCACertificates",
              "value": "-----BEGIN CERTIFICATE----- ... -----END CERTIFICATE-----"
            }
          },
          "cf_client_id": {
            "type": "string",
            "description": "The client id for CF’s API.",
            "x-vault-displayAttrs": {
              "name": "CF API Client ID",
              "value": "client"
            }
          },
          "cf_client_secret": {
            "type": "string",
            "description": "The client secret for CF’s API.",
            "x-vault-displayAttrs": {
              "name": "CF API Client Secret",
              "sensitive": true
            }
          },
          "cf_password": {
            "type": "string",
            "description": "The password for CF’s API.",
            "x-vault-displayAttrs": {
              "name": "CF API Password",
              "sensitive": true
            }
          },
          "cf_username": {
            "type": "string",
            "description": "The username for CF’s API.",
            "x-vault-displayAttrs": {
              "name": "CF API Username",
              "value": "admin"
            }
          },
          "identity_ca_certificates": {
            "type": "array",
            "description": "The PEM-format CA certificates that are required to have issued the instance certificates presented for logging in.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Identity CA Certificates",
              "value": "-----BEGIN CERTIFICATE----- ... -----END CERTIFICATE-----"
            }
          },
          "login_max_seconds_not_after": {
            "type": "integer",
            "description": "Duration in seconds for the maximum acceptable length in the future a \"signing_time\" can be. Useful for clock drift. Set low to reduce the opportunity for replay attacks.",
            "default": 60,
            "x-vault-displayAttrs": {
              "name": "Login Max Seconds Ahead",
              "value": "60"
            }
          },
          "login_max_seconds_not_before": {
            "type": "integer",
            "description": "Duration in seconds for the maximum acceptable age of a \"signing_time\". Useful for clock drift. Set low to reduce the opportunity for replay attacks.",
            "format": "seconds",
            "default": 300,
            "x-vault-displayAttrs": {
              "name": "Login Max Seconds Old",
              "value": "300"
            }
          },
          "pcf_api_addr": {
            "type": "string",
            "description": "Deprecated. Please use \"cf_api_addr\".",
            "deprecated": true,
            "x-vault-displayAttrs": {
              "name": "CF API Address",
              "value": "https://api.10.244.0.34.xip.io"
            }
          },
          "pcf_api_trusted_certificates": {
            "type": "array",
            "description": "Deprecated. Please use \"cf_api_trusted_certificates\".",
            "items": {
              "type": "string"
            },
            "deprecated": true,
            "x-vault-displayAttrs": {
              "name": "CF API Trusted IdentityCACertificates",
              "value": "-----BEGIN CERTIFICATE----- ... -----END CERTIFICATE-----"
            }
          },
          "pcf_password": {
            "type": "string",
            "description": "Deprecated. Please use \"cf_password\".",
            "deprecated": true,
            "x-vault-displayAttrs": {
              "name": "CF API Password",
              "sensitive": true
            }
          },
          "pcf_username": {
            "type": "string",
            "description": "Deprecated. Please use \"cf_username\".",
            "deprecated": true,
            "x-vault-displayAttrs": {
              "name": "CF API Username",
              "value": "admin"
            }
          }
        }
      },
      "CloudFoundryWriteRoleRequest": {
        "type": "object",
        "properties": {
          "bound_application_ids": {
            "type": "array",
            "description": "Require that the client certificate presented has at least one of these app IDs.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Bound Application IDs",
              "value": "6b814521-5f08-4b1a-8c4e-fbe7c5f3a169"
            }
          },
          "bound_cidrs": {
            "type": "array",
            "description": "Use \"token_bound_cidrs\" instead. If this and \"token_bound_cidrs\" are both specified, only \"token_bound_cidrs\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "bound_instance_ids": {
            "type": "array",
            "description": "Require that the client certificate presented has at least one of these instance IDs.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Bound Instance IDs",
              "value": "8a886b31-ccf7-480d-54d8-cc28"
            }
          },
          "bound_organization_ids": {
            "type": "array",
            "description": "Require that the client certificate presented has at least one of these org IDs.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Bound Organization IDs",
              "value": "34a878d0-c2f9-4521-ba73-a9f664e82c7b"
            }
          },
          "bound_space_ids": {
            "type": "array",
            "description": "Require that the client certificate presented has at least one of these space IDs.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Bound Space IDs",
              "value": "3d2eba6b-ef19-44d5-91dd-1975b0db5cc9"
            }
          },
          "disable_ip_matching": {
            "type": "boolean",
            "description": "If set to true, disables the default behavior that logging in must be performed from an acceptable IP address described by the certificate presented.",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Disable IP Address Matching",
              "value": "false"
            }
          },
          "max_ttl": {
            "type": "integer",
            "description": "Use \"token_max_ttl\" instead. If this and \"token_max_ttl\" are both specified, only \"token_max_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "period": {
            "type": "integer",
            "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Use \"token_ttl\" instead. If this and \"token_ttl\" are both specified, only \"token_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          }
        }
      },
      "ConsulWriteAccessConfigRequest": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "Consul server address"
          },
          "ca_cert": {
            "type": "string",
            "description": "CA certificate to use when verifying Consul server certificate, must be x509 PEM encoded."
          },
          "client_cert": {
            "type": "string",
            "description": "Client certificate used for Consul's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_key."
          },
          "client_key": {
            "type": "string",
            "description": "Client key used for Consul's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_cert."
          },
          "scheme": {
            "type": "string",
            "description": "URI scheme for the Consul address",
            "default": "http"
          },
          "token": {
            "type": "string",
            "description": "Token for API calls"
          }
        }
      },
      "ConsulWriteRoleRequest": {
        "type": "object",
        "properties": {
          "consul_namespace": {
            "type": "string",
            "description": "Indicates which namespace that the token will be created within. Defaults to 'default'. Available in Consul 1.7 and above."
          },
          "consul_policies": {
            "type": "array",
            "description": "List of policies to attach to the token. Either \"consul_policies\" or \"consul_roles\" are required for Consul 1.5 and above, or just \"consul_policies\" if using Consul 1.4.",
            "items": {
              "type": "string"
            }
          },
          "consul_roles": {
            "type": "array",
            "description": "List of Consul roles to attach to the token. Either \"policies\" or \"consul_roles\" are required for Consul 1.5 and above.",
            "items": {
              "type": "string"
            }
          },
          "lease": {
            "type": "integer",
            "description": "Use \"ttl\" instead.",
            "format": "seconds",
            "deprecated": true
          },
          "local": {
            "type": "boolean",
            "description": "Indicates that the token should not be replicated globally and instead be local to the current datacenter. Available in Consul 1.4 and above."
          },
          "max_ttl": {
            "type": "integer",
            "description": "Max TTL for the Consul token created from the role.",
            "format": "seconds"
          },
          "node_identities": {
            "type": "array",
            "description": "List of Node Identities to attach to the token. Available in Consul 1.8.1 or above.",
            "items": {
              "type": "string"
            }
          },
          "partition": {
            "type": "string",
            "description": "Indicates which admin partition that the token will be created within. Defaults to 'default'. Available in Consul 1.11 and above."
          },
          "policies": {
            "type": "array",
            "description": "Use \"consul_policies\" instead.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "policy": {
            "type": "string",
            "description": "Policy document, base64 encoded. Required for 'client' tokens. Required for Consul pre-1.4.",
            "deprecated": true
          },
          "service_identities": {
            "type": "array",
            "description": "List of Service Identities to attach to the token, separated by semicolons. Available in Consul 1.5 or above.",
            "items": {
              "type": "string"
            }
          },
          "token_type": {
            "type": "string",
            "description": "Which type of token to create: 'client' or 'management'. If a 'management' token, the \"policy\", \"policies\", and \"consul_roles\" parameters are not required. Defaults to 'client'.",
            "default": "client",
            "deprecated": true
          },
          "ttl": {
            "type": "integer",
            "description": "TTL for the Consul token created from the role.",
            "format": "seconds"
          }
        }
      },
      "EntityBatchDeleteRequest": {
        "type": "object",
        "properties": {
          "entity_ids": {
            "type": "array",
            "description": "Entity IDs to delete",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "EntityLookupRequest": {
        "type": "object",
        "properties": {
          "alias_id": {
            "type": "string",
            "description": "ID of the alias."
          },
          "alias_mount_accessor": {
            "type": "string",
            "description": "Accessor of the mount to which the alias belongs to. This should be supplied in conjunction with 'alias_name'."
          },
          "alias_name": {
            "type": "string",
            "description": "Name of the alias. This should be supplied in conjunction with 'alias_mount_accessor'."
          },
          "id": {
            "type": "string",
            "description": "ID of the entity."
          },
          "name": {
            "type": "string",
            "description": "Name of the entity."
          }
        }
      },
      "EntityMergeRequest": {
        "type": "object",
        "properties": {
          "conflicting_alias_ids_to_keep": {
            "type": "array",
            "description": "Alias IDs to keep in case of conflicting aliases. Ignored if no conflicting aliases found",
            "items": {
              "type": "string"
            }
          },
          "force": {
            "type": "boolean",
            "description": "Setting this will follow the 'mine' strategy for merging MFA secrets. If there are secrets of the same type both in entities that are merged from and in entity into which all others are getting merged, secrets in the destination will be unaltered. If not set, this API will throw an error containing all the conflicts."
          },
          "from_entity_ids": {
            "type": "array",
            "description": "Entity IDs which need to get merged",
            "items": {
              "type": "string"
            }
          },
          "to_entity_id": {
            "type": "string",
            "description": "Entity ID into which all the other entities need to get merged"
          }
        }
      },
      "EntityWriteAliasByIDRequest": {
        "type": "object",
        "properties": {
          "canonical_id": {
            "type": "string",
            "description": "Entity ID to which this alias should be tied to"
          },
          "custom_metadata": {
            "type": "object",
            "description": "User provided key-value pairs",
            "format": "kvpairs"
          },
          "entity_id": {
            "type": "string",
            "description": "Entity ID to which this alias belongs to. This field is deprecated, use canonical_id."
          },
          "mount_accessor": {
            "type": "string",
            "description": "(Unused)"
          },
          "name": {
            "type": "string",
            "description": "(Unused)"
          }
        }
      },
      "EntityWriteAliasRequest": {
        "type": "object",
        "properties": {
          "canonical_id": {
            "type": "string",
            "description": "Entity ID to which this alias belongs"
          },
          "custom_metadata": {
            "type": "object",
            "description": "User provided key-value pairs",
            "format": "kvpairs"
          },
          "entity_id": {
            "type": "string",
            "description": "Entity ID to which this alias belongs. This field is deprecated, use canonical_id."
          },
          "id": {
            "type": "string",
            "description": "ID of the entity alias. If set, updates the corresponding entity alias."
          },
          "mount_accessor": {
            "type": "string",
            "description": "Mount accessor to which this alias belongs to; unused for a modify"
          },
          "name": {
            "type": "string",
            "description": "Name of the alias; unused for a modify"
          }
        }
      },
      "EntityWriteByIDRequest": {
        "type": "object",
        "properties": {
          "disabled": {
            "type": "boolean",
            "description": "If set true, tokens tied to this identity will not be able to be used (but will not be revoked)."
          },
          "metadata": {
            "type": "object",
            "description": "Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
            "format": "kvpairs"
          },
          "name": {
            "type": "string",
            "description": "Name of the entity"
          },
          "policies": {
            "type": "array",
            "description": "Policies to be tied to the entity.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "EntityWriteByNameRequest": {
        "type": "object",
        "properties": {
          "disabled": {
            "type": "boolean",
            "description": "If set true, tokens tied to this identity will not be able to be used (but will not be revoked)."
          },
          "id": {
            "type": "string",
            "description": "ID of the entity. If set, updates the corresponding existing entity."
          },
          "metadata": {
            "type": "object",
            "description": "Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
            "format": "kvpairs"
          },
          "policies": {
            "type": "array",
            "description": "Policies to be tied to the entity.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "EntityWriteRequest": {
        "type": "object",
        "properties": {
          "disabled": {
            "type": "boolean",
            "description": "If set true, tokens tied to this identity will not be able to be used (but will not be revoked)."
          },
          "id": {
            "type": "string",
            "description": "ID of the entity. If set, updates the corresponding existing entity."
          },
          "metadata": {
            "type": "object",
            "description": "Metadata to be associated with the entity. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
            "format": "kvpairs"
          },
          "name": {
            "type": "string",
            "description": "Name of the entity"
          },
          "policies": {
            "type": "array",
            "description": "Policies to be tied to the entity.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "GitHubLoginRequest": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "description": "GitHub personal API token"
          }
        }
      },
      "GitHubWriteConfigRequest": {
        "type": "object",
        "properties": {
          "base_url": {
            "type": "string",
            "description": "The API endpoint to use. Useful if you are running GitHub Enterprise or an API-compatible authentication server.",
            "x-vault-displayAttrs": {
              "name": "Base URL",
              "group": "GitHub Options"
            }
          },
          "max_ttl": {
            "type": "integer",
            "description": "Use \"token_max_ttl\" instead. If this and \"token_max_ttl\" are both specified, only \"token_max_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "organization": {
            "type": "string",
            "description": "The organization users must be part of"
          },
          "organization_id": {
            "type": "integer",
            "description": "The ID of the organization users must be part of",
            "format": "int64"
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies. This will apply to all tokens generated by this auth method, in addition to any policies configured for specific users/groups.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Use \"token_ttl\" instead. If this and \"token_ttl\" are both specified, only \"token_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          }
        },
        "required": [
          "organization"
        ]
      },
      "GitHubWriteMapTeamRequest": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "Value for teams mapping"
          }
        }
      },
      "GitHubWriteMapUserRequest": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "Value for users mapping"
          }
        }
      },
      "GoogleCloudKMSDecryptRequest": {
        "type": "object",
        "properties": {
          "additional_authenticated_data": {
            "type": "string",
            "description": "Optional data that was specified during encryption of this payload."
          },
          "ciphertext": {
            "type": "string",
            "description": "Ciphertext to decrypt as previously returned from an encrypt operation. This must be base64-encoded ciphertext as previously returned from an encrypt operation."
          },
          "key_version": {
            "type": "integer",
            "description": "Integer version of the crypto key version to use for decryption. This is required for asymmetric keys. For symmetric keys, Cloud KMS will choose the correct version automatically."
          }
        }
      },
      "GoogleCloudKMSEncryptRequest": {
        "type": "object",
        "properties": {
          "additional_authenticated_data": {
            "type": "string",
            "description": "Optional base64-encoded data that, if specified, must also be provided to decrypt this payload."
          },
          "key_version": {
            "type": "integer",
            "description": "Integer version of the crypto key version to use for encryption. If unspecified, this defaults to the latest active crypto key version."
          },
          "plaintext": {
            "type": "string",
            "description": "Plaintext value to be encrypted. This can be a string or binary, but the size is limited. See the Google Cloud KMS documentation for information on size limitations by key types."
          }
        }
      },
      "GoogleCloudKMSReencryptRequest": {
        "type": "object",
        "properties": {
          "additional_authenticated_data": {
            "type": "string",
            "description": "Optional data that, if specified, must also be provided during decryption."
          },
          "ciphertext": {
            "type": "string",
            "description": "Ciphertext to be re-encrypted to the latest key version. This must be ciphertext that Vault previously generated for this named key."
          },
          "key_version": {
            "type": "integer",
            "description": "Integer version of the crypto key version to use for the new encryption. If unspecified, this defaults to the latest active crypto key version."
          }
        }
      },
      "GoogleCloudKMSRegisterKeyRequest": {
        "type": "object",
        "properties": {
          "crypto_key": {
            "type": "string",
            "description": "Full resource ID of the crypto key including the project, location, key ring, and crypto key like \"projects/%s/locations/%s/keyRings/%s/cryptoKeys/%s\". This crypto key must already exist in Google Cloud KMS unless verify is set to \"false\"."
          },
          "verify": {
            "type": "boolean",
            "description": "Verify that the given Google Cloud KMS crypto key exists and is accessible before creating the storage entry in Vault. Set this to \"false\" if the key will not exist at creation time.",
            "default": true
          }
        }
      },
      "GoogleCloudKMSSignRequest": {
        "type": "object",
        "properties": {
          "digest": {
            "type": "string",
            "description": "Digest to sign. This digest must use the same SHA algorithm as the underlying Cloud KMS key. The digest must be the base64-encoded binary value. This field is required."
          },
          "key_version": {
            "type": "integer",
            "description": "Integer version of the crypto key version to use for signing. This field is required."
          }
        }
      },
      "GoogleCloudKMSVerifyRequest": {
        "type": "object",
        "properties": {
          "digest": {
            "type": "string",
            "description": "Digest to verify. This digest must use the same SHA algorithm as the underlying Cloud KMS key. The digest must be the base64-encoded binary value. This field is required."
          },
          "key_version": {
            "type": "integer",
            "description": "Integer version of the crypto key version to use for verification. This field is required."
          },
          "signature": {
            "type": "string",
            "description": "Base64-encoded signature to use for verification. This field is required."
          }
        }
      },
      "GoogleCloudKMSWriteConfigRequest": {
        "type": "object",
        "properties": {
          "credentials": {
            "type": "string",
            "description": "The credentials to use for authenticating to Google Cloud. Leave this blank to use the Default Application Credentials or instance metadata authentication."
          },
          "scopes": {
            "type": "array",
            "description": "The list of full-URL scopes to request when authenticating. By default, this requests https://www.googleapis.com/auth/cloudkms.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "GoogleCloudKMSWriteKeyConfigRequest": {
        "type": "object",
        "properties": {
          "max_version": {
            "type": "integer",
            "description": "Maximum allowed crypto key version. If set to a positive value, key versions greater than the given value are not permitted to be used. If set to 0 or a negative value, there is no maximum key version."
          },
          "min_version": {
            "type": "integer",
            "description": "Minimum allowed crypto key version. If set to a positive value, key versions less than the given value are not permitted to be used. If set to 0 or a negative value, there is no minimum key version. This value only affects encryption/re-encryption, not decryption. To restrict old values from being decrypted, increase this value and then perform a trim operation."
          }
        }
      },
      "GoogleCloudKMSWriteKeyRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "Algorithm to use for encryption, decryption, or signing. The value depends on the key purpose. The value cannot be changed after creation. For a key purpose of \"encrypt_decrypt\", the valid values are: - symmetric_encryption (default) For a key purpose of \"asymmetric_sign\", valid values are: - rsa_sign_pss_2048_sha256 - rsa_sign_pss_3072_sha256 - rsa_sign_pss_4096_sha256 - rsa_sign_pkcs1_2048_sha256 - rsa_sign_pkcs1_3072_sha256 - rsa_sign_pkcs1_4096_sha256 - ec_sign_p256_sha256 - ec_sign_p384_sha384 For a key purpose of \"asymmetric_decrypt\", valid values are: - rsa_decrypt_oaep_2048_sha256 - rsa_decrypt_oaep_3072_sha256 - rsa_decrypt_oaep_4096_sha256"
          },
          "crypto_key": {
            "type": "string",
            "description": "Name of the crypto key to use. If the given crypto key does not exist, Vault will try to create it. This defaults to the name of the key given to Vault as the parameter if unspecified."
          },
          "key_ring": {
            "type": "string",
            "description": "Full Google Cloud resource ID of the key ring with the project and location (e.g. projects/my-project/locations/global/keyRings/my-keyring). If the given key ring does not exist, Vault will try to create it during a create operation."
          },
          "labels": {
            "type": "object",
            "description": "Arbitrary key=value label to apply to the crypto key. To specify multiple labels, specify this argument multiple times (e.g. labels=\"a=b\" labels=\"c=d\").",
            "format": "kvpairs"
          },
          "protection_level": {
            "type": "string",
            "description": "Level of protection to use for the key management. Valid values are \"software\" and \"hsm\". The default value is \"software\". The value cannot be changed after creation."
          },
          "purpose": {
            "type": "string",
            "description": "Purpose of the key. Valid options are \"asymmetric_decrypt\", \"asymmetric_sign\", and \"encrypt_decrypt\". The default value is \"encrypt_decrypt\". The value cannot be changed after creation."
          },
          "rotation_period": {
            "type": "integer",
            "description": "Amount of time between crypto key version rotations. This is specified as a time duration value like 72h (72 hours). The smallest possible value is 24h. This value only applies to keys with a purpose of \"encrypt_decrypt\".",
            "format": "seconds"
          }
        }
      },
      "GoogleCloudLoginRequest": {
        "type": "object",
        "properties": {
          "jwt": {
            "type": "string",
            "description": "A signed JWT. This is either a self-signed service account JWT ('iam' roles only) or a GCE identity metadata token ('iam', 'gce' roles)."
          },
          "role": {
            "type": "string",
            "description": "Name of the role against which the login is being attempted. Required."
          }
        }
      },
      "GoogleCloudWriteAuthConfigRequest": {
        "type": "object",
        "properties": {
          "credentials": {
            "type": "string",
            "description": "Google credentials JSON that Vault will use to verify users against GCP APIs. If not specified, will use application default credentials",
            "x-vault-displayAttrs": {
              "name": "Credentials"
            }
          },
          "custom_endpoint": {
            "type": "object",
            "description": "Specifies overrides for various Google API Service Endpoints used in requests.",
            "format": "kvpairs"
          },
          "gce_alias": {
            "type": "string",
            "description": "Indicates what value to use when generating an alias for GCE authentications.",
            "default": "role_id"
          },
          "gce_metadata": {
            "type": "array",
            "description": "The metadata to include on the aliases and audit logs generated by this plugin. When set to 'default', includes: instance_creation_timestamp, instance_id, instance_name, project_id, project_number, role, service_account_id, service_account_email, zone. Not editing this field means the 'default' fields are included. Explicitly setting this field to empty overrides the 'default' and means no metadata will be included. If not using 'default', explicit fields must be sent like: 'field1,field2'.",
            "items": {
              "type": "string"
            },
            "default": [
              "default"
            ],
            "x-vault-displayAttrs": {
              "name": "gce_metadata",
              "value": "field1,field2"
            }
          },
          "google_certs_endpoint": {
            "type": "string",
            "description": "Deprecated. This field does nothing and be removed in a future release",
            "deprecated": true
          },
          "iam_alias": {
            "type": "string",
            "description": "Indicates what value to use when generating an alias for IAM authentications.",
            "default": "role_id"
          },
          "iam_metadata": {
            "type": "array",
            "description": "The metadata to include on the aliases and audit logs generated by this plugin. When set to 'default', includes: project_id, role, service_account_id, service_account_email. Not editing this field means the 'default' fields are included. Explicitly setting this field to empty overrides the 'default' and means no metadata will be included. If not using 'default', explicit fields must be sent like: 'field1,field2'.",
            "items": {
              "type": "string"
            },
            "default": [
              "default"
            ],
            "x-vault-displayAttrs": {
              "name": "iam_metadata",
              "value": "field1,field2"
            }
          }
        }
      },
      "GoogleCloudWriteConfigRequest": {
        "type": "object",
        "properties": {
          "credentials": {
            "type": "string",
            "description": "GCP IAM service account credentials JSON with permissions to create new service accounts and set IAM policies"
          },
          "max_ttl": {
            "type": "integer",
            "description": "Maximum time a service account key is valid for. If <= 0, will use system default.",
            "format": "seconds"
          },
          "ttl": {
            "type": "integer",
            "description": "Default lease for generated keys. If <= 0, will use system default.",
            "format": "seconds"
          }
        }
      },
      "GoogleCloudWriteKeyRequest": {
        "type": "object",
        "properties": {
          "key_algorithm": {
            "type": "string",
            "description": "Private key algorithm for service account key - defaults to KEY_ALG_RSA_2048\"",
            "default": "KEY_ALG_RSA_2048"
          },
          "key_type": {
            "type": "string",
            "description": "Private key type for service account key - defaults to TYPE_GOOGLE_CREDENTIALS_FILE\"",
            "default": "TYPE_GOOGLE_CREDENTIALS_FILE"
          },
          "ttl": {
            "type": "integer",
            "description": "Lifetime of the service account key",
            "format": "seconds"
          }
        }
      },
      "GoogleCloudWriteRoleLabelsRequest": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "description": "BoundLabels to add (in $key:$value)",
            "items": {
              "type": "string"
            }
          },
          "remove": {
            "type": "array",
            "description": "Label key values to remove",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "GoogleCloudWriteRoleRequest": {
        "type": "object",
        "properties": {
          "add_group_aliases": {
            "type": "boolean",
            "description": "If true, will add group aliases to auth tokens generated under this role. This will add the full list of ancestors (projects, folders, organizations) for the given entity's project. Requires IAM permission `resourcemanager.projects.get` on this project.",
            "default": false
          },
          "allow_gce_inference": {
            "type": "boolean",
            "description": "'iam' roles only. If false, Vault will not not allow GCE instances to login in against this role",
            "default": true
          },
          "bound_instance_group": {
            "type": "string",
            "description": "Deprecated: use \"bound_instance_groups\" instead."
          },
          "bound_instance_groups": {
            "type": "array",
            "description": "Comma-separated list of permitted instance groups to which the GCE instance must belong. This option only applies to \"gce\" roles.",
            "items": {
              "type": "string"
            }
          },
          "bound_labels": {
            "type": "array",
            "description": "Comma-separated list of GCP labels formatted as\"key:value\" strings that must be present on the GCE instance in order to authenticate. This option only applies to \"gce\" roles.",
            "items": {
              "type": "string"
            }
          },
          "bound_projects": {
            "type": "array",
            "description": "GCP Projects that authenticating entities must belong to.",
            "items": {
              "type": "string"
            }
          },
          "bound_region": {
            "type": "string",
            "description": "Deprecated: use \"bound_regions\" instead."
          },
          "bound_regions": {
            "type": "array",
            "description": "Comma-separated list of permitted regions to which the GCE instance must belong. If a group is provided, it is assumed to be a regional group. If \"zone\" is provided, this option is ignored. This can be a self-link or region name. This option only applies to \"gce\" roles.",
            "items": {
              "type": "string"
            }
          },
          "bound_service_accounts": {
            "type": "array",
            "description": "Can be set for both 'iam' and 'gce' roles (required for 'iam'). A comma-seperated list of authorized service accounts. If the single value \"*\" is given, this is assumed to be all service accounts under the role's project. If this is set on a GCE role, the inferred service account from the instance metadata token will be used.",
            "items": {
              "type": "string"
            }
          },
          "bound_zone": {
            "type": "string",
            "description": "Deprecated: use \"bound_zones\" instead."
          },
          "bound_zones": {
            "type": "array",
            "description": "Comma-separated list of permitted zones to which the GCE instance must belong. If a group is provided, it is assumed to be a zonal group. This can be a self-link or zone name. This option only applies to \"gce\" roles.",
            "items": {
              "type": "string"
            }
          },
          "max_jwt_exp": {
            "type": "integer",
            "description": "Currently enabled for 'iam' only. Duration in seconds from time of validation that a JWT must expire within.",
            "format": "seconds",
            "default": 900
          },
          "max_ttl": {
            "type": "integer",
            "description": "Use \"token_max_ttl\" instead. If this and \"token_max_ttl\" are both specified, only \"token_max_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "period": {
            "type": "integer",
            "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "project_id": {
            "type": "string",
            "description": "Deprecated: use \"bound_projects\" instead"
          },
          "service_accounts": {
            "type": "array",
            "description": "Deprecated: use \"bound_service_accounts\" instead.",
            "items": {
              "type": "string"
            }
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Use \"token_ttl\" instead. If this and \"token_ttl\" are both specified, only \"token_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "type": {
            "type": "string",
            "description": "Type of the role. Currently supported: iam, gce"
          }
        }
      },
      "GoogleCloudWriteRoleServiceAccountsRequest": {
        "type": "object",
        "properties": {
          "add": {
            "type": "array",
            "description": "Service-account emails or IDs to add.",
            "items": {
              "type": "string"
            }
          },
          "remove": {
            "type": "array",
            "description": "Service-account emails or IDs to remove.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "GoogleCloudWriteRolesetKeyRequest": {
        "type": "object",
        "properties": {
          "key_algorithm": {
            "type": "string",
            "description": "Private key algorithm for service account key - defaults to KEY_ALG_RSA_2048\"",
            "default": "KEY_ALG_RSA_2048"
          },
          "key_type": {
            "type": "string",
            "description": "Private key type for service account key - defaults to TYPE_GOOGLE_CREDENTIALS_FILE\"",
            "default": "TYPE_GOOGLE_CREDENTIALS_FILE"
          },
          "ttl": {
            "type": "integer",
            "description": "Lifetime of the service account key",
            "format": "seconds"
          }
        }
      },
      "GoogleCloudWriteRolesetRequest": {
        "type": "object",
        "properties": {
          "bindings": {
            "type": "string",
            "description": "Bindings configuration string."
          },
          "project": {
            "type": "string",
            "description": "Name of the GCP project that this roleset's service account will belong to."
          },
          "secret_type": {
            "type": "string",
            "description": "Type of secret generated for this role set. Defaults to 'access_token'",
            "default": "access_token"
          },
          "token_scopes": {
            "type": "array",
            "description": "List of OAuth scopes to assign to credentials generated under this role set",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "GoogleCloudWriteStaticAccountKeyRequest": {
        "type": "object",
        "properties": {
          "key_algorithm": {
            "type": "string",
            "description": "Private key algorithm for service account key. Defaults to KEY_ALG_RSA_2048.\"",
            "default": "KEY_ALG_RSA_2048"
          },
          "key_type": {
            "type": "string",
            "description": "Private key type for service account key. Defaults to TYPE_GOOGLE_CREDENTIALS_FILE.\"",
            "default": "TYPE_GOOGLE_CREDENTIALS_FILE"
          },
          "ttl": {
            "type": "integer",
            "description": "Lifetime of the service account key",
            "format": "seconds"
          }
        }
      },
      "GoogleCloudWriteStaticAccountRequest": {
        "type": "object",
        "properties": {
          "bindings": {
            "type": "string",
            "description": "Bindings configuration string."
          },
          "secret_type": {
            "type": "string",
            "description": "Type of secret generated for this account. Cannot be updated. Defaults to \"access_token\"",
            "default": "access_token"
          },
          "service_account_email": {
            "type": "string",
            "description": "Required. Email of the GCP service account to manage. Cannot be updated."
          },
          "token_scopes": {
            "type": "array",
            "description": "List of OAuth scopes to assign to access tokens generated under this account. Ignored if \"secret_type\" is not \"\"access_token\"\"",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "GroupLookupRequest": {
        "type": "object",
        "properties": {
          "alias_id": {
            "type": "string",
            "description": "ID of the alias."
          },
          "alias_mount_accessor": {
            "type": "string",
            "description": "Accessor of the mount to which the alias belongs to. This should be supplied in conjunction with 'alias_name'."
          },
          "alias_name": {
            "type": "string",
            "description": "Name of the alias. This should be supplied in conjunction with 'alias_mount_accessor'."
          },
          "id": {
            "type": "string",
            "description": "ID of the group."
          },
          "name": {
            "type": "string",
            "description": "Name of the group."
          }
        }
      },
      "GroupWriteAliasByIDRequest": {
        "type": "object",
        "properties": {
          "canonical_id": {
            "type": "string",
            "description": "ID of the group to which this is an alias."
          },
          "mount_accessor": {
            "type": "string",
            "description": "Mount accessor to which this alias belongs to."
          },
          "name": {
            "type": "string",
            "description": "Alias of the group."
          }
        }
      },
      "GroupWriteAliasRequest": {
        "type": "object",
        "properties": {
          "canonical_id": {
            "type": "string",
            "description": "ID of the group to which this is an alias."
          },
          "id": {
            "type": "string",
            "description": "ID of the group alias."
          },
          "mount_accessor": {
            "type": "string",
            "description": "Mount accessor to which this alias belongs to."
          },
          "name": {
            "type": "string",
            "description": "Alias of the group."
          }
        }
      },
      "GroupWriteByIDRequest": {
        "type": "object",
        "properties": {
          "member_entity_ids": {
            "type": "array",
            "description": "Entity IDs to be assigned as group members.",
            "items": {
              "type": "string"
            }
          },
          "member_group_ids": {
            "type": "array",
            "description": "Group IDs to be assigned as group members.",
            "items": {
              "type": "string"
            }
          },
          "metadata": {
            "type": "object",
            "description": "Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
            "format": "kvpairs"
          },
          "name": {
            "type": "string",
            "description": "Name of the group."
          },
          "policies": {
            "type": "array",
            "description": "Policies to be tied to the group.",
            "items": {
              "type": "string"
            }
          },
          "type": {
            "type": "string",
            "description": "Type of the group, 'internal' or 'external'. Defaults to 'internal'"
          }
        }
      },
      "GroupWriteByNameRequest": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "ID of the group. If set, updates the corresponding existing group."
          },
          "member_entity_ids": {
            "type": "array",
            "description": "Entity IDs to be assigned as group members.",
            "items": {
              "type": "string"
            }
          },
          "member_group_ids": {
            "type": "array",
            "description": "Group IDs to be assigned as group members.",
            "items": {
              "type": "string"
            }
          },
          "metadata": {
            "type": "object",
            "description": "Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
            "format": "kvpairs"
          },
          "policies": {
            "type": "array",
            "description": "Policies to be tied to the group.",
            "items": {
              "type": "string"
            }
          },
          "type": {
            "type": "string",
            "description": "Type of the group, 'internal' or 'external'. Defaults to 'internal'"
          }
        }
      },
      "GroupWriteRequest": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "ID of the group. If set, updates the corresponding existing group."
          },
          "member_entity_ids": {
            "type": "array",
            "description": "Entity IDs to be assigned as group members.",
            "items": {
              "type": "string"
            }
          },
          "member_group_ids": {
            "type": "array",
            "description": "Group IDs to be assigned as group members.",
            "items": {
              "type": "string"
            }
          },
          "metadata": {
            "type": "object",
            "description": "Metadata to be associated with the group. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
            "format": "kvpairs"
          },
          "name": {
            "type": "string",
            "description": "Name of the group."
          },
          "policies": {
            "type": "array",
            "description": "Policies to be tied to the group.",
            "items": {
              "type": "string"
            }
          },
          "type": {
            "type": "string",
            "description": "Type of the group, 'internal' or 'external'. Defaults to 'internal'"
          }
        }
      },
      "JWTLoginRequest": {
        "type": "object",
        "properties": {
          "jwt": {
            "type": "string",
            "description": "The signed JWT to validate."
          },
          "role": {
            "type": "string",
            "description": "The role to log in against.",
            "format": "lowercase"
          }
        }
      },
      "JWTWriteConfigRequest": {
        "type": "object",
        "properties": {
          "bound_issuer": {
            "type": "string",
            "description": "The value against which to match the 'iss' claim in a JWT. Optional."
          },
          "default_role": {
            "type": "string",
            "description": "The default role to use if none is provided during login. If not set, a role is required during login.",
            "format": "lowercase"
          },
          "jwks_ca_pem": {
            "type": "string",
            "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used."
          },
          "jwks_url": {
            "type": "string",
            "description": "JWKS URL to use to authenticate signatures. Cannot be used with \"oidc_discovery_url\" or \"jwt_validation_pubkeys\"."
          },
          "jwt_supported_algs": {
            "type": "array",
            "description": "A list of supported signing algorithms. Defaults to RS256.",
            "items": {
              "type": "string"
            }
          },
          "jwt_validation_pubkeys": {
            "type": "array",
            "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used with \"jwks_url\" or \"oidc_discovery_url\".",
            "items": {
              "type": "string"
            }
          },
          "namespace_in_state": {
            "type": "boolean",
            "description": "Pass namespace in the OIDC state parameter instead of as a separate query parameter. With this setting, the allowed redirect URL(s) in Vault and on the provider side should not contain a namespace query parameter. This means only one redirect URL entry needs to be maintained on the provider side for all vault namespaces that will be authenticating against it. Defaults to true for new configs.",
            "x-vault-displayAttrs": {
              "name": "Namespace in OIDC state",
              "value": true
            }
          },
          "oidc_client_id": {
            "type": "string",
            "description": "The OAuth Client ID configured with your OIDC provider."
          },
          "oidc_client_secret": {
            "type": "string",
            "description": "The OAuth Client Secret configured with your OIDC provider.",
            "x-vault-displayAttrs": {
              "sensitive": true
            }
          },
          "oidc_discovery_ca_pem": {
            "type": "string",
            "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used."
          },
          "oidc_discovery_url": {
            "type": "string",
            "description": "OIDC Discovery URL, without any .well-known component (base path). Cannot be used with \"jwks_url\" or \"jwt_validation_pubkeys\"."
          },
          "oidc_response_mode": {
            "type": "string",
            "description": "The response mode to be used in the OAuth2 request. Allowed values are 'query' and 'form_post'."
          },
          "oidc_response_types": {
            "type": "array",
            "description": "The response types to request. Allowed values are 'code' and 'id_token'. Defaults to 'code'.",
            "items": {
              "type": "string"
            }
          },
          "provider_config": {
            "type": "object",
            "description": "Provider-specific configuration. Optional.",
            "format": "map",
            "x-vault-displayAttrs": {
              "name": "Provider Config"
            }
          }
        }
      },
      "JWTWriteOIDCAuthURLRequest": {
        "type": "object",
        "properties": {
          "client_nonce": {
            "type": "string",
            "description": "Optional client-provided nonce that must match during callback, if present."
          },
          "redirect_uri": {
            "type": "string",
            "description": "The OAuth redirect_uri to use in the authorization URL."
          },
          "role": {
            "type": "string",
            "description": "The role to issue an OIDC authorization URL against.",
            "format": "lowercase"
          }
        }
      },
      "JWTWriteOIDCCallbackRequest": {
        "type": "object",
        "properties": {
          "client_nonce": {
            "type": "string"
          },
          "code": {
            "type": "string"
          },
          "id_token": {
            "type": "string"
          },
          "state": {
            "type": "string"
          }
        }
      },
      "JWTWriteRoleRequest": {
        "type": "object",
        "properties": {
          "allowed_redirect_uris": {
            "type": "array",
            "description": "Comma-separated list of allowed values for redirect_uri",
            "items": {
              "type": "string"
            }
          },
          "bound_audiences": {
            "type": "array",
            "description": "Comma-separated list of 'aud' claims that are valid for login; any match is sufficient",
            "items": {
              "type": "string"
            }
          },
          "bound_cidrs": {
            "type": "array",
            "description": "Use \"token_bound_cidrs\" instead. If this and \"token_bound_cidrs\" are both specified, only \"token_bound_cidrs\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "bound_claims": {
            "type": "object",
            "description": "Map of claims/values which must match for login",
            "format": "map"
          },
          "bound_claims_type": {
            "type": "string",
            "description": "How to interpret values in the map of claims/values (which must match for login): allowed values are 'string' or 'glob'",
            "default": "string"
          },
          "bound_subject": {
            "type": "string",
            "description": "The 'sub' claim that is valid for login. Optional."
          },
          "claim_mappings": {
            "type": "object",
            "description": "Mappings of claims (key) that will be copied to a metadata field (value)",
            "format": "kvpairs"
          },
          "clock_skew_leeway": {
            "type": "integer",
            "description": "Duration in seconds of leeway when validating all claims to account for clock skew. Defaults to 60 (1 minute) if set to 0 and can be disabled if set to -1.",
            "format": "seconds",
            "default": 60000000000
          },
          "expiration_leeway": {
            "type": "integer",
            "description": "Duration in seconds of leeway when validating expiration of a token to account for clock skew. Defaults to 150 (2.5 minutes) if set to 0 and can be disabled if set to -1.",
            "format": "seconds",
            "default": 150
          },
          "groups_claim": {
            "type": "string",
            "description": "The claim to use for the Identity group alias names"
          },
          "max_age": {
            "type": "integer",
            "description": "Specifies the allowable elapsed time in seconds since the last time the user was actively authenticated.",
            "format": "seconds"
          },
          "max_ttl": {
            "type": "integer",
            "description": "Use \"token_max_ttl\" instead. If this and \"token_max_ttl\" are both specified, only \"token_max_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "not_before_leeway": {
            "type": "integer",
            "description": "Duration in seconds of leeway when validating not before values of a token to account for clock skew. Defaults to 150 (2.5 minutes) if set to 0 and can be disabled if set to -1.",
            "format": "seconds",
            "default": 150
          },
          "num_uses": {
            "type": "integer",
            "description": "Use \"token_num_uses\" instead. If this and \"token_num_uses\" are both specified, only \"token_num_uses\" will be used.",
            "deprecated": true
          },
          "oidc_scopes": {
            "type": "array",
            "description": "Comma-separated list of OIDC scopes",
            "items": {
              "type": "string"
            }
          },
          "period": {
            "type": "integer",
            "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "role_type": {
            "type": "string",
            "description": "Type of the role, either 'jwt' or 'oidc'."
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Use \"token_ttl\" instead. If this and \"token_ttl\" are both specified, only \"token_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "user_claim": {
            "type": "string",
            "description": "The claim to use for the Identity entity alias name"
          },
          "user_claim_json_pointer": {
            "type": "boolean",
            "description": "If true, the user_claim value will use JSON pointer syntax for referencing claims."
          },
          "verbose_oidc_logging": {
            "type": "boolean",
            "description": "Log received OIDC tokens and claims when debug-level logging is active. Not recommended in production since sensitive information may be present in OIDC responses."
          }
        }
      },
      "KVv2DeleteVersionsRequest": {
        "type": "object",
        "properties": {
          "versions": {
            "type": "array",
            "description": "The versions to be archived. The versioned data will not be deleted, but it will no longer be returned in normal get requests.",
            "items": {
              "type": "integer"
            }
          }
        }
      },
      "KVv2DestroyVersionsRequest": {
        "type": "object",
        "properties": {
          "versions": {
            "type": "array",
            "description": "The versions to destroy. Their data will be permanently deleted.",
            "items": {
              "type": "integer"
            }
          }
        }
      },
      "KVv2UndeleteVersionsRequest": {
        "type": "object",
        "properties": {
          "versions": {
            "type": "array",
            "description": "The versions to unarchive. The versions will be restored and their data will be returned on normal get requests.",
            "items": {
              "type": "integer"
            }
          }
        }
      },
      "KVv2WriteConfigRequest": {
        "type": "object",
        "properties": {
          "cas_required": {
            "type": "boolean",
            "description": "If true, the backend will require the cas parameter to be set for each write"
          },
          "delete_version_after": {
            "type": "integer",
            "description": "If set, the length of time before a version is deleted. A negative duration disables the use of delete_version_after on all keys. A zero duration clears the current setting. Accepts a Go duration format string.",
            "format": "seconds"
          },
          "max_versions": {
            "type": "integer",
            "description": "The number of versions to keep for each key. Defaults to 10"
          }
        }
      },
      "KVv2WriteMetadataRequest": {
        "type": "object",
        "properties": {
          "cas_required": {
            "type": "boolean",
            "description": "If true the key will require the cas parameter to be set on all write requests. If false, the backend’s configuration will be used."
          },
          "custom_metadata": {
            "type": "object",
            "description": "User-provided key-value pairs that are used to describe arbitrary and version-agnostic information about a secret.",
            "format": "map"
          },
          "delete_version_after": {
            "type": "integer",
            "description": "The length of time before a version is deleted. If not set, the backend's configured delete_version_after is used. Cannot be greater than the backend's delete_version_after. A zero duration clears the current setting. A negative duration will cause an error.",
            "format": "seconds"
          },
          "max_versions": {
            "type": "integer",
            "description": "The number of versions to keep. If not set, the backend’s configured max version is used."
          }
        }
      },
      "KVv2WriteRequest": {
        "type": "object",
        "properties": {
          "data": {
            "type": "object",
            "description": "The contents of the data map will be stored and returned on read.",
            "format": "map"
          },
          "options": {
            "type": "object",
            "description": "Options for writing a KV entry. Set the \"cas\" value to use a Check-And-Set operation. If not set the write will be allowed. If set to 0 a write will only be allowed if the key doesn’t exist. If the index is non-zero the write will only be allowed if the key’s current version matches the version specified in the cas parameter.",
            "format": "map"
          },
          "version": {
            "type": "integer",
            "description": "If provided during a read, the value at the version number will be returned"
          }
        }
      },
      "KerberosLoginRequest": {
        "type": "object",
        "properties": {
          "authorization": {
            "type": "string",
            "description": "SPNEGO Authorization header. Required."
          }
        }
      },
      "KerberosWriteConfigRequest": {
        "type": "object",
        "properties": {
          "add_group_aliases": {
            "type": "boolean",
            "description": "If set to true, returns any groups found in LDAP as a group alias."
          },
          "keytab": {
            "type": "string",
            "description": "Base64 encoded keytab",
            "x-vault-displayAttrs": {
              "sensitive": true
            }
          },
          "remove_instance_name": {
            "type": "boolean",
            "description": "Remove instance/FQDN from keytab principal names."
          },
          "service_account": {
            "type": "string",
            "description": "Service Account"
          }
        }
      },
      "KerberosWriteGroupRequest": {
        "type": "object",
        "properties": {
          "policies": {
            "type": "array",
            "description": "Comma-separated list of policies associated to the group.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "KerberosWriteLDAPConfigRequest": {
        "type": "object",
        "properties": {
          "anonymous_group_search": {
            "type": "boolean",
            "description": "Use anonymous binds when performing LDAP group searches (if true the initial credentials will still be used for the initial connection test).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Anonymous group search"
            }
          },
          "binddn": {
            "type": "string",
            "description": "LDAP DN for searching for the user DN (optional)",
            "x-vault-displayAttrs": {
              "name": "Name of Object to bind (binddn)"
            }
          },
          "bindpass": {
            "type": "string",
            "description": "LDAP password for searching for the user DN (optional)",
            "x-vault-displayAttrs": {
              "sensitive": true
            }
          },
          "case_sensitive_names": {
            "type": "boolean",
            "description": "If true, case sensitivity will be used when comparing usernames and groups for matching policies."
          },
          "certificate": {
            "type": "string",
            "description": "CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "CA certificate",
              "editType": "file"
            }
          },
          "client_tls_cert": {
            "type": "string",
            "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "Client certificate",
              "editType": "file"
            }
          },
          "client_tls_key": {
            "type": "string",
            "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "Client key",
              "editType": "file"
            }
          },
          "deny_null_bind": {
            "type": "boolean",
            "description": "Denies an unauthenticated LDAP bind request if the user's password is empty; defaults to true",
            "default": true
          },
          "discoverdn": {
            "type": "boolean",
            "description": "Use anonymous bind to discover the bind DN of a user (optional)",
            "x-vault-displayAttrs": {
              "name": "Discover DN"
            }
          },
          "groupattr": {
            "type": "string",
            "description": "LDAP attribute to follow on objects returned by <groupfilter> in order to enumerate user group membership. Examples: \"cn\" or \"memberOf\", etc. Default: cn",
            "default": "cn",
            "x-vault-displayAttrs": {
              "name": "Group Attribute",
              "value": "cn"
            }
          },
          "groupdn": {
            "type": "string",
            "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org)",
            "x-vault-displayAttrs": {
              "name": "Group DN"
            }
          },
          "groupfilter": {
            "type": "string",
            "description": "Go template for querying group membership of user (optional) The template can access the following context variables: UserDN, Username Example: (&(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})) Default: (|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))",
            "default": "(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))",
            "x-vault-displayAttrs": {
              "name": "Group Filter"
            }
          },
          "insecure_tls": {
            "type": "boolean",
            "description": "Skip LDAP server SSL Certificate verification - VERY insecure (optional)",
            "x-vault-displayAttrs": {
              "name": "Insecure TLS"
            }
          },
          "request_timeout": {
            "type": "integer",
            "description": "Timeout, in seconds, for the connection when making requests against the server before returning back an error.",
            "format": "seconds",
            "default": "90s"
          },
          "starttls": {
            "type": "boolean",
            "description": "Issue a StartTLS command after establishing unencrypted connection (optional)",
            "x-vault-displayAttrs": {
              "name": "Issue StartTLS"
            }
          },
          "tls_max_version": {
            "type": "string",
            "description": "Maximum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'",
            "enum": [
              "tls10",
              "tls11",
              "tls12",
              "tls13"
            ],
            "default": "tls12",
            "x-vault-displayAttrs": {
              "name": "Maximum TLS Version"
            }
          },
          "tls_min_version": {
            "type": "string",
            "description": "Minimum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'",
            "enum": [
              "tls10",
              "tls11",
              "tls12",
              "tls13"
            ],
            "default": "tls12",
            "x-vault-displayAttrs": {
              "name": "Minimum TLS Version"
            }
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies. This will apply to all tokens generated by this auth method, in addition to any configured for specific users/groups.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "upndomain": {
            "type": "string",
            "description": "Enables userPrincipalDomain login with [username]@UPNDomain (optional)",
            "x-vault-displayAttrs": {
              "name": "User Principal (UPN) Domain"
            }
          },
          "url": {
            "type": "string",
            "description": "LDAP URL to connect to (default: ldap://127.0.0.1). Multiple URLs can be specified by concatenating them with commas; they will be tried in-order.",
            "default": "ldap://127.0.0.1",
            "x-vault-displayAttrs": {
              "name": "URL"
            }
          },
          "use_pre111_group_cn_behavior": {
            "type": "boolean",
            "description": "In Vault 1.1.1 a fix for handling group CN values of different cases unfortunately introduced a regression that could cause previously defined groups to not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for matching group CNs will be used. This is only needed in some upgrade scenarios for backwards compatibility. It is enabled by default if the config is upgraded but disabled by default on new configurations."
          },
          "use_token_groups": {
            "type": "boolean",
            "description": "If true, use the Active Directory tokenGroups constructed attribute of the user to find the group memberships. This will find all security groups including nested ones.",
            "default": false
          },
          "userattr": {
            "type": "string",
            "description": "Attribute used for users (default: cn)",
            "default": "cn",
            "x-vault-displayAttrs": {
              "name": "User Attribute",
              "value": "cn"
            }
          },
          "userdn": {
            "type": "string",
            "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)",
            "x-vault-displayAttrs": {
              "name": "User DN"
            }
          },
          "userfilter": {
            "type": "string",
            "description": "Go template for LDAP user search filer (optional) The template can access the following context variables: UserAttr, Username Default: ({{.UserAttr}}={{.Username}})",
            "default": "({{.UserAttr}}={{.Username}})",
            "x-vault-displayAttrs": {
              "name": "User Search Filter"
            }
          },
          "username_as_alias": {
            "type": "boolean",
            "description": "If true, sets the alias name to the username",
            "default": false
          }
        }
      },
      "KubernetesLoginRequest": {
        "type": "object",
        "properties": {
          "jwt": {
            "type": "string",
            "description": "A signed JWT for authenticating a service account. This field is required."
          },
          "role": {
            "type": "string",
            "description": "Name of the role against which the login is being attempted. This field is required"
          }
        }
      },
      "KubernetesWriteAuthConfigRequest": {
        "type": "object",
        "properties": {
          "disable_iss_validation": {
            "type": "boolean",
            "description": "Disable JWT issuer validation (Deprecated, will be removed in a future release)",
            "default": true,
            "deprecated": true,
            "x-vault-displayAttrs": {
              "name": "Disable JWT Issuer Validation"
            }
          },
          "disable_local_ca_jwt": {
            "type": "boolean",
            "description": "Disable defaulting to the local CA cert and service account JWT when running in a Kubernetes pod",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Disable use of local CA and service account JWT"
            }
          },
          "issuer": {
            "type": "string",
            "description": "Optional JWT issuer. If no issuer is specified, then this plugin will use kubernetes.io/serviceaccount as the default issuer. (Deprecated, will be removed in a future release)",
            "deprecated": true,
            "x-vault-displayAttrs": {
              "name": "JWT Issuer"
            }
          },
          "kubernetes_ca_cert": {
            "type": "string",
            "description": "PEM encoded CA cert for use by the TLS client used to talk with the API.",
            "x-vault-displayAttrs": {
              "name": "Kubernetes CA Certificate"
            }
          },
          "kubernetes_host": {
            "type": "string",
            "description": "Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server."
          },
          "pem_keys": {
            "type": "array",
            "description": "Optional list of PEM-formated public keys or certificates used to verify the signatures of kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Service account verification keys"
            }
          },
          "token_reviewer_jwt": {
            "type": "string",
            "description": "A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.",
            "x-vault-displayAttrs": {
              "name": "Token Reviewer JWT"
            }
          }
        }
      },
      "KubernetesWriteAuthRoleRequest": {
        "type": "object",
        "properties": {
          "alias_name_source": {
            "type": "string",
            "description": "Source to use when deriving the Alias name. valid choices: \"serviceaccount_uid\" : <token.uid> e.g. 474b11b5-0f20-4f9d-8ca5-65715ab325e0 (most secure choice) \"serviceaccount_name\" : <namespace>/<serviceaccount> e.g. vault/vault-agent default: \"serviceaccount_uid\"",
            "default": "serviceaccount_uid"
          },
          "audience": {
            "type": "string",
            "description": "Optional Audience claim to verify in the jwt."
          },
          "bound_cidrs": {
            "type": "array",
            "description": "Use \"token_bound_cidrs\" instead. If this and \"token_bound_cidrs\" are both specified, only \"token_bound_cidrs\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "bound_service_account_names": {
            "type": "array",
            "description": "List of service account names able to access this role. If set to \"*\" all names are allowed.",
            "items": {
              "type": "string"
            }
          },
          "bound_service_account_namespaces": {
            "type": "array",
            "description": "List of namespaces allowed to access this role. If set to \"*\" all namespaces are allowed.",
            "items": {
              "type": "string"
            }
          },
          "max_ttl": {
            "type": "integer",
            "description": "Use \"token_max_ttl\" instead. If this and \"token_max_ttl\" are both specified, only \"token_max_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "num_uses": {
            "type": "integer",
            "description": "Use \"token_num_uses\" instead. If this and \"token_num_uses\" are both specified, only \"token_num_uses\" will be used.",
            "deprecated": true
          },
          "period": {
            "type": "integer",
            "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Use \"token_ttl\" instead. If this and \"token_ttl\" are both specified, only \"token_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          }
        }
      },
      "KubernetesWriteConfigRequest": {
        "type": "object",
        "properties": {
          "disable_local_ca_jwt": {
            "type": "boolean",
            "description": "Disable defaulting to the local CA certificate and service account JWT when running in a Kubernetes pod.",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Disable use of local CA and service account JWT"
            }
          },
          "kubernetes_ca_cert": {
            "type": "string",
            "description": "PEM encoded CA certificate to use to verify the Kubernetes API server certificate. Defaults to the local pod's CA if found.",
            "x-vault-displayAttrs": {
              "name": "Kubernetes CA Certificate"
            }
          },
          "kubernetes_host": {
            "type": "string",
            "description": "Kubernetes API URL to connect to. Defaults to https://$KUBERNETES_SERVICE_HOST:KUBERNETES_SERVICE_PORT if those environment variables are set.",
            "x-vault-displayAttrs": {
              "name": "Kubernetes API URL"
            }
          },
          "service_account_jwt": {
            "type": "string",
            "description": "The JSON web token of the service account used by the secret engine to manage Kubernetes credentials. Defaults to the local pod's JWT if found.",
            "x-vault-displayAttrs": {
              "name": "Kubernetes API JWT"
            }
          }
        }
      },
      "KubernetesWriteCredentialsRequest": {
        "type": "object",
        "properties": {
          "cluster_role_binding": {
            "type": "boolean",
            "description": "If true, generate a ClusterRoleBinding to grant permissions across the whole cluster instead of within a namespace. Requires the Vault role to have kubernetes_role_type set to ClusterRole."
          },
          "kubernetes_namespace": {
            "type": "string",
            "description": "The name of the Kubernetes namespace in which to generate the credentials"
          },
          "ttl": {
            "type": "integer",
            "description": "The TTL of the generated credentials",
            "format": "seconds"
          }
        },
        "required": [
          "kubernetes_namespace"
        ]
      },
      "KubernetesWriteRoleRequest": {
        "type": "object",
        "properties": {
          "allowed_kubernetes_namespace_selector": {
            "type": "string",
            "description": "A label selector for Kubernetes namespaces in which credentials can be generated. Accepts either a JSON or YAML object. If set with allowed_kubernetes_namespaces, the conditions are conjuncted."
          },
          "allowed_kubernetes_namespaces": {
            "type": "array",
            "description": "A list of the Kubernetes namespaces in which credentials can be generated. If set to \"*\" all namespaces are allowed.",
            "items": {
              "type": "string"
            }
          },
          "extra_annotations": {
            "type": "object",
            "description": "Additional annotations to apply to all generated Kubernetes objects.",
            "format": "kvpairs"
          },
          "extra_labels": {
            "type": "object",
            "description": "Additional labels to apply to all generated Kubernetes objects.",
            "format": "kvpairs"
          },
          "generated_role_rules": {
            "type": "string",
            "description": "The Role or ClusterRole rules to use when generating a role. Accepts either a JSON or YAML object. If set, the entire chain of Kubernetes objects will be generated."
          },
          "kubernetes_role_name": {
            "type": "string",
            "description": "The pre-existing Role or ClusterRole to bind a generated service account to. If set, Kubernetes token, service account, and role binding objects will be created."
          },
          "kubernetes_role_type": {
            "type": "string",
            "description": "Specifies whether the Kubernetes role is a Role or ClusterRole.",
            "default": "Role"
          },
          "name_template": {
            "type": "string",
            "description": "The name template to use when generating service accounts, roles and role bindings. If unset, a default template is used."
          },
          "service_account_name": {
            "type": "string",
            "description": "The pre-existing service account to generate tokens for. Mutually exclusive with all role parameters. If set, only a Kubernetes service account token will be created."
          },
          "token_default_ttl": {
            "type": "integer",
            "description": "The default ttl for generated Kubernetes service account tokens. If not set or set to 0, will use system default.",
            "format": "seconds"
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum ttl for generated Kubernetes service account tokens. If not set or set to 0, will use system default.",
            "format": "seconds"
          }
        }
      },
      "LDAPCheckInLibraryRequest": {
        "type": "object",
        "properties": {
          "service_account_names": {
            "type": "array",
            "description": "The username/logon name for the service accounts to check in.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "LDAPCheckInManageLibraryRequest": {
        "type": "object",
        "properties": {
          "service_account_names": {
            "type": "array",
            "description": "The username/logon name for the service accounts to check in.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "LDAPCheckOutLibraryRequest": {
        "type": "object",
        "properties": {
          "ttl": {
            "type": "integer",
            "description": "The length of time before the check-out will expire, in seconds.",
            "format": "seconds"
          }
        }
      },
      "LDAPLoginRequest": {
        "type": "object",
        "properties": {
          "password": {
            "type": "string",
            "description": "Password for this user."
          }
        }
      },
      "LDAPWriteAuthConfigRequest": {
        "type": "object",
        "properties": {
          "anonymous_group_search": {
            "type": "boolean",
            "description": "Use anonymous binds when performing LDAP group searches (if true the initial credentials will still be used for the initial connection test).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Anonymous group search"
            }
          },
          "binddn": {
            "type": "string",
            "description": "LDAP DN for searching for the user DN (optional)",
            "x-vault-displayAttrs": {
              "name": "Name of Object to bind (binddn)"
            }
          },
          "bindpass": {
            "type": "string",
            "description": "LDAP password for searching for the user DN (optional)",
            "x-vault-displayAttrs": {
              "sensitive": true
            }
          },
          "case_sensitive_names": {
            "type": "boolean",
            "description": "If true, case sensitivity will be used when comparing usernames and groups for matching policies."
          },
          "certificate": {
            "type": "string",
            "description": "CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "CA certificate",
              "editType": "file"
            }
          },
          "client_tls_cert": {
            "type": "string",
            "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "Client certificate",
              "editType": "file"
            }
          },
          "client_tls_key": {
            "type": "string",
            "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "Client key",
              "editType": "file"
            }
          },
          "deny_null_bind": {
            "type": "boolean",
            "description": "Denies an unauthenticated LDAP bind request if the user's password is empty; defaults to true",
            "default": true
          },
          "discoverdn": {
            "type": "boolean",
            "description": "Use anonymous bind to discover the bind DN of a user (optional)",
            "x-vault-displayAttrs": {
              "name": "Discover DN"
            }
          },
          "groupattr": {
            "type": "string",
            "description": "LDAP attribute to follow on objects returned by <groupfilter> in order to enumerate user group membership. Examples: \"cn\" or \"memberOf\", etc. Default: cn",
            "default": "cn",
            "x-vault-displayAttrs": {
              "name": "Group Attribute",
              "value": "cn"
            }
          },
          "groupdn": {
            "type": "string",
            "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org)",
            "x-vault-displayAttrs": {
              "name": "Group DN"
            }
          },
          "groupfilter": {
            "type": "string",
            "description": "Go template for querying group membership of user (optional) The template can access the following context variables: UserDN, Username Example: (&(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})) Default: (|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))",
            "default": "(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))",
            "x-vault-displayAttrs": {
              "name": "Group Filter"
            }
          },
          "insecure_tls": {
            "type": "boolean",
            "description": "Skip LDAP server SSL Certificate verification - VERY insecure (optional)",
            "x-vault-displayAttrs": {
              "name": "Insecure TLS"
            }
          },
          "request_timeout": {
            "type": "integer",
            "description": "Timeout, in seconds, for the connection when making requests against the server before returning back an error.",
            "format": "seconds",
            "default": "90s"
          },
          "starttls": {
            "type": "boolean",
            "description": "Issue a StartTLS command after establishing unencrypted connection (optional)",
            "x-vault-displayAttrs": {
              "name": "Issue StartTLS"
            }
          },
          "tls_max_version": {
            "type": "string",
            "description": "Maximum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'",
            "enum": [
              "tls10",
              "tls11",
              "tls12",
              "tls13"
            ],
            "default": "tls12",
            "x-vault-displayAttrs": {
              "name": "Maximum TLS Version"
            }
          },
          "tls_min_version": {
            "type": "string",
            "description": "Minimum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'",
            "enum": [
              "tls10",
              "tls11",
              "tls12",
              "tls13"
            ],
            "default": "tls12",
            "x-vault-displayAttrs": {
              "name": "Minimum TLS Version"
            }
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies. This will apply to all tokens generated by this auth method, in addition to any configured for specific users/groups.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "upndomain": {
            "type": "string",
            "description": "Enables userPrincipalDomain login with [username]@UPNDomain (optional)",
            "x-vault-displayAttrs": {
              "name": "User Principal (UPN) Domain"
            }
          },
          "url": {
            "type": "string",
            "description": "LDAP URL to connect to (default: ldap://127.0.0.1). Multiple URLs can be specified by concatenating them with commas; they will be tried in-order.",
            "default": "ldap://127.0.0.1",
            "x-vault-displayAttrs": {
              "name": "URL"
            }
          },
          "use_pre111_group_cn_behavior": {
            "type": "boolean",
            "description": "In Vault 1.1.1 a fix for handling group CN values of different cases unfortunately introduced a regression that could cause previously defined groups to not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for matching group CNs will be used. This is only needed in some upgrade scenarios for backwards compatibility. It is enabled by default if the config is upgraded but disabled by default on new configurations."
          },
          "use_token_groups": {
            "type": "boolean",
            "description": "If true, use the Active Directory tokenGroups constructed attribute of the user to find the group memberships. This will find all security groups including nested ones.",
            "default": false
          },
          "userattr": {
            "type": "string",
            "description": "Attribute used for users (default: cn)",
            "default": "cn",
            "x-vault-displayAttrs": {
              "name": "User Attribute",
              "value": "cn"
            }
          },
          "userdn": {
            "type": "string",
            "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)",
            "x-vault-displayAttrs": {
              "name": "User DN"
            }
          },
          "userfilter": {
            "type": "string",
            "description": "Go template for LDAP user search filer (optional) The template can access the following context variables: UserAttr, Username Default: ({{.UserAttr}}={{.Username}})",
            "default": "({{.UserAttr}}={{.Username}})",
            "x-vault-displayAttrs": {
              "name": "User Search Filter"
            }
          },
          "username_as_alias": {
            "type": "boolean",
            "description": "If true, sets the alias name to the username",
            "default": false
          }
        }
      },
      "LDAPWriteConfigRequest": {
        "type": "object",
        "properties": {
          "anonymous_group_search": {
            "type": "boolean",
            "description": "Use anonymous binds when performing LDAP group searches (if true the initial credentials will still be used for the initial connection test).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Anonymous group search"
            }
          },
          "binddn": {
            "type": "string",
            "description": "LDAP DN for searching for the user DN (optional)",
            "x-vault-displayAttrs": {
              "name": "Name of Object to bind (binddn)"
            }
          },
          "bindpass": {
            "type": "string",
            "description": "LDAP password for searching for the user DN (optional)",
            "x-vault-displayAttrs": {
              "sensitive": true
            }
          },
          "case_sensitive_names": {
            "type": "boolean",
            "description": "If true, case sensitivity will be used when comparing usernames and groups for matching policies."
          },
          "certificate": {
            "type": "string",
            "description": "CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "CA certificate",
              "editType": "file"
            }
          },
          "client_tls_cert": {
            "type": "string",
            "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "Client certificate",
              "editType": "file"
            }
          },
          "client_tls_key": {
            "type": "string",
            "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "Client key",
              "editType": "file"
            }
          },
          "deny_null_bind": {
            "type": "boolean",
            "description": "Denies an unauthenticated LDAP bind request if the user's password is empty; defaults to true",
            "default": true
          },
          "discoverdn": {
            "type": "boolean",
            "description": "Use anonymous bind to discover the bind DN of a user (optional)",
            "x-vault-displayAttrs": {
              "name": "Discover DN"
            }
          },
          "groupattr": {
            "type": "string",
            "description": "LDAP attribute to follow on objects returned by <groupfilter> in order to enumerate user group membership. Examples: \"cn\" or \"memberOf\", etc. Default: cn",
            "default": "cn",
            "x-vault-displayAttrs": {
              "name": "Group Attribute",
              "value": "cn"
            }
          },
          "groupdn": {
            "type": "string",
            "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org)",
            "x-vault-displayAttrs": {
              "name": "Group DN"
            }
          },
          "groupfilter": {
            "type": "string",
            "description": "Go template for querying group membership of user (optional) The template can access the following context variables: UserDN, Username Example: (&(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})) Default: (|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))",
            "default": "(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))",
            "x-vault-displayAttrs": {
              "name": "Group Filter"
            }
          },
          "insecure_tls": {
            "type": "boolean",
            "description": "Skip LDAP server SSL Certificate verification - VERY insecure (optional)",
            "x-vault-displayAttrs": {
              "name": "Insecure TLS"
            }
          },
          "length": {
            "type": "integer",
            "description": "The desired length of passwords that Vault generates.",
            "deprecated": true
          },
          "max_ttl": {
            "type": "integer",
            "description": "The maximum password time-to-live.",
            "format": "seconds"
          },
          "password_policy": {
            "type": "string",
            "description": "Password policy to use to generate passwords"
          },
          "request_timeout": {
            "type": "integer",
            "description": "Timeout, in seconds, for the connection when making requests against the server before returning back an error.",
            "format": "seconds",
            "default": "90s"
          },
          "schema": {
            "type": "string",
            "description": "The desired LDAP schema used when modifying user account passwords.",
            "default": "openldap"
          },
          "starttls": {
            "type": "boolean",
            "description": "Issue a StartTLS command after establishing unencrypted connection (optional)",
            "x-vault-displayAttrs": {
              "name": "Issue StartTLS"
            }
          },
          "tls_max_version": {
            "type": "string",
            "description": "Maximum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'",
            "enum": [
              "tls10",
              "tls11",
              "tls12",
              "tls13"
            ],
            "default": "tls12",
            "x-vault-displayAttrs": {
              "name": "Maximum TLS Version"
            }
          },
          "tls_min_version": {
            "type": "string",
            "description": "Minimum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'",
            "enum": [
              "tls10",
              "tls11",
              "tls12",
              "tls13"
            ],
            "default": "tls12",
            "x-vault-displayAttrs": {
              "name": "Minimum TLS Version"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The default password time-to-live.",
            "format": "seconds"
          },
          "upndomain": {
            "type": "string",
            "description": "Enables userPrincipalDomain login with [username]@UPNDomain (optional)",
            "x-vault-displayAttrs": {
              "name": "User Principal (UPN) Domain"
            }
          },
          "url": {
            "type": "string",
            "description": "LDAP URL to connect to (default: ldap://127.0.0.1). Multiple URLs can be specified by concatenating them with commas; they will be tried in-order.",
            "default": "ldap://127.0.0.1",
            "x-vault-displayAttrs": {
              "name": "URL"
            }
          },
          "use_pre111_group_cn_behavior": {
            "type": "boolean",
            "description": "In Vault 1.1.1 a fix for handling group CN values of different cases unfortunately introduced a regression that could cause previously defined groups to not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for matching group CNs will be used. This is only needed in some upgrade scenarios for backwards compatibility. It is enabled by default if the config is upgraded but disabled by default on new configurations."
          },
          "use_token_groups": {
            "type": "boolean",
            "description": "If true, use the Active Directory tokenGroups constructed attribute of the user to find the group memberships. This will find all security groups including nested ones.",
            "default": false
          },
          "userattr": {
            "type": "string",
            "description": "Attribute used for users (default: cn)",
            "default": "cn",
            "x-vault-displayAttrs": {
              "name": "User Attribute",
              "value": "cn"
            }
          },
          "userdn": {
            "type": "string",
            "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)",
            "x-vault-displayAttrs": {
              "name": "User DN"
            }
          },
          "userfilter": {
            "type": "string",
            "description": "Go template for LDAP user search filer (optional) The template can access the following context variables: UserAttr, Username Default: ({{.UserAttr}}={{.Username}})",
            "default": "({{.UserAttr}}={{.Username}})",
            "x-vault-displayAttrs": {
              "name": "User Search Filter"
            }
          },
          "username_as_alias": {
            "type": "boolean",
            "description": "If true, sets the alias name to the username",
            "default": false
          }
        }
      },
      "LDAPWriteGroupRequest": {
        "type": "object",
        "properties": {
          "policies": {
            "type": "array",
            "description": "Comma-separated list of policies associated to the group.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "LDAPWriteLibraryRequest": {
        "type": "object",
        "properties": {
          "disable_check_in_enforcement": {
            "type": "boolean",
            "description": "Disable the default behavior of requiring that check-ins are performed by the entity that checked them out.",
            "default": false
          },
          "max_ttl": {
            "type": "integer",
            "description": "In seconds, the max amount of time a check-out's renewals should last. Defaults to 24 hours.",
            "format": "seconds",
            "default": 86400
          },
          "service_account_names": {
            "type": "array",
            "description": "The username/logon name for the service accounts with which this set will be associated.",
            "items": {
              "type": "string"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "In seconds, the amount of time a check-out should last. Defaults to 24 hours.",
            "format": "seconds",
            "default": 86400
          }
        }
      },
      "LDAPWriteRoleRequest": {
        "type": "object",
        "properties": {
          "creation_ldif": {
            "type": "string",
            "description": "LDIF string used to create new entities within the LDAP system. This LDIF can be templated."
          },
          "default_ttl": {
            "type": "integer",
            "description": "Default TTL for dynamic credentials",
            "format": "seconds"
          },
          "deletion_ldif": {
            "type": "string",
            "description": "LDIF string used to delete entities created within the LDAP system. This LDIF can be templated."
          },
          "max_ttl": {
            "type": "integer",
            "description": "Max TTL a dynamic credential can be extended to",
            "format": "seconds"
          },
          "rollback_ldif": {
            "type": "string",
            "description": "LDIF string used to rollback changes in the event of a failure to create credentials. This LDIF can be templated."
          },
          "username_template": {
            "type": "string",
            "description": "The template used to create a username"
          }
        },
        "required": [
          "creation_ldif",
          "deletion_ldif"
        ]
      },
      "LDAPWriteStaticRoleRequest": {
        "type": "object",
        "properties": {
          "dn": {
            "type": "string",
            "description": "The distinguished name of the entry to manage."
          },
          "rotation_period": {
            "type": "integer",
            "description": "Period for automatic credential rotation of the given entry.",
            "format": "seconds"
          },
          "username": {
            "type": "string",
            "description": "The username/logon name for the entry with which this role will be associated."
          }
        }
      },
      "LDAPWriteUserRequest": {
        "type": "object",
        "properties": {
          "groups": {
            "type": "array",
            "description": "Comma-separated list of additional groups associated with the user.",
            "items": {
              "type": "string"
            }
          },
          "policies": {
            "type": "array",
            "description": "Comma-separated list of policies associated with the user.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "MFAMethodAdminDestroyTOTPRequest": {
        "type": "object",
        "properties": {
          "entity_id": {
            "type": "string",
            "description": "Identifier of the entity from which the MFA method secret needs to be removed."
          },
          "method_id": {
            "type": "string",
            "description": "The unique identifier for this MFA method."
          }
        },
        "required": [
          "method_id",
          "entity_id"
        ]
      },
      "MFAMethodAdminGenerateTOTPRequest": {
        "type": "object",
        "properties": {
          "entity_id": {
            "type": "string",
            "description": "Entity ID on which the generated secret needs to get stored."
          },
          "method_id": {
            "type": "string",
            "description": "The unique identifier for this MFA method."
          }
        },
        "required": [
          "method_id",
          "entity_id"
        ]
      },
      "MFAMethodGenerateTOTPRequest": {
        "type": "object",
        "properties": {
          "method_id": {
            "type": "string",
            "description": "The unique identifier for this MFA method."
          }
        },
        "required": [
          "method_id"
        ]
      },
      "MFAMethodWriteDuoRequest": {
        "type": "object",
        "properties": {
          "api_hostname": {
            "type": "string",
            "description": "API host name for Duo."
          },
          "integration_key": {
            "type": "string",
            "description": "Integration key for Duo."
          },
          "method_id": {
            "type": "string",
            "description": "The unique identifier for this MFA method."
          },
          "push_info": {
            "type": "string",
            "description": "Push information for Duo."
          },
          "secret_key": {
            "type": "string",
            "description": "Secret key for Duo."
          },
          "use_passcode": {
            "type": "boolean",
            "description": "If true, the user is reminded to use the passcode upon MFA validation. This option does not enforce using the passcode. Defaults to false."
          },
          "username_format": {
            "type": "string",
            "description": "A template string for mapping Identity names to MFA method names. Values to subtitute should be placed in {{}}. For example, \"{{alias.name}}@example.com\". Currently-supported mappings: alias.name: The name returned by the mount configured via the mount_accessor parameter If blank, the Alias's name field will be used as-is."
          }
        }
      },
      "MFAMethodWriteOktaRequest": {
        "type": "object",
        "properties": {
          "api_token": {
            "type": "string",
            "description": "Okta API key."
          },
          "base_url": {
            "type": "string",
            "description": "The base domain to use for the Okta API. When not specified in the configuration, \"okta.com\" is used."
          },
          "method_id": {
            "type": "string",
            "description": "The unique identifier for this MFA method."
          },
          "org_name": {
            "type": "string",
            "description": "Name of the organization to be used in the Okta API."
          },
          "primary_email": {
            "type": "boolean",
            "description": "If true, the username will only match the primary email for the account. Defaults to false."
          },
          "production": {
            "type": "boolean",
            "description": "(DEPRECATED) Use base_url instead."
          },
          "username_format": {
            "type": "string",
            "description": "A template string for mapping Identity names to MFA method names. Values to substitute should be placed in {{}}. For example, \"{{entity.name}}@example.com\". If blank, the Entity's name field will be used as-is."
          }
        }
      },
      "MFAMethodWritePingIDRequest": {
        "type": "object",
        "properties": {
          "method_id": {
            "type": "string",
            "description": "The unique identifier for this MFA method."
          },
          "settings_file_base64": {
            "type": "string",
            "description": "The settings file provided by Ping, Base64-encoded. This must be a settings file suitable for third-party clients, not the PingID SDK or PingFederate."
          },
          "username_format": {
            "type": "string",
            "description": "A template string for mapping Identity names to MFA method names. Values to subtitute should be placed in {{}}. For example, \"{{alias.name}}@example.com\". Currently-supported mappings: alias.name: The name returned by the mount configured via the mount_accessor parameter If blank, the Alias's name field will be used as-is."
          }
        }
      },
      "MFAMethodWriteTOTPRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "The hashing algorithm used to generate the TOTP token. Options include SHA1, SHA256 and SHA512.",
            "default": "SHA1"
          },
          "digits": {
            "type": "integer",
            "description": "The number of digits in the generated TOTP token. This value can either be 6 or 8.",
            "default": 6
          },
          "issuer": {
            "type": "string",
            "description": "The name of the key's issuing organization."
          },
          "key_size": {
            "type": "integer",
            "description": "Determines the size in bytes of the generated key.",
            "default": 20
          },
          "max_validation_attempts": {
            "type": "integer",
            "description": "Max number of allowed validation attempts."
          },
          "method_id": {
            "type": "string",
            "description": "The unique identifier for this MFA method."
          },
          "period": {
            "type": "integer",
            "description": "The length of time used to generate a counter for the TOTP token calculation.",
            "format": "seconds",
            "default": 30
          },
          "qr_size": {
            "type": "integer",
            "description": "The pixel size of the generated square QR code.",
            "default": 200
          },
          "skew": {
            "type": "integer",
            "description": "The number of delay periods that are allowed when validating a TOTP token. This value can either be 0 or 1.",
            "default": 1
          }
        }
      },
      "MFAValidateRequest": {
        "type": "object",
        "properties": {
          "mfa_payload": {
            "type": "object",
            "description": "A map from MFA method ID to a slice of passcodes or an empty slice if the method does not use passcodes",
            "format": "map"
          },
          "mfa_request_id": {
            "type": "string",
            "description": "ID for this MFA request"
          }
        },
        "required": [
          "mfa_request_id",
          "mfa_payload"
        ]
      },
      "MFAWriteLoginEnforcementRequest": {
        "type": "object",
        "properties": {
          "auth_method_accessors": {
            "type": "array",
            "description": "Array of auth mount accessor IDs",
            "items": {
              "type": "string"
            }
          },
          "auth_method_types": {
            "type": "array",
            "description": "Array of auth mount types",
            "items": {
              "type": "string"
            }
          },
          "identity_entity_ids": {
            "type": "array",
            "description": "Array of identity entity IDs",
            "items": {
              "type": "string"
            }
          },
          "identity_group_ids": {
            "type": "array",
            "description": "Array of identity group IDs",
            "items": {
              "type": "string"
            }
          },
          "mfa_method_ids": {
            "type": "array",
            "description": "Array of Method IDs that determine what methods will be enforced",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "mfa_method_ids"
        ]
      },
      "MongoDBAtlasWriteConfigRequest": {
        "type": "object",
        "properties": {
          "private_key": {
            "type": "string",
            "description": "MongoDB Atlas Programmatic Private Key",
            "x-vault-displayAttrs": {
              "sensitive": true
            }
          },
          "public_key": {
            "type": "string",
            "description": "MongoDB Atlas Programmatic Public Key"
          }
        },
        "required": [
          "public_key",
          "private_key"
        ]
      },
      "MongoDBAtlasWriteRoleRequest": {
        "type": "object",
        "properties": {
          "cidr_blocks": {
            "type": "array",
            "description": "Access list entry in CIDR notation to be added for the API key. Optional for organization and project keys.",
            "items": {
              "type": "string"
            }
          },
          "ip_addresses": {
            "type": "array",
            "description": "IP address to be added to the access list for the API key. Optional for organization and project keys.",
            "items": {
              "type": "string"
            }
          },
          "max_ttl": {
            "type": "integer",
            "description": "The maximum allowed lifetime of credentials issued using this role.",
            "format": "seconds"
          },
          "organization_id": {
            "type": "string",
            "description": "Organization ID required for an organization API key"
          },
          "project_id": {
            "type": "string",
            "description": "Project ID the project API key belongs to."
          },
          "project_roles": {
            "type": "array",
            "description": "Roles assigned when an organization API Key is assigned to a project API key",
            "items": {
              "type": "string"
            }
          },
          "roles": {
            "type": "array",
            "description": "List of roles that the API Key should be granted. A minimum of one role must be provided. Any roles provided must be valid for the assigned Project, required for organization and project keys.",
            "items": {
              "type": "string"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Duration in seconds after which the issued credential should expire. Defaults to 0, in which case the value will fallback to the system/mount defaults.",
            "format": "seconds"
          }
        },
        "required": [
          "roles"
        ]
      },
      "NomadWriteAccessConfigRequest": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "Nomad server address"
          },
          "ca_cert": {
            "type": "string",
            "description": "CA certificate to use when verifying Nomad server certificate, must be x509 PEM encoded."
          },
          "client_cert": {
            "type": "string",
            "description": "Client certificate used for Nomad's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_key."
          },
          "client_key": {
            "type": "string",
            "description": "Client key used for Nomad's TLS communication, must be x509 PEM encoded and if this is set you need to also set client_cert."
          },
          "max_token_name_length": {
            "type": "integer",
            "description": "Max length for name of generated Nomad tokens"
          },
          "token": {
            "type": "string",
            "description": "Token for API calls"
          }
        }
      },
      "NomadWriteLeaseConfigRequest": {
        "type": "object",
        "properties": {
          "max_ttl": {
            "type": "integer",
            "description": "Duration after which the issued token should not be allowed to be renewed",
            "format": "seconds"
          },
          "ttl": {
            "type": "integer",
            "description": "Duration before which the issued token needs renewal",
            "format": "seconds"
          }
        }
      },
      "NomadWriteRoleRequest": {
        "type": "object",
        "properties": {
          "global": {
            "type": "boolean",
            "description": "Boolean value describing if the token should be global or not. Defaults to false."
          },
          "policies": {
            "type": "array",
            "description": "Comma-separated string or list of policies as previously created in Nomad. Required for 'client' token.",
            "items": {
              "type": "string"
            }
          },
          "type": {
            "type": "string",
            "description": "Which type of token to create: 'client' or 'management'. If a 'management' token, the \"policies\" parameter is not required. Defaults to 'client'.",
            "default": "client"
          }
        }
      },
      "OCILoginWithRoleRequest": {
        "type": "object",
        "properties": {
          "request_headers": {
            "type": "string",
            "description": "The signed headers of the client"
          }
        }
      },
      "OCIWriteConfigRequest": {
        "type": "object",
        "properties": {
          "home_tenancy_id": {
            "type": "string",
            "description": "The tenancy id of the account."
          }
        }
      },
      "OCIWriteRoleRequest": {
        "type": "object",
        "properties": {
          "ocid_list": {
            "type": "array",
            "description": "A comma separated list of Group or Dynamic Group OCIDs that are allowed to take this role.",
            "items": {
              "type": "string"
            }
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          }
        }
      },
      "OIDCIntrospectRequest": {
        "type": "object",
        "properties": {
          "client_id": {
            "type": "string",
            "description": "Optional client_id to verify"
          },
          "token": {
            "type": "string",
            "description": "Token to verify"
          }
        }
      },
      "OIDCLoginRequest": {
        "type": "object",
        "properties": {
          "jwt": {
            "type": "string",
            "description": "The signed JWT to validate."
          },
          "role": {
            "type": "string",
            "description": "The role to log in against.",
            "format": "lowercase"
          }
        }
      },
      "OIDCRotateKeyRequest": {
        "type": "object",
        "properties": {
          "verification_ttl": {
            "type": "integer",
            "description": "Controls how long the public portion of a key will be available for verification after being rotated. Setting verification_ttl here will override the verification_ttl set on the key.",
            "format": "seconds"
          }
        }
      },
      "OIDCWriteAssignmentRequest": {
        "type": "object",
        "properties": {
          "entity_ids": {
            "type": "array",
            "description": "Comma separated string or array of identity entity IDs",
            "items": {
              "type": "string"
            }
          },
          "group_ids": {
            "type": "array",
            "description": "Comma separated string or array of identity group IDs",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "OIDCWriteAuthConfigRequest": {
        "type": "object",
        "properties": {
          "bound_issuer": {
            "type": "string",
            "description": "The value against which to match the 'iss' claim in a JWT. Optional."
          },
          "default_role": {
            "type": "string",
            "description": "The default role to use if none is provided during login. If not set, a role is required during login.",
            "format": "lowercase"
          },
          "jwks_ca_pem": {
            "type": "string",
            "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used."
          },
          "jwks_url": {
            "type": "string",
            "description": "JWKS URL to use to authenticate signatures. Cannot be used with \"oidc_discovery_url\" or \"jwt_validation_pubkeys\"."
          },
          "jwt_supported_algs": {
            "type": "array",
            "description": "A list of supported signing algorithms. Defaults to RS256.",
            "items": {
              "type": "string"
            }
          },
          "jwt_validation_pubkeys": {
            "type": "array",
            "description": "A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used with \"jwks_url\" or \"oidc_discovery_url\".",
            "items": {
              "type": "string"
            }
          },
          "namespace_in_state": {
            "type": "boolean",
            "description": "Pass namespace in the OIDC state parameter instead of as a separate query parameter. With this setting, the allowed redirect URL(s) in Vault and on the provider side should not contain a namespace query parameter. This means only one redirect URL entry needs to be maintained on the provider side for all vault namespaces that will be authenticating against it. Defaults to true for new configs.",
            "x-vault-displayAttrs": {
              "name": "Namespace in OIDC state",
              "value": true
            }
          },
          "oidc_client_id": {
            "type": "string",
            "description": "The OAuth Client ID configured with your OIDC provider."
          },
          "oidc_client_secret": {
            "type": "string",
            "description": "The OAuth Client Secret configured with your OIDC provider.",
            "x-vault-displayAttrs": {
              "sensitive": true
            }
          },
          "oidc_discovery_ca_pem": {
            "type": "string",
            "description": "The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used."
          },
          "oidc_discovery_url": {
            "type": "string",
            "description": "OIDC Discovery URL, without any .well-known component (base path). Cannot be used with \"jwks_url\" or \"jwt_validation_pubkeys\"."
          },
          "oidc_response_mode": {
            "type": "string",
            "description": "The response mode to be used in the OAuth2 request. Allowed values are 'query' and 'form_post'."
          },
          "oidc_response_types": {
            "type": "array",
            "description": "The response types to request. Allowed values are 'code' and 'id_token'. Defaults to 'code'.",
            "items": {
              "type": "string"
            }
          },
          "provider_config": {
            "type": "object",
            "description": "Provider-specific configuration. Optional.",
            "format": "map",
            "x-vault-displayAttrs": {
              "name": "Provider Config"
            }
          }
        }
      },
      "OIDCWriteAuthRoleRequest": {
        "type": "object",
        "properties": {
          "allowed_redirect_uris": {
            "type": "array",
            "description": "Comma-separated list of allowed values for redirect_uri",
            "items": {
              "type": "string"
            }
          },
          "bound_audiences": {
            "type": "array",
            "description": "Comma-separated list of 'aud' claims that are valid for login; any match is sufficient",
            "items": {
              "type": "string"
            }
          },
          "bound_cidrs": {
            "type": "array",
            "description": "Use \"token_bound_cidrs\" instead. If this and \"token_bound_cidrs\" are both specified, only \"token_bound_cidrs\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "bound_claims": {
            "type": "object",
            "description": "Map of claims/values which must match for login",
            "format": "map"
          },
          "bound_claims_type": {
            "type": "string",
            "description": "How to interpret values in the map of claims/values (which must match for login): allowed values are 'string' or 'glob'",
            "default": "string"
          },
          "bound_subject": {
            "type": "string",
            "description": "The 'sub' claim that is valid for login. Optional."
          },
          "claim_mappings": {
            "type": "object",
            "description": "Mappings of claims (key) that will be copied to a metadata field (value)",
            "format": "kvpairs"
          },
          "clock_skew_leeway": {
            "type": "integer",
            "description": "Duration in seconds of leeway when validating all claims to account for clock skew. Defaults to 60 (1 minute) if set to 0 and can be disabled if set to -1.",
            "format": "seconds",
            "default": 60000000000
          },
          "expiration_leeway": {
            "type": "integer",
            "description": "Duration in seconds of leeway when validating expiration of a token to account for clock skew. Defaults to 150 (2.5 minutes) if set to 0 and can be disabled if set to -1.",
            "format": "seconds",
            "default": 150
          },
          "groups_claim": {
            "type": "string",
            "description": "The claim to use for the Identity group alias names"
          },
          "max_age": {
            "type": "integer",
            "description": "Specifies the allowable elapsed time in seconds since the last time the user was actively authenticated.",
            "format": "seconds"
          },
          "max_ttl": {
            "type": "integer",
            "description": "Use \"token_max_ttl\" instead. If this and \"token_max_ttl\" are both specified, only \"token_max_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "not_before_leeway": {
            "type": "integer",
            "description": "Duration in seconds of leeway when validating not before values of a token to account for clock skew. Defaults to 150 (2.5 minutes) if set to 0 and can be disabled if set to -1.",
            "format": "seconds",
            "default": 150
          },
          "num_uses": {
            "type": "integer",
            "description": "Use \"token_num_uses\" instead. If this and \"token_num_uses\" are both specified, only \"token_num_uses\" will be used.",
            "deprecated": true
          },
          "oidc_scopes": {
            "type": "array",
            "description": "Comma-separated list of OIDC scopes",
            "items": {
              "type": "string"
            }
          },
          "period": {
            "type": "integer",
            "description": "Use \"token_period\" instead. If this and \"token_period\" are both specified, only \"token_period\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "role_type": {
            "type": "string",
            "description": "Type of the role, either 'jwt' or 'oidc'."
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Use \"token_ttl\" instead. If this and \"token_ttl\" are both specified, only \"token_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "user_claim": {
            "type": "string",
            "description": "The claim to use for the Identity entity alias name"
          },
          "user_claim_json_pointer": {
            "type": "boolean",
            "description": "If true, the user_claim value will use JSON pointer syntax for referencing claims."
          },
          "verbose_oidc_logging": {
            "type": "boolean",
            "description": "Log received OIDC tokens and claims when debug-level logging is active. Not recommended in production since sensitive information may be present in OIDC responses."
          }
        }
      },
      "OIDCWriteAuthURLRequest": {
        "type": "object",
        "properties": {
          "client_nonce": {
            "type": "string",
            "description": "Optional client-provided nonce that must match during callback, if present."
          },
          "redirect_uri": {
            "type": "string",
            "description": "The OAuth redirect_uri to use in the authorization URL."
          },
          "role": {
            "type": "string",
            "description": "The role to issue an OIDC authorization URL against.",
            "format": "lowercase"
          }
        }
      },
      "OIDCWriteCallbackRequest": {
        "type": "object",
        "properties": {
          "client_nonce": {
            "type": "string"
          },
          "code": {
            "type": "string"
          },
          "id_token": {
            "type": "string"
          },
          "state": {
            "type": "string"
          }
        }
      },
      "OIDCWriteClientRequest": {
        "type": "object",
        "properties": {
          "access_token_ttl": {
            "type": "integer",
            "description": "The time-to-live for access tokens obtained by the client.",
            "format": "seconds",
            "default": "24h"
          },
          "assignments": {
            "type": "array",
            "description": "Comma separated string or array of assignment resources.",
            "items": {
              "type": "string"
            }
          },
          "client_type": {
            "type": "string",
            "description": "The client type based on its ability to maintain confidentiality of credentials. The following client types are supported: 'confidential', 'public'. Defaults to 'confidential'.",
            "default": "confidential"
          },
          "id_token_ttl": {
            "type": "integer",
            "description": "The time-to-live for ID tokens obtained by the client.",
            "format": "seconds",
            "default": "24h"
          },
          "key": {
            "type": "string",
            "description": "A reference to a named key resource. Cannot be modified after creation. Defaults to the 'default' key.",
            "default": "default"
          },
          "redirect_uris": {
            "type": "array",
            "description": "Comma separated string or array of redirect URIs used by the client. One of these values must exactly match the redirect_uri parameter value used in each authentication request.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "OIDCWriteConfigRequest": {
        "type": "object",
        "properties": {
          "issuer": {
            "type": "string",
            "description": "Issuer URL to be used in the iss claim of the token. If not set, Vault's app_addr will be used."
          }
        }
      },
      "OIDCWriteKeyRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "Signing algorithm to use. This will default to RS256.",
            "default": "RS256"
          },
          "allowed_client_ids": {
            "type": "array",
            "description": "Comma separated string or array of role client ids allowed to use this key for signing. If empty no roles are allowed. If \"*\" all roles are allowed.",
            "items": {
              "type": "string"
            }
          },
          "rotation_period": {
            "type": "integer",
            "description": "How often to generate a new keypair.",
            "format": "seconds",
            "default": "24h"
          },
          "verification_ttl": {
            "type": "integer",
            "description": "Controls how long the public portion of a key will be available for verification after being rotated.",
            "format": "seconds",
            "default": "24h"
          }
        }
      },
      "OIDCWriteProviderAuthorizeRequest": {
        "type": "object",
        "properties": {
          "client_id": {
            "type": "string",
            "description": "The ID of the requesting client."
          },
          "code_challenge": {
            "type": "string",
            "description": "The code challenge derived from the code verifier."
          },
          "code_challenge_method": {
            "type": "string",
            "description": "The method that was used to derive the code challenge. The following methods are supported: 'S256', 'plain'. Defaults to 'plain'.",
            "default": "plain"
          },
          "max_age": {
            "type": "integer",
            "description": "The allowable elapsed time in seconds since the last time the end-user was actively authenticated."
          },
          "nonce": {
            "type": "string",
            "description": "The value that will be returned in the ID token nonce claim after a token exchange."
          },
          "redirect_uri": {
            "type": "string",
            "description": "The redirection URI to which the response will be sent."
          },
          "response_type": {
            "type": "string",
            "description": "The OIDC authentication flow to be used. The following response types are supported: 'code'"
          },
          "scope": {
            "type": "string",
            "description": "A space-delimited, case-sensitive list of scopes to be requested. The 'openid' scope is required."
          },
          "state": {
            "type": "string",
            "description": "The value used to maintain state between the authentication request and client."
          }
        },
        "required": [
          "response_type",
          "client_id",
          "redirect_uri",
          "scope"
        ]
      },
      "OIDCWriteProviderRequest": {
        "type": "object",
        "properties": {
          "allowed_client_ids": {
            "type": "array",
            "description": "The client IDs that are permitted to use the provider",
            "items": {
              "type": "string"
            }
          },
          "issuer": {
            "type": "string",
            "description": "Specifies what will be used for the iss claim of ID tokens."
          },
          "scopes_supported": {
            "type": "array",
            "description": "The scopes supported for requesting on the provider",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "OIDCWriteProviderTokenRequest": {
        "type": "object",
        "properties": {
          "client_id": {
            "type": "string",
            "description": "The ID of the requesting client."
          },
          "client_secret": {
            "type": "string",
            "description": "The secret of the requesting client."
          },
          "code": {
            "type": "string",
            "description": "The authorization code received from the provider's authorization endpoint."
          },
          "code_verifier": {
            "type": "string",
            "description": "The code verifier associated with the authorization code."
          },
          "grant_type": {
            "type": "string",
            "description": "The authorization grant type. The following grant types are supported: 'authorization_code'."
          },
          "redirect_uri": {
            "type": "string",
            "description": "The callback location where the authentication response was sent."
          }
        },
        "required": [
          "code",
          "grant_type",
          "redirect_uri"
        ]
      },
      "OIDCWriteRoleRequest": {
        "type": "object",
        "properties": {
          "client_id": {
            "type": "string",
            "description": "Optional client_id"
          },
          "key": {
            "type": "string",
            "description": "The OIDC key to use for generating tokens. The specified key must already exist."
          },
          "template": {
            "type": "string",
            "description": "The template string to use for generating tokens. This may be in string-ified JSON or base64 format."
          },
          "ttl": {
            "type": "integer",
            "description": "TTL of the tokens generated against the role.",
            "format": "seconds",
            "default": "24h"
          }
        },
        "required": [
          "key"
        ]
      },
      "OIDCWriteScopeRequest": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "description": "The description of the scope"
          },
          "template": {
            "type": "string",
            "description": "The template string to use for the scope. This may be in string-ified JSON or base64 format."
          }
        }
      },
      "OktaLoginRequest": {
        "type": "object",
        "properties": {
          "nonce": {
            "type": "string",
            "description": "Nonce provided if performing login that requires number verification challenge. Logins through the vault login CLI command will automatically generate a nonce."
          },
          "password": {
            "type": "string",
            "description": "Password for this user."
          },
          "provider": {
            "type": "string",
            "description": "Preferred factor provider."
          },
          "totp": {
            "type": "string",
            "description": "TOTP passcode."
          }
        }
      },
      "OktaWriteConfigRequest": {
        "type": "object",
        "properties": {
          "api_token": {
            "type": "string",
            "description": "Okta API key.",
            "x-vault-displayAttrs": {
              "name": "API Token"
            }
          },
          "base_url": {
            "type": "string",
            "description": "The base domain to use for the Okta API. When not specified in the configuration, \"okta.com\" is used.",
            "x-vault-displayAttrs": {
              "name": "Base URL"
            }
          },
          "bypass_okta_mfa": {
            "type": "boolean",
            "description": "When set true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.",
            "x-vault-displayAttrs": {
              "name": "Bypass Okta MFA"
            }
          },
          "max_ttl": {
            "type": "integer",
            "description": "Use \"token_max_ttl\" instead. If this and \"token_max_ttl\" are both specified, only \"token_max_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "org_name": {
            "type": "string",
            "description": "Name of the organization to be used in the Okta API.",
            "x-vault-displayAttrs": {
              "name": "Organization Name"
            }
          },
          "organization": {
            "type": "string",
            "description": "Use org_name instead.",
            "deprecated": true
          },
          "production": {
            "type": "boolean",
            "description": "Use base_url instead.",
            "deprecated": true
          },
          "token": {
            "type": "string",
            "description": "Use api_token instead.",
            "deprecated": true
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies. This will apply to all tokens generated by this auth method, in addition to any configured for specific users/groups.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Use \"token_ttl\" instead. If this and \"token_ttl\" are both specified, only \"token_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          }
        }
      },
      "OktaWriteGroupRequest": {
        "type": "object",
        "properties": {
          "policies": {
            "type": "array",
            "description": "Comma-separated list of policies associated to the group.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "OktaWriteUserRequest": {
        "type": "object",
        "properties": {
          "groups": {
            "type": "array",
            "description": "List of groups associated with the user.",
            "items": {
              "type": "string"
            }
          },
          "policies": {
            "type": "array",
            "description": "List of policies associated with the user.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "OpenLDAPCheckInLibraryRequest": {
        "type": "object",
        "properties": {
          "service_account_names": {
            "type": "array",
            "description": "The username/logon name for the service accounts to check in.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "OpenLDAPCheckInManageLibraryRequest": {
        "type": "object",
        "properties": {
          "service_account_names": {
            "type": "array",
            "description": "The username/logon name for the service accounts to check in.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "OpenLDAPCheckOutLibraryRequest": {
        "type": "object",
        "properties": {
          "ttl": {
            "type": "integer",
            "description": "The length of time before the check-out will expire, in seconds.",
            "format": "seconds"
          }
        }
      },
      "OpenLDAPWriteConfigRequest": {
        "type": "object",
        "properties": {
          "anonymous_group_search": {
            "type": "boolean",
            "description": "Use anonymous binds when performing LDAP group searches (if true the initial credentials will still be used for the initial connection test).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Anonymous group search"
            }
          },
          "binddn": {
            "type": "string",
            "description": "LDAP DN for searching for the user DN (optional)",
            "x-vault-displayAttrs": {
              "name": "Name of Object to bind (binddn)"
            }
          },
          "bindpass": {
            "type": "string",
            "description": "LDAP password for searching for the user DN (optional)",
            "x-vault-displayAttrs": {
              "sensitive": true
            }
          },
          "case_sensitive_names": {
            "type": "boolean",
            "description": "If true, case sensitivity will be used when comparing usernames and groups for matching policies."
          },
          "certificate": {
            "type": "string",
            "description": "CA certificate to use when verifying LDAP server certificate, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "CA certificate",
              "editType": "file"
            }
          },
          "client_tls_cert": {
            "type": "string",
            "description": "Client certificate to provide to the LDAP server, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "Client certificate",
              "editType": "file"
            }
          },
          "client_tls_key": {
            "type": "string",
            "description": "Client certificate key to provide to the LDAP server, must be x509 PEM encoded (optional)",
            "x-vault-displayAttrs": {
              "name": "Client key",
              "editType": "file"
            }
          },
          "deny_null_bind": {
            "type": "boolean",
            "description": "Denies an unauthenticated LDAP bind request if the user's password is empty; defaults to true",
            "default": true
          },
          "discoverdn": {
            "type": "boolean",
            "description": "Use anonymous bind to discover the bind DN of a user (optional)",
            "x-vault-displayAttrs": {
              "name": "Discover DN"
            }
          },
          "groupattr": {
            "type": "string",
            "description": "LDAP attribute to follow on objects returned by <groupfilter> in order to enumerate user group membership. Examples: \"cn\" or \"memberOf\", etc. Default: cn",
            "default": "cn",
            "x-vault-displayAttrs": {
              "name": "Group Attribute",
              "value": "cn"
            }
          },
          "groupdn": {
            "type": "string",
            "description": "LDAP search base to use for group membership search (eg: ou=Groups,dc=example,dc=org)",
            "x-vault-displayAttrs": {
              "name": "Group DN"
            }
          },
          "groupfilter": {
            "type": "string",
            "description": "Go template for querying group membership of user (optional) The template can access the following context variables: UserDN, Username Example: (&(objectClass=group)(member:1.2.840.113556.1.4.1941:={{.UserDN}})) Default: (|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))",
            "default": "(|(memberUid={{.Username}})(member={{.UserDN}})(uniqueMember={{.UserDN}}))",
            "x-vault-displayAttrs": {
              "name": "Group Filter"
            }
          },
          "insecure_tls": {
            "type": "boolean",
            "description": "Skip LDAP server SSL Certificate verification - VERY insecure (optional)",
            "x-vault-displayAttrs": {
              "name": "Insecure TLS"
            }
          },
          "length": {
            "type": "integer",
            "description": "The desired length of passwords that Vault generates.",
            "deprecated": true
          },
          "max_ttl": {
            "type": "integer",
            "description": "The maximum password time-to-live.",
            "format": "seconds"
          },
          "password_policy": {
            "type": "string",
            "description": "Password policy to use to generate passwords"
          },
          "request_timeout": {
            "type": "integer",
            "description": "Timeout, in seconds, for the connection when making requests against the server before returning back an error.",
            "format": "seconds",
            "default": "90s"
          },
          "schema": {
            "type": "string",
            "description": "The desired LDAP schema used when modifying user account passwords.",
            "default": "openldap"
          },
          "starttls": {
            "type": "boolean",
            "description": "Issue a StartTLS command after establishing unencrypted connection (optional)",
            "x-vault-displayAttrs": {
              "name": "Issue StartTLS"
            }
          },
          "tls_max_version": {
            "type": "string",
            "description": "Maximum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'",
            "enum": [
              "tls10",
              "tls11",
              "tls12",
              "tls13"
            ],
            "default": "tls12",
            "x-vault-displayAttrs": {
              "name": "Maximum TLS Version"
            }
          },
          "tls_min_version": {
            "type": "string",
            "description": "Minimum TLS version to use. Accepted values are 'tls10', 'tls11', 'tls12' or 'tls13'. Defaults to 'tls12'",
            "enum": [
              "tls10",
              "tls11",
              "tls12",
              "tls13"
            ],
            "default": "tls12",
            "x-vault-displayAttrs": {
              "name": "Minimum TLS Version"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The default password time-to-live.",
            "format": "seconds"
          },
          "upndomain": {
            "type": "string",
            "description": "Enables userPrincipalDomain login with [username]@UPNDomain (optional)",
            "x-vault-displayAttrs": {
              "name": "User Principal (UPN) Domain"
            }
          },
          "url": {
            "type": "string",
            "description": "LDAP URL to connect to (default: ldap://127.0.0.1). Multiple URLs can be specified by concatenating them with commas; they will be tried in-order.",
            "default": "ldap://127.0.0.1",
            "x-vault-displayAttrs": {
              "name": "URL"
            }
          },
          "use_pre111_group_cn_behavior": {
            "type": "boolean",
            "description": "In Vault 1.1.1 a fix for handling group CN values of different cases unfortunately introduced a regression that could cause previously defined groups to not be found due to a change in the resulting name. If set true, the pre-1.1.1 behavior for matching group CNs will be used. This is only needed in some upgrade scenarios for backwards compatibility. It is enabled by default if the config is upgraded but disabled by default on new configurations."
          },
          "use_token_groups": {
            "type": "boolean",
            "description": "If true, use the Active Directory tokenGroups constructed attribute of the user to find the group memberships. This will find all security groups including nested ones.",
            "default": false
          },
          "userattr": {
            "type": "string",
            "description": "Attribute used for users (default: cn)",
            "default": "cn",
            "x-vault-displayAttrs": {
              "name": "User Attribute",
              "value": "cn"
            }
          },
          "userdn": {
            "type": "string",
            "description": "LDAP domain to use for users (eg: ou=People,dc=example,dc=org)",
            "x-vault-displayAttrs": {
              "name": "User DN"
            }
          },
          "userfilter": {
            "type": "string",
            "description": "Go template for LDAP user search filer (optional) The template can access the following context variables: UserAttr, Username Default: ({{.UserAttr}}={{.Username}})",
            "default": "({{.UserAttr}}={{.Username}})",
            "x-vault-displayAttrs": {
              "name": "User Search Filter"
            }
          },
          "username_as_alias": {
            "type": "boolean",
            "description": "If true, sets the alias name to the username",
            "default": false
          }
        }
      },
      "OpenLDAPWriteLibraryRequest": {
        "type": "object",
        "properties": {
          "disable_check_in_enforcement": {
            "type": "boolean",
            "description": "Disable the default behavior of requiring that check-ins are performed by the entity that checked them out.",
            "default": false
          },
          "max_ttl": {
            "type": "integer",
            "description": "In seconds, the max amount of time a check-out's renewals should last. Defaults to 24 hours.",
            "format": "seconds",
            "default": 86400
          },
          "service_account_names": {
            "type": "array",
            "description": "The username/logon name for the service accounts with which this set will be associated.",
            "items": {
              "type": "string"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "In seconds, the amount of time a check-out should last. Defaults to 24 hours.",
            "format": "seconds",
            "default": 86400
          }
        }
      },
      "OpenLDAPWriteRoleRequest": {
        "type": "object",
        "properties": {
          "creation_ldif": {
            "type": "string",
            "description": "LDIF string used to create new entities within the LDAP system. This LDIF can be templated."
          },
          "default_ttl": {
            "type": "integer",
            "description": "Default TTL for dynamic credentials",
            "format": "seconds"
          },
          "deletion_ldif": {
            "type": "string",
            "description": "LDIF string used to delete entities created within the LDAP system. This LDIF can be templated."
          },
          "max_ttl": {
            "type": "integer",
            "description": "Max TTL a dynamic credential can be extended to",
            "format": "seconds"
          },
          "rollback_ldif": {
            "type": "string",
            "description": "LDIF string used to rollback changes in the event of a failure to create credentials. This LDIF can be templated."
          },
          "username_template": {
            "type": "string",
            "description": "The template used to create a username"
          }
        },
        "required": [
          "creation_ldif",
          "deletion_ldif"
        ]
      },
      "OpenLDAPWriteStaticRoleRequest": {
        "type": "object",
        "properties": {
          "dn": {
            "type": "string",
            "description": "The distinguished name of the entry to manage."
          },
          "rotation_period": {
            "type": "integer",
            "description": "Period for automatic credential rotation of the given entry.",
            "format": "seconds"
          },
          "username": {
            "type": "string",
            "description": "The username/logon name for the entry with which this role will be associated."
          }
        }
      },
      "PKIBundleWriteRequest": {
        "type": "object",
        "properties": {
          "pem_bundle": {
            "type": "string",
            "description": "PEM-format, concatenated unencrypted secret-key (optional) and certificates."
          }
        }
      },
      "PKIGenerateRootRequest": {
        "type": "object",
        "properties": {
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans."
          },
          "country": {
            "type": "array",
            "description": "If set, Country will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "issuer_name": {
            "type": "string",
            "description": "Provide a name to the generated or existing issuer, the name must be unique across all issuers and not be the reserved value 'default'"
          },
          "key_bits": {
            "type": "integer",
            "description": "The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "key_name": {
            "type": "string",
            "description": "Provide a name to the generated or existing key, the name must be unique across all keys and not be the reserved value 'default'"
          },
          "key_ref": {
            "type": "string",
            "description": "Reference to a existing key; either \"default\" for the configured default key, an identifier or the name assigned to the key.",
            "default": "default"
          },
          "key_type": {
            "type": "string",
            "description": "The type of key to use; defaults to RSA. \"rsa\" \"ec\" and \"ed25519\" are the only valid values.",
            "enum": [
              "rsa",
              "ec",
              "ed25519"
            ],
            "default": "rsa",
            "x-vault-displayAttrs": {
              "value": "rsa"
            }
          },
          "locality": {
            "type": "array",
            "description": "If set, Locality will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Locality/City"
            }
          },
          "managed_key_id": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types."
          },
          "managed_key_name": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types."
          },
          "max_path_length": {
            "type": "integer",
            "description": "The maximum allowable path length",
            "default": -1
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "not_before_duration": {
            "type": "integer",
            "description": "The duration before now which the certificate needs to be backdated by.",
            "format": "seconds",
            "default": 30,
            "x-vault-displayAttrs": {
              "value": 30
            }
          },
          "organization": {
            "type": "array",
            "description": "If set, O (Organization) will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "ou": {
            "type": "array",
            "description": "If set, OU (OrganizationalUnit) will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "OU (Organizational Unit)"
            }
          },
          "permitted_dns_domains": {
            "type": "array",
            "description": "Domains for which this certificate is allowed to sign or issue child certificates. If set, all DNS names (subject and alt) on child certs must be exact matches or subsets of the given domains (see https://tools.ietf.org/html/rfc5280#section-4.2.1.10).",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Permitted DNS Domains"
            }
          },
          "postal_code": {
            "type": "array",
            "description": "If set, Postal Code will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Postal Code"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "province": {
            "type": "array",
            "description": "If set, Province will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Province/State"
            }
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "signature_bits": {
            "type": "integer",
            "description": "The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "street_address": {
            "type": "array",
            "description": "If set, Street Address will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Street Address"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          },
          "use_pss": {
            "type": "boolean",
            "description": "Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.",
            "default": false
          }
        }
      },
      "PKIImportKeysRequest": {
        "type": "object",
        "properties": {
          "key_name": {
            "type": "string",
            "description": "Optional name to be used for this key"
          },
          "pem_bundle": {
            "type": "string",
            "description": "PEM-format, unencrypted secret key"
          }
        }
      },
      "PKIIssuerIssueRoleRequest": {
        "type": "object",
        "properties": {
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address."
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "remove_roots_from_chain": {
            "type": "boolean",
            "description": "Whether or not to remove self-signed CA certificates in the output of the ca_chain field.",
            "default": false
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          }
        }
      },
      "PKIIssuerResignCRLsRequest": {
        "type": "object",
        "properties": {
          "crl_number": {
            "type": "integer",
            "description": "The sequence number to be written within the CRL Number extension."
          },
          "crls": {
            "type": "array",
            "description": "A list of PEM encoded CRLs to combine, originally signed by the requested issuer.",
            "items": {
              "type": "string"
            }
          },
          "delta_crl_base_number": {
            "type": "integer",
            "description": "Using a zero or greater value specifies the base CRL revision number to encode within a Delta CRL indicator extension, otherwise the extension will not be added.",
            "default": -1
          },
          "format": {
            "type": "string",
            "description": "The format of the combined CRL, can be \"pem\" or \"der\". If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "default": "pem"
          },
          "next_update": {
            "type": "string",
            "description": "The amount of time the generated CRL should be valid; defaults to 72 hours.",
            "default": "72h"
          }
        }
      },
      "PKIIssuerSignIntermediateRequest": {
        "type": "object",
        "properties": {
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans."
          },
          "country": {
            "type": "array",
            "description": "If set, Country will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "csr": {
            "type": "string",
            "description": "PEM-format CSR to be signed.",
            "default": ""
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "issuer_name": {
            "type": "string",
            "description": "Provide a name to the generated or existing issuer, the name must be unique across all issuers and not be the reserved value 'default'"
          },
          "locality": {
            "type": "array",
            "description": "If set, Locality will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Locality/City"
            }
          },
          "max_path_length": {
            "type": "integer",
            "description": "The maximum allowable path length",
            "default": -1
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "not_before_duration": {
            "type": "integer",
            "description": "The duration before now which the certificate needs to be backdated by.",
            "format": "seconds",
            "default": 30,
            "x-vault-displayAttrs": {
              "value": 30
            }
          },
          "organization": {
            "type": "array",
            "description": "If set, O (Organization) will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "ou": {
            "type": "array",
            "description": "If set, OU (OrganizationalUnit) will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "OU (Organizational Unit)"
            }
          },
          "permitted_dns_domains": {
            "type": "array",
            "description": "Domains for which this certificate is allowed to sign or issue child certificates. If set, all DNS names (subject and alt) on child certs must be exact matches or subsets of the given domains (see https://tools.ietf.org/html/rfc5280#section-4.2.1.10).",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Permitted DNS Domains"
            }
          },
          "postal_code": {
            "type": "array",
            "description": "If set, Postal Code will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Postal Code"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "province": {
            "type": "array",
            "description": "If set, Province will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Province/State"
            }
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "signature_bits": {
            "type": "integer",
            "description": "The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "skid": {
            "type": "string",
            "description": "Value for the Subject Key Identifier field (RFC 5280 Section 4.2.1.2). This value should ONLY be used when cross-signing to mimic the existing certificate's SKID value; this is necessary to allow certain TLS implementations (such as OpenSSL) which use SKID/AKID matches in chain building to restrict possible valid chains. Specified as a string in hex format. Default is empty, allowing Vault to automatically calculate the SKID according to method one in the above RFC section.",
            "default": "",
            "x-vault-displayAttrs": {
              "value": ""
            }
          },
          "street_address": {
            "type": "array",
            "description": "If set, Street Address will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Street Address"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          },
          "use_csr_values": {
            "type": "boolean",
            "description": "If true, then: 1) Subject information, including names and alternate names, will be preserved from the CSR rather than using values provided in the other parameters to this path; 2) Any key usages requested in the CSR will be added to the basic set of key usages used for CA certs signed by this path; for instance, the non-repudiation flag; 3) Extensions requested in the CSR will be copied into the issued certificate.",
            "default": false
          },
          "use_pss": {
            "type": "boolean",
            "description": "Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.",
            "default": false
          }
        }
      },
      "PKIIssuerSignRevocationListRequest": {
        "type": "object",
        "properties": {
          "crl_number": {
            "type": "integer",
            "description": "The sequence number to be written within the CRL Number extension."
          },
          "delta_crl_base_number": {
            "type": "integer",
            "description": "Using a zero or greater value specifies the base CRL revision number to encode within a Delta CRL indicator extension, otherwise the extension will not be added.",
            "default": -1
          },
          "extensions": {
            "type": "array",
            "description": "A list of maps containing extensions with keys id (string), critical (bool), value (string)",
            "items": {
              "type": "object"
            }
          },
          "format": {
            "type": "string",
            "description": "The format of the combined CRL, can be \"pem\" or \"der\". If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "default": "pem"
          },
          "next_update": {
            "type": "string",
            "description": "The amount of time the generated CRL should be valid; defaults to 72 hours.",
            "default": "72h"
          },
          "revoked_certs": {
            "type": "array",
            "description": "A list of maps containing the keys serial_number (string), revocation_time (string), and extensions (map with keys id (string), critical (bool), value (string))",
            "items": {
              "type": "object"
            }
          }
        }
      },
      "PKIIssuerSignRoleRequest": {
        "type": "object",
        "properties": {
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address."
          },
          "csr": {
            "type": "string",
            "description": "PEM-format CSR to be signed.",
            "default": ""
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "remove_roots_from_chain": {
            "type": "boolean",
            "description": "Whether or not to remove self-signed CA certificates in the output of the ca_chain field.",
            "default": false
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          }
        }
      },
      "PKIIssuerSignSelfIssuedRequest": {
        "type": "object",
        "properties": {
          "certificate": {
            "type": "string",
            "description": "PEM-format self-issued certificate to be signed."
          },
          "require_matching_certificate_algorithms": {
            "type": "boolean",
            "description": "If true, require the public key algorithm of the signer to match that of the self issued certificate.",
            "default": false
          }
        }
      },
      "PKIIssuerSignVerbatimRequest": {
        "type": "object",
        "properties": {
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address."
          },
          "csr": {
            "type": "string",
            "description": "PEM-format CSR to be signed. Values will be taken verbatim from the CSR, except for basic constraints.",
            "default": ""
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "ext_key_usage": {
            "type": "array",
            "description": "A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the \"ExtKeyUsage\" part of the name. To remove all key usages from being set, set this value to an empty list.",
            "items": {
              "type": "string"
            },
            "default": []
          },
          "ext_key_usage_oids": {
            "type": "array",
            "description": "A comma-separated string or list of extended key usage oids.",
            "items": {
              "type": "string"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "key_usage": {
            "type": "array",
            "description": "A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the \"KeyUsage\" part of the name. To remove all key usages from being set, set this value to an empty list.",
            "items": {
              "type": "string"
            },
            "default": [
              "DigitalSignature",
              "KeyAgreement",
              "KeyEncipherment"
            ]
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "remove_roots_from_chain": {
            "type": "boolean",
            "description": "Whether or not to remove self-signed CA certificates in the output of the ca_chain field.",
            "default": false
          },
          "role": {
            "type": "string",
            "description": "The desired role with configuration for this request"
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "signature_bits": {
            "type": "integer",
            "description": "The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          },
          "use_pss": {
            "type": "boolean",
            "description": "Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.",
            "default": false
          }
        }
      },
      "PKIIssuerSignVerbatimRoleRequest": {
        "type": "object",
        "properties": {
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address."
          },
          "csr": {
            "type": "string",
            "description": "PEM-format CSR to be signed. Values will be taken verbatim from the CSR, except for basic constraints.",
            "default": ""
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "ext_key_usage": {
            "type": "array",
            "description": "A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the \"ExtKeyUsage\" part of the name. To remove all key usages from being set, set this value to an empty list.",
            "items": {
              "type": "string"
            },
            "default": []
          },
          "ext_key_usage_oids": {
            "type": "array",
            "description": "A comma-separated string or list of extended key usage oids.",
            "items": {
              "type": "string"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "key_usage": {
            "type": "array",
            "description": "A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the \"KeyUsage\" part of the name. To remove all key usages from being set, set this value to an empty list.",
            "items": {
              "type": "string"
            },
            "default": [
              "DigitalSignature",
              "KeyAgreement",
              "KeyEncipherment"
            ]
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "remove_roots_from_chain": {
            "type": "boolean",
            "description": "Whether or not to remove self-signed CA certificates in the output of the ca_chain field.",
            "default": false
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "signature_bits": {
            "type": "integer",
            "description": "The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          },
          "use_pss": {
            "type": "boolean",
            "description": "Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.",
            "default": false
          }
        }
      },
      "PKIIssuersGenerateIntermediateRequest": {
        "type": "object",
        "properties": {
          "add_basic_constraints": {
            "type": "boolean",
            "description": "Whether to add a Basic Constraints extension with CA: true. Only needed as a workaround in some compatibility scenarios with Active Directory Certificate Services."
          },
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans."
          },
          "country": {
            "type": "array",
            "description": "If set, Country will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "key_bits": {
            "type": "integer",
            "description": "The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "key_name": {
            "type": "string",
            "description": "Provide a name to the generated or existing key, the name must be unique across all keys and not be the reserved value 'default'"
          },
          "key_ref": {
            "type": "string",
            "description": "Reference to a existing key; either \"default\" for the configured default key, an identifier or the name assigned to the key.",
            "default": "default"
          },
          "key_type": {
            "type": "string",
            "description": "The type of key to use; defaults to RSA. \"rsa\" \"ec\" and \"ed25519\" are the only valid values.",
            "enum": [
              "rsa",
              "ec",
              "ed25519"
            ],
            "default": "rsa",
            "x-vault-displayAttrs": {
              "value": "rsa"
            }
          },
          "locality": {
            "type": "array",
            "description": "If set, Locality will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Locality/City"
            }
          },
          "managed_key_id": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types."
          },
          "managed_key_name": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types."
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "not_before_duration": {
            "type": "integer",
            "description": "The duration before now which the certificate needs to be backdated by.",
            "format": "seconds",
            "default": 30,
            "x-vault-displayAttrs": {
              "value": 30
            }
          },
          "organization": {
            "type": "array",
            "description": "If set, O (Organization) will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "ou": {
            "type": "array",
            "description": "If set, OU (OrganizationalUnit) will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "OU (Organizational Unit)"
            }
          },
          "postal_code": {
            "type": "array",
            "description": "If set, Postal Code will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Postal Code"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "province": {
            "type": "array",
            "description": "If set, Province will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Province/State"
            }
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "signature_bits": {
            "type": "integer",
            "description": "The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "street_address": {
            "type": "array",
            "description": "If set, Street Address will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Street Address"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          }
        }
      },
      "PKIIssuersGenerateRootRequest": {
        "type": "object",
        "properties": {
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans."
          },
          "country": {
            "type": "array",
            "description": "If set, Country will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "issuer_name": {
            "type": "string",
            "description": "Provide a name to the generated or existing issuer, the name must be unique across all issuers and not be the reserved value 'default'"
          },
          "key_bits": {
            "type": "integer",
            "description": "The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "key_name": {
            "type": "string",
            "description": "Provide a name to the generated or existing key, the name must be unique across all keys and not be the reserved value 'default'"
          },
          "key_ref": {
            "type": "string",
            "description": "Reference to a existing key; either \"default\" for the configured default key, an identifier or the name assigned to the key.",
            "default": "default"
          },
          "key_type": {
            "type": "string",
            "description": "The type of key to use; defaults to RSA. \"rsa\" \"ec\" and \"ed25519\" are the only valid values.",
            "enum": [
              "rsa",
              "ec",
              "ed25519"
            ],
            "default": "rsa",
            "x-vault-displayAttrs": {
              "value": "rsa"
            }
          },
          "locality": {
            "type": "array",
            "description": "If set, Locality will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Locality/City"
            }
          },
          "managed_key_id": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types."
          },
          "managed_key_name": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types."
          },
          "max_path_length": {
            "type": "integer",
            "description": "The maximum allowable path length",
            "default": -1
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "not_before_duration": {
            "type": "integer",
            "description": "The duration before now which the certificate needs to be backdated by.",
            "format": "seconds",
            "default": 30,
            "x-vault-displayAttrs": {
              "value": 30
            }
          },
          "organization": {
            "type": "array",
            "description": "If set, O (Organization) will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "ou": {
            "type": "array",
            "description": "If set, OU (OrganizationalUnit) will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "OU (Organizational Unit)"
            }
          },
          "permitted_dns_domains": {
            "type": "array",
            "description": "Domains for which this certificate is allowed to sign or issue child certificates. If set, all DNS names (subject and alt) on child certs must be exact matches or subsets of the given domains (see https://tools.ietf.org/html/rfc5280#section-4.2.1.10).",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Permitted DNS Domains"
            }
          },
          "postal_code": {
            "type": "array",
            "description": "If set, Postal Code will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Postal Code"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "province": {
            "type": "array",
            "description": "If set, Province will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Province/State"
            }
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "signature_bits": {
            "type": "integer",
            "description": "The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "street_address": {
            "type": "array",
            "description": "If set, Street Address will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Street Address"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          },
          "use_pss": {
            "type": "boolean",
            "description": "Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.",
            "default": false
          }
        }
      },
      "PKIReplaceRootRequest": {
        "type": "object",
        "properties": {
          "default": {
            "type": "string",
            "description": "Reference (name or identifier) to the default issuer.",
            "default": "next"
          }
        }
      },
      "PKIRevokeRequest": {
        "type": "object",
        "properties": {
          "certificate": {
            "type": "string",
            "description": "Certificate to revoke in PEM format; must be signed by an issuer in this mount."
          },
          "serial_number": {
            "type": "string",
            "description": "Certificate serial number, in colon- or hyphen-separated octal"
          }
        }
      },
      "PKIRevokeWithKeyRequest": {
        "type": "object",
        "properties": {
          "certificate": {
            "type": "string",
            "description": "Certificate to revoke in PEM format; must be signed by an issuer in this mount."
          },
          "private_key": {
            "type": "string",
            "description": "Key to use to verify revocation permission; must be in PEM format."
          },
          "serial_number": {
            "type": "string",
            "description": "Certificate serial number, in colon- or hyphen-separated octal"
          }
        }
      },
      "PKIRootSignIntermediateRequest": {
        "type": "object",
        "properties": {
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans."
          },
          "country": {
            "type": "array",
            "description": "If set, Country will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "csr": {
            "type": "string",
            "description": "PEM-format CSR to be signed.",
            "default": ""
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "issuer_name": {
            "type": "string",
            "description": "Provide a name to the generated or existing issuer, the name must be unique across all issuers and not be the reserved value 'default'"
          },
          "issuer_ref": {
            "type": "string",
            "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
            "default": "default"
          },
          "locality": {
            "type": "array",
            "description": "If set, Locality will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Locality/City"
            }
          },
          "max_path_length": {
            "type": "integer",
            "description": "The maximum allowable path length",
            "default": -1
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "not_before_duration": {
            "type": "integer",
            "description": "The duration before now which the certificate needs to be backdated by.",
            "format": "seconds",
            "default": 30,
            "x-vault-displayAttrs": {
              "value": 30
            }
          },
          "organization": {
            "type": "array",
            "description": "If set, O (Organization) will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "ou": {
            "type": "array",
            "description": "If set, OU (OrganizationalUnit) will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "OU (Organizational Unit)"
            }
          },
          "permitted_dns_domains": {
            "type": "array",
            "description": "Domains for which this certificate is allowed to sign or issue child certificates. If set, all DNS names (subject and alt) on child certs must be exact matches or subsets of the given domains (see https://tools.ietf.org/html/rfc5280#section-4.2.1.10).",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Permitted DNS Domains"
            }
          },
          "postal_code": {
            "type": "array",
            "description": "If set, Postal Code will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Postal Code"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "province": {
            "type": "array",
            "description": "If set, Province will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Province/State"
            }
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "signature_bits": {
            "type": "integer",
            "description": "The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "skid": {
            "type": "string",
            "description": "Value for the Subject Key Identifier field (RFC 5280 Section 4.2.1.2). This value should ONLY be used when cross-signing to mimic the existing certificate's SKID value; this is necessary to allow certain TLS implementations (such as OpenSSL) which use SKID/AKID matches in chain building to restrict possible valid chains. Specified as a string in hex format. Default is empty, allowing Vault to automatically calculate the SKID according to method one in the above RFC section.",
            "default": "",
            "x-vault-displayAttrs": {
              "value": ""
            }
          },
          "street_address": {
            "type": "array",
            "description": "If set, Street Address will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Street Address"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          },
          "use_csr_values": {
            "type": "boolean",
            "description": "If true, then: 1) Subject information, including names and alternate names, will be preserved from the CSR rather than using values provided in the other parameters to this path; 2) Any key usages requested in the CSR will be added to the basic set of key usages used for CA certs signed by this path; for instance, the non-repudiation flag; 3) Extensions requested in the CSR will be copied into the issued certificate.",
            "default": false
          },
          "use_pss": {
            "type": "boolean",
            "description": "Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.",
            "default": false
          }
        }
      },
      "PKIRootSignSelfIssuedRequest": {
        "type": "object",
        "properties": {
          "certificate": {
            "type": "string",
            "description": "PEM-format self-issued certificate to be signed."
          },
          "issuer_ref": {
            "type": "string",
            "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
            "default": "default"
          },
          "require_matching_certificate_algorithms": {
            "type": "boolean",
            "description": "If true, require the public key algorithm of the signer to match that of the self issued certificate.",
            "default": false
          }
        }
      },
      "PKIRotateRootRequest": {
        "type": "object",
        "properties": {
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans."
          },
          "country": {
            "type": "array",
            "description": "If set, Country will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "issuer_name": {
            "type": "string",
            "description": "Provide a name to the generated or existing issuer, the name must be unique across all issuers and not be the reserved value 'default'"
          },
          "key_bits": {
            "type": "integer",
            "description": "The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "key_name": {
            "type": "string",
            "description": "Provide a name to the generated or existing key, the name must be unique across all keys and not be the reserved value 'default'"
          },
          "key_ref": {
            "type": "string",
            "description": "Reference to a existing key; either \"default\" for the configured default key, an identifier or the name assigned to the key.",
            "default": "default"
          },
          "key_type": {
            "type": "string",
            "description": "The type of key to use; defaults to RSA. \"rsa\" \"ec\" and \"ed25519\" are the only valid values.",
            "enum": [
              "rsa",
              "ec",
              "ed25519"
            ],
            "default": "rsa",
            "x-vault-displayAttrs": {
              "value": "rsa"
            }
          },
          "locality": {
            "type": "array",
            "description": "If set, Locality will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Locality/City"
            }
          },
          "managed_key_id": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types."
          },
          "managed_key_name": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types."
          },
          "max_path_length": {
            "type": "integer",
            "description": "The maximum allowable path length",
            "default": -1
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "not_before_duration": {
            "type": "integer",
            "description": "The duration before now which the certificate needs to be backdated by.",
            "format": "seconds",
            "default": 30,
            "x-vault-displayAttrs": {
              "value": 30
            }
          },
          "organization": {
            "type": "array",
            "description": "If set, O (Organization) will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "ou": {
            "type": "array",
            "description": "If set, OU (OrganizationalUnit) will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "OU (Organizational Unit)"
            }
          },
          "permitted_dns_domains": {
            "type": "array",
            "description": "Domains for which this certificate is allowed to sign or issue child certificates. If set, all DNS names (subject and alt) on child certs must be exact matches or subsets of the given domains (see https://tools.ietf.org/html/rfc5280#section-4.2.1.10).",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Permitted DNS Domains"
            }
          },
          "postal_code": {
            "type": "array",
            "description": "If set, Postal Code will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Postal Code"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "province": {
            "type": "array",
            "description": "If set, Province will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Province/State"
            }
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "signature_bits": {
            "type": "integer",
            "description": "The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "street_address": {
            "type": "array",
            "description": "If set, Street Address will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Street Address"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          },
          "use_pss": {
            "type": "boolean",
            "description": "Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.",
            "default": false
          }
        }
      },
      "PKISignRoleRequest": {
        "type": "object",
        "properties": {
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address."
          },
          "csr": {
            "type": "string",
            "description": "PEM-format CSR to be signed.",
            "default": ""
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "issuer_ref": {
            "type": "string",
            "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
            "default": "default"
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "remove_roots_from_chain": {
            "type": "boolean",
            "description": "Whether or not to remove self-signed CA certificates in the output of the ca_chain field.",
            "default": false
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          }
        }
      },
      "PKISignVerbatimRequest": {
        "type": "object",
        "properties": {
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address."
          },
          "csr": {
            "type": "string",
            "description": "PEM-format CSR to be signed. Values will be taken verbatim from the CSR, except for basic constraints.",
            "default": ""
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "ext_key_usage": {
            "type": "array",
            "description": "A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the \"ExtKeyUsage\" part of the name. To remove all key usages from being set, set this value to an empty list.",
            "items": {
              "type": "string"
            },
            "default": []
          },
          "ext_key_usage_oids": {
            "type": "array",
            "description": "A comma-separated string or list of extended key usage oids.",
            "items": {
              "type": "string"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "issuer_ref": {
            "type": "string",
            "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
            "default": "default"
          },
          "key_usage": {
            "type": "array",
            "description": "A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the \"KeyUsage\" part of the name. To remove all key usages from being set, set this value to an empty list.",
            "items": {
              "type": "string"
            },
            "default": [
              "DigitalSignature",
              "KeyAgreement",
              "KeyEncipherment"
            ]
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "remove_roots_from_chain": {
            "type": "boolean",
            "description": "Whether or not to remove self-signed CA certificates in the output of the ca_chain field.",
            "default": false
          },
          "role": {
            "type": "string",
            "description": "The desired role with configuration for this request"
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "signature_bits": {
            "type": "integer",
            "description": "The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          },
          "use_pss": {
            "type": "boolean",
            "description": "Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.",
            "default": false
          }
        }
      },
      "PKISignVerbatimRoleRequest": {
        "type": "object",
        "properties": {
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address."
          },
          "csr": {
            "type": "string",
            "description": "PEM-format CSR to be signed. Values will be taken verbatim from the CSR, except for basic constraints.",
            "default": ""
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "ext_key_usage": {
            "type": "array",
            "description": "A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the \"ExtKeyUsage\" part of the name. To remove all key usages from being set, set this value to an empty list.",
            "items": {
              "type": "string"
            },
            "default": []
          },
          "ext_key_usage_oids": {
            "type": "array",
            "description": "A comma-separated string or list of extended key usage oids.",
            "items": {
              "type": "string"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "issuer_ref": {
            "type": "string",
            "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
            "default": "default"
          },
          "key_usage": {
            "type": "array",
            "description": "A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the \"KeyUsage\" part of the name. To remove all key usages from being set, set this value to an empty list.",
            "items": {
              "type": "string"
            },
            "default": [
              "DigitalSignature",
              "KeyAgreement",
              "KeyEncipherment"
            ]
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "remove_roots_from_chain": {
            "type": "boolean",
            "description": "Whether or not to remove self-signed CA certificates in the output of the ca_chain field.",
            "default": false
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "signature_bits": {
            "type": "integer",
            "description": "The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          },
          "use_pss": {
            "type": "boolean",
            "description": "Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.",
            "default": false
          }
        }
      },
      "PKITidyRequest": {
        "type": "object",
        "properties": {
          "issuer_safety_buffer": {
            "type": "integer",
            "description": "The amount of extra time that must have passed beyond issuer's expiration before it is removed from the backend storage. Defaults to 8760 hours (1 year).",
            "format": "seconds",
            "default": 31536000
          },
          "pause_duration": {
            "type": "string",
            "description": "The amount of time to wait between processing certificates. This allows operators to change the execution profile of tidy to take consume less resources by slowing down how long it takes to run. Note that the entire list of certificates will be stored in memory during the entire tidy operation, but resources to read/process/update existing entries will be spread out over a greater period of time. By default this is zero seconds.",
            "default": "0s"
          },
          "safety_buffer": {
            "type": "integer",
            "description": "The amount of extra time that must have passed beyond certificate expiration before it is removed from the backend storage and/or revocation list. Defaults to 72 hours.",
            "format": "seconds",
            "default": 259200
          },
          "tidy_cert_store": {
            "type": "boolean",
            "description": "Set to true to enable tidying up the certificate store"
          },
          "tidy_expired_issuers": {
            "type": "boolean",
            "description": "Set to true to automatically remove expired issuers past the issuer_safety_buffer. No keys will be removed as part of this operation."
          },
          "tidy_revocation_list": {
            "type": "boolean",
            "description": "Deprecated; synonym for 'tidy_revoked_certs"
          },
          "tidy_revoked_cert_issuer_associations": {
            "type": "boolean",
            "description": "Set to true to validate issuer associations on revocation entries. This helps increase the performance of CRL building and OCSP responses."
          },
          "tidy_revoked_certs": {
            "type": "boolean",
            "description": "Set to true to expire all revoked and expired certificates, removing them both from the CRL and from storage. The CRL will be rotated if this causes any values to be removed."
          }
        }
      },
      "PKIWriteAutoTidyConfigRequest": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "Set to true to enable automatic tidy operations."
          },
          "interval_duration": {
            "type": "integer",
            "description": "Interval at which to run an auto-tidy operation. This is the time between tidy invocations (after one finishes to the start of the next). Running a manual tidy will reset this duration.",
            "format": "seconds",
            "default": 43200
          },
          "issuer_safety_buffer": {
            "type": "integer",
            "description": "The amount of extra time that must have passed beyond issuer's expiration before it is removed from the backend storage. Defaults to 8760 hours (1 year).",
            "format": "seconds",
            "default": 31536000
          },
          "pause_duration": {
            "type": "string",
            "description": "The amount of time to wait between processing certificates. This allows operators to change the execution profile of tidy to take consume less resources by slowing down how long it takes to run. Note that the entire list of certificates will be stored in memory during the entire tidy operation, but resources to read/process/update existing entries will be spread out over a greater period of time. By default this is zero seconds.",
            "default": "0s"
          },
          "safety_buffer": {
            "type": "integer",
            "description": "The amount of extra time that must have passed beyond certificate expiration before it is removed from the backend storage and/or revocation list. Defaults to 72 hours.",
            "format": "seconds",
            "default": 259200
          },
          "tidy_cert_store": {
            "type": "boolean",
            "description": "Set to true to enable tidying up the certificate store"
          },
          "tidy_expired_issuers": {
            "type": "boolean",
            "description": "Set to true to automatically remove expired issuers past the issuer_safety_buffer. No keys will be removed as part of this operation."
          },
          "tidy_revocation_list": {
            "type": "boolean",
            "description": "Deprecated; synonym for 'tidy_revoked_certs"
          },
          "tidy_revoked_cert_issuer_associations": {
            "type": "boolean",
            "description": "Set to true to validate issuer associations on revocation entries. This helps increase the performance of CRL building and OCSP responses."
          },
          "tidy_revoked_certs": {
            "type": "boolean",
            "description": "Set to true to expire all revoked and expired certificates, removing them both from the CRL and from storage. The CRL will be rotated if this causes any values to be removed."
          }
        }
      },
      "PKIWriteCAConfigRequest": {
        "type": "object",
        "properties": {
          "pem_bundle": {
            "type": "string",
            "description": "PEM-format, concatenated unencrypted secret key and certificate."
          }
        }
      },
      "PKIWriteCRLConfigRequest": {
        "type": "object",
        "properties": {
          "auto_rebuild": {
            "type": "boolean",
            "description": "If set to true, enables automatic rebuilding of the CRL"
          },
          "auto_rebuild_grace_period": {
            "type": "string",
            "description": "The time before the CRL expires to automatically rebuild it, when enabled. Must be shorter than the CRL expiry. Defaults to 12h.",
            "default": "12h"
          },
          "delta_rebuild_interval": {
            "type": "string",
            "description": "The time between delta CRL rebuilds if a new revocation has occurred. Must be shorter than the CRL expiry. Defaults to 15m.",
            "default": "15m"
          },
          "disable": {
            "type": "boolean",
            "description": "If set to true, disables generating the CRL entirely."
          },
          "enable_delta": {
            "type": "boolean",
            "description": "Whether to enable delta CRLs between authoritative CRL rebuilds"
          },
          "expiry": {
            "type": "string",
            "description": "The amount of time the generated CRL should be valid; defaults to 72 hours",
            "default": "72h"
          },
          "ocsp_disable": {
            "type": "boolean",
            "description": "If set to true, ocsp unauthorized responses will be returned."
          },
          "ocsp_expiry": {
            "type": "string",
            "description": "The amount of time an OCSP response will be valid (controls the NextUpdate field); defaults to 12 hours",
            "default": "1h"
          }
        }
      },
      "PKIWriteCertsRequest": {
        "type": "object",
        "properties": {
          "pem_bundle": {
            "type": "string",
            "description": "PEM-format, concatenated unencrypted secret-key (optional) and certificates."
          }
        }
      },
      "PKIWriteClusterConfigRequest": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "Canonical URI to this mount on this performance replication cluster's external address. This is for resolving AIA URLs and providing the {{cluster_path}} template parameter but might be used for other purposes in the future. This should only point back to this particular PR replica and should not ever point to another PR cluster. It may point to any node in the PR replica, including standby nodes, and need not always point to the active node. For example: https://pr1.vault.example.com:8200/v1/pki"
          }
        }
      },
      "PKIWriteIntermediateCrossSignRequest": {
        "type": "object",
        "properties": {
          "add_basic_constraints": {
            "type": "boolean",
            "description": "Whether to add a Basic Constraints extension with CA: true. Only needed as a workaround in some compatibility scenarios with Active Directory Certificate Services."
          },
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans."
          },
          "country": {
            "type": "array",
            "description": "If set, Country will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "exported": {
            "type": "string",
            "description": "Must be \"internal\", \"exported\" or \"kms\". If set to \"exported\", the generated private key will be returned. This is your *only* chance to retrieve the private key!",
            "enum": [
              "internal",
              "external",
              "kms"
            ]
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "key_bits": {
            "type": "integer",
            "description": "The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "key_name": {
            "type": "string",
            "description": "Provide a name to the generated or existing key, the name must be unique across all keys and not be the reserved value 'default'"
          },
          "key_ref": {
            "type": "string",
            "description": "Reference to a existing key; either \"default\" for the configured default key, an identifier or the name assigned to the key.",
            "default": "default"
          },
          "key_type": {
            "type": "string",
            "description": "The type of key to use; defaults to RSA. \"rsa\" \"ec\" and \"ed25519\" are the only valid values.",
            "enum": [
              "rsa",
              "ec",
              "ed25519"
            ],
            "default": "rsa",
            "x-vault-displayAttrs": {
              "value": "rsa"
            }
          },
          "locality": {
            "type": "array",
            "description": "If set, Locality will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Locality/City"
            }
          },
          "managed_key_id": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types."
          },
          "managed_key_name": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types."
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "not_before_duration": {
            "type": "integer",
            "description": "The duration before now which the certificate needs to be backdated by.",
            "format": "seconds",
            "default": 30,
            "x-vault-displayAttrs": {
              "value": 30
            }
          },
          "organization": {
            "type": "array",
            "description": "If set, O (Organization) will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "ou": {
            "type": "array",
            "description": "If set, OU (OrganizationalUnit) will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "OU (Organizational Unit)"
            }
          },
          "postal_code": {
            "type": "array",
            "description": "If set, Postal Code will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Postal Code"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "province": {
            "type": "array",
            "description": "If set, Province will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Province/State"
            }
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "signature_bits": {
            "type": "integer",
            "description": "The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "street_address": {
            "type": "array",
            "description": "If set, Street Address will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Street Address"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          }
        }
      },
      "PKIWriteIntermediateGenerateRequest": {
        "type": "object",
        "properties": {
          "add_basic_constraints": {
            "type": "boolean",
            "description": "Whether to add a Basic Constraints extension with CA: true. Only needed as a workaround in some compatibility scenarios with Active Directory Certificate Services."
          },
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. May contain both DNS names and email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If not specified when signing, the common name will be taken from the CSR; other names must still be specified in alt_names or ip_sans."
          },
          "country": {
            "type": "array",
            "description": "If set, Country will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "key_bits": {
            "type": "integer",
            "description": "The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "key_name": {
            "type": "string",
            "description": "Provide a name to the generated or existing key, the name must be unique across all keys and not be the reserved value 'default'"
          },
          "key_ref": {
            "type": "string",
            "description": "Reference to a existing key; either \"default\" for the configured default key, an identifier or the name assigned to the key.",
            "default": "default"
          },
          "key_type": {
            "type": "string",
            "description": "The type of key to use; defaults to RSA. \"rsa\" \"ec\" and \"ed25519\" are the only valid values.",
            "enum": [
              "rsa",
              "ec",
              "ed25519"
            ],
            "default": "rsa",
            "x-vault-displayAttrs": {
              "value": "rsa"
            }
          },
          "locality": {
            "type": "array",
            "description": "If set, Locality will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Locality/City"
            }
          },
          "managed_key_id": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types."
          },
          "managed_key_name": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types."
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "not_before_duration": {
            "type": "integer",
            "description": "The duration before now which the certificate needs to be backdated by.",
            "format": "seconds",
            "default": 30,
            "x-vault-displayAttrs": {
              "value": 30
            }
          },
          "organization": {
            "type": "array",
            "description": "If set, O (Organization) will be set to this value.",
            "items": {
              "type": "string"
            }
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "ou": {
            "type": "array",
            "description": "If set, OU (OrganizationalUnit) will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "OU (Organizational Unit)"
            }
          },
          "postal_code": {
            "type": "array",
            "description": "If set, Postal Code will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Postal Code"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "province": {
            "type": "array",
            "description": "If set, Province will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Province/State"
            }
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "signature_bits": {
            "type": "integer",
            "description": "The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).",
            "default": 0,
            "x-vault-displayAttrs": {
              "value": 0
            }
          },
          "street_address": {
            "type": "array",
            "description": "If set, Street Address will be set to this value.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Street Address"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          }
        }
      },
      "PKIWriteIntermediateSetSignedRequest": {
        "type": "object",
        "properties": {
          "certificate": {
            "type": "string",
            "description": "PEM-format certificate. This must be a CA certificate with a public key matching the previously-generated key from the generation endpoint. Additional parent CAs may be optionally appended to the bundle."
          }
        }
      },
      "PKIWriteInternalExportedRequest": {
        "type": "object",
        "properties": {
          "key_bits": {
            "type": "integer",
            "description": "The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.",
            "default": 0
          },
          "key_name": {
            "type": "string",
            "description": "Optional name to be used for this key"
          },
          "key_type": {
            "type": "string",
            "description": "The type of key to use; defaults to RSA. \"rsa\" \"ec\" and \"ed25519\" are the only valid values.",
            "enum": [
              "rsa",
              "ec",
              "ed25519"
            ],
            "default": "rsa",
            "x-vault-displayAttrs": {
              "value": "rsa"
            }
          },
          "managed_key_id": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types."
          },
          "managed_key_name": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types."
          }
        }
      },
      "PKIWriteIssueRoleRequest": {
        "type": "object",
        "properties": {
          "alt_names": {
            "type": "string",
            "description": "The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses.",
            "x-vault-displayAttrs": {
              "name": "DNS/Email Subject Alternative Names (SANs)"
            }
          },
          "common_name": {
            "type": "string",
            "description": "The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address."
          },
          "exclude_cn_from_sans": {
            "type": "boolean",
            "description": "If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).",
            "default": false,
            "x-vault-displayAttrs": {
              "name": "Exclude Common Name from Subject Alternative Names (SANs)"
            }
          },
          "format": {
            "type": "string",
            "description": "Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".",
            "enum": [
              "pem",
              "der",
              "pem_bundle"
            ],
            "default": "pem",
            "x-vault-displayAttrs": {
              "value": "pem"
            }
          },
          "ip_sans": {
            "type": "array",
            "description": "The requested IP SANs, if any, in a comma-delimited list",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "IP Subject Alternative Names (SANs)"
            }
          },
          "issuer_ref": {
            "type": "string",
            "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
            "default": "default"
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ"
          },
          "other_sans": {
            "type": "array",
            "description": "Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Other SANs"
            }
          },
          "private_key_format": {
            "type": "string",
            "description": "Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".",
            "enum": [
              "",
              "der",
              "pem",
              "pkcs8"
            ],
            "default": "der",
            "x-vault-displayAttrs": {
              "value": "der"
            }
          },
          "remove_roots_from_chain": {
            "type": "boolean",
            "description": "Whether or not to remove self-signed CA certificates in the output of the ca_chain field.",
            "default": false
          },
          "serial_number": {
            "type": "string",
            "description": "The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field."
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "uri_sans": {
            "type": "array",
            "description": "The requested URI SANs, if any, in a comma-delimited list.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "URI Subject Alternative Names (SANs)"
            }
          }
        }
      },
      "PKIWriteIssuersConfigRequest": {
        "type": "object",
        "properties": {
          "default": {
            "type": "string",
            "description": "Reference (name or identifier) to the default issuer."
          },
          "default_follows_latest_issuer": {
            "type": "boolean",
            "description": "Whether the default issuer should automatically follow the latest generated or imported issuer. Defaults to false.",
            "default": false
          }
        }
      },
      "PKIWriteKMSRequest": {
        "type": "object",
        "properties": {
          "key_bits": {
            "type": "integer",
            "description": "The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.",
            "default": 0
          },
          "key_name": {
            "type": "string",
            "description": "Optional name to be used for this key"
          },
          "key_type": {
            "type": "string",
            "description": "The type of key to use; defaults to RSA. \"rsa\" \"ec\" and \"ed25519\" are the only valid values.",
            "enum": [
              "rsa",
              "ec",
              "ed25519"
            ],
            "default": "rsa",
            "x-vault-displayAttrs": {
              "value": "rsa"
            }
          },
          "managed_key_id": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_name is required. Ignored for other types."
          },
          "managed_key_name": {
            "type": "string",
            "description": "The name of the managed key to use when the exported type is kms. When kms type is the key type, this field or managed_key_id is required. Ignored for other types."
          }
        }
      },
      "PKIWriteKeyRequest": {
        "type": "object",
        "properties": {
          "key_name": {
            "type": "string",
            "description": "Human-readable name for this key."
          }
        }
      },
      "PKIWriteKeysConfigRequest": {
        "type": "object",
        "properties": {
          "default": {
            "type": "string",
            "description": "Reference (name or identifier) of the default key."
          }
        }
      },
      "PKIWriteRoleRequest": {
        "type": "object",
        "properties": {
          "allow_any_name": {
            "type": "boolean",
            "description": "If set, clients can request certificates for any domain, regardless of allowed_domains restrictions. See the documentation for more information."
          },
          "allow_bare_domains": {
            "type": "boolean",
            "description": "If set, clients can request certificates for the base domains themselves, e.g. \"example.com\" of domains listed in allowed_domains. This is a separate option as in some cases this can be considered a security threat. See the documentation for more information."
          },
          "allow_glob_domains": {
            "type": "boolean",
            "description": "If set, domains specified in allowed_domains can include shell-style glob patterns, e.g. \"ftp*.example.com\". See the documentation for more information."
          },
          "allow_ip_sans": {
            "type": "boolean",
            "description": "If set, IP Subject Alternative Names are allowed. Any valid IP is accepted and No authorization checking is performed.",
            "default": true,
            "x-vault-displayAttrs": {
              "name": "Allow IP Subject Alternative Names",
              "value": true
            }
          },
          "allow_localhost": {
            "type": "boolean",
            "description": "Whether to allow \"localhost\" and \"localdomain\" as a valid common name in a request, independent of allowed_domains value.",
            "default": true,
            "x-vault-displayAttrs": {
              "value": true
            }
          },
          "allow_subdomains": {
            "type": "boolean",
            "description": "If set, clients can request certificates for subdomains of domains listed in allowed_domains, including wildcard subdomains. See the documentation for more information."
          },
          "allow_wildcard_certificates": {
            "type": "boolean",
            "description": "If set, allows certificates with wildcards in the common name to be issued, conforming to RFC 6125's Section 6.4.3; e.g., \"*.example.net\" or \"b*z.example.net\". See the documentation for more information.",
            "default": true
          },
          "allowed_domains": {
            "type": "array",
            "description": "Specifies the domains this role is allowed to issue certificates for. This is used with the allow_bare_domains, allow_subdomains, and allow_glob_domains to determine matches for the common name, DNS-typed SAN entries, and Email-typed SAN entries of certificates. See the documentation for more information. This parameter accepts a comma-separated string or list of domains.",
            "items": {
              "type": "string"
            }
          },
          "allowed_domains_template": {
            "type": "boolean",
            "description": "If set, Allowed domains can be specified using identity template policies. Non-templated domains are also permitted.",
            "default": false
          },
          "allowed_other_sans": {
            "type": "array",
            "description": "If set, an array of allowed other names to put in SANs. These values support globbing and must be in the format <oid>;<type>:<value>. Currently only \"utf8\" is a valid type. All values, including globbing values, must use this syntax, with the exception being a single \"*\" which allows any OID and any value (but type must still be utf8).",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Allowed Other Subject Alternative Names"
            }
          },
          "allowed_serial_numbers": {
            "type": "array",
            "description": "If set, an array of allowed serial numbers to put in Subject. These values support globbing.",
            "items": {
              "type": "string"
            }
          },
          "allowed_uri_sans": {
            "type": "array",
            "description": "If set, an array of allowed URIs for URI Subject Alternative Names. Any valid URI is accepted, these values support globbing.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Allowed URI Subject Alternative Names"
            }
          },
          "allowed_uri_sans_template": {
            "type": "boolean",
            "description": "If set, Allowed URI SANs can be specified using identity template policies. Non-templated URI SANs are also permitted.",
            "default": false
          },
          "backend": {
            "type": "string",
            "description": "Backend Type"
          },
          "basic_constraints_valid_for_non_ca": {
            "type": "boolean",
            "description": "Mark Basic Constraints valid when issuing non-CA certificates.",
            "x-vault-displayAttrs": {
              "name": "Basic Constraints Valid for Non-CA"
            }
          },
          "client_flag": {
            "type": "boolean",
            "description": "If set, certificates are flagged for client auth use. Defaults to true. See also RFC 5280 Section 4.2.1.12.",
            "default": true,
            "x-vault-displayAttrs": {
              "value": true
            }
          },
          "cn_validations": {
            "type": "array",
            "description": "List of allowed validations to run against the Common Name field. Values can include 'email' to validate the CN is a email address, 'hostname' to validate the CN is a valid hostname (potentially including wildcards). When multiple validations are specified, these take OR semantics (either email OR hostname are allowed). The special value 'disabled' allows disabling all CN name validations, allowing for arbitrary non-Hostname, non-Email address CNs.",
            "items": {
              "type": "string"
            },
            "default": [
              "email",
              "hostname"
            ],
            "x-vault-displayAttrs": {
              "name": "Common Name Validations"
            }
          },
          "code_signing_flag": {
            "type": "boolean",
            "description": "If set, certificates are flagged for code signing use. Defaults to false. See also RFC 5280 Section 4.2.1.12."
          },
          "country": {
            "type": "array",
            "description": "If set, Country will be set to this value in certificates issued by this role.",
            "items": {
              "type": "string"
            }
          },
          "email_protection_flag": {
            "type": "boolean",
            "description": "If set, certificates are flagged for email protection use. Defaults to false. See also RFC 5280 Section 4.2.1.12."
          },
          "enforce_hostnames": {
            "type": "boolean",
            "description": "If set, only valid host names are allowed for CN and DNS SANs, and the host part of email addresses. Defaults to true.",
            "default": true,
            "x-vault-displayAttrs": {
              "value": true
            }
          },
          "ext_key_usage": {
            "type": "array",
            "description": "A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the \"ExtKeyUsage\" part of the name. To remove all key usages from being set, set this value to an empty list. See also RFC 5280 Section 4.2.1.12.",
            "items": {
              "type": "string"
            },
            "default": [],
            "x-vault-displayAttrs": {
              "name": "Extended Key Usage"
            }
          },
          "ext_key_usage_oids": {
            "type": "array",
            "description": "A comma-separated string or list of extended key usage oids.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Extended Key Usage OIDs"
            }
          },
          "generate_lease": {
            "type": "boolean",
            "description": "If set, certificates issued/signed against this role will have Vault leases attached to them. Defaults to \"false\". Certificates can be added to the CRL by \"vault revoke <lease_id>\" when certificates are associated with leases. It can also be done using the \"pki/revoke\" endpoint. However, when lease generation is disabled, invoking \"pki/revoke\" would be the only way to add the certificates to the CRL. When large number of certificates are generated with long lifetimes, it is recommended that lease generation be disabled, as large amount of leases adversely affect the startup time of Vault."
          },
          "issuer_ref": {
            "type": "string",
            "description": "Reference to the issuer used to sign requests serviced by this role.",
            "default": "default"
          },
          "key_bits": {
            "type": "integer",
            "description": "The number of bits to use. Allowed values are 0 (universal default); with rsa key_type: 2048 (default), 3072, or 4096; with ec key_type: 224, 256 (default), 384, or 521; ignored with ed25519.",
            "default": 0
          },
          "key_type": {
            "type": "string",
            "description": "The type of key to use; defaults to RSA. \"rsa\" \"ec\", \"ed25519\" and \"any\" are the only valid values.",
            "enum": [
              "rsa",
              "ec",
              "ed25519",
              "any"
            ],
            "default": "rsa"
          },
          "key_usage": {
            "type": "array",
            "description": "A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the \"KeyUsage\" part of the name. To remove all key usages from being set, set this value to an empty list. See also RFC 5280 Section 4.2.1.3.",
            "items": {
              "type": "string"
            },
            "default": [
              "DigitalSignature",
              "KeyAgreement",
              "KeyEncipherment"
            ],
            "x-vault-displayAttrs": {
              "value": "DigitalSignature,KeyAgreement,KeyEncipherment"
            }
          },
          "locality": {
            "type": "array",
            "description": "If set, Locality will be set to this value in certificates issued by this role.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Locality/City"
            }
          },
          "max_ttl": {
            "type": "integer",
            "description": "The maximum allowed lease duration. If not set, defaults to the system maximum lease TTL.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Max TTL"
            }
          },
          "no_store": {
            "type": "boolean",
            "description": "If set, certificates issued/signed against this role will not be stored in the storage backend. This can improve performance when issuing large numbers of certificates. However, certificates issued in this way cannot be enumerated or revoked, so this option is recommended only for certificates that are non-sensitive, or extremely short-lived. This option implies a value of \"false\" for \"generate_lease\"."
          },
          "not_after": {
            "type": "string",
            "description": "Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ."
          },
          "not_before_duration": {
            "type": "integer",
            "description": "The duration before now which the certificate needs to be backdated by.",
            "format": "seconds",
            "default": 30,
            "x-vault-displayAttrs": {
              "value": 30
            }
          },
          "organization": {
            "type": "array",
            "description": "If set, O (Organization) will be set to this value in certificates issued by this role.",
            "items": {
              "type": "string"
            }
          },
          "ou": {
            "type": "array",
            "description": "If set, OU (OrganizationalUnit) will be set to this value in certificates issued by this role.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Organizational Unit"
            }
          },
          "policy_identifiers": {
            "type": "array",
            "description": "A comma-separated string or list of policy OIDs, or a JSON list of qualified policy information, which must include an oid, and may include a notice and/or cps url, using the form [{\"oid\"=\"1.3.6.1.4.1.7.8\",\"notice\"=\"I am a user Notice\"}, {\"oid\"=\"1.3.6.1.4.1.44947.1.2.4 \",\"cps\"=\"https://example.com\"}].",
            "items": {
              "type": "string"
            }
          },
          "postal_code": {
            "type": "array",
            "description": "If set, Postal Code will be set to this value in certificates issued by this role.",
            "items": {
              "type": "string"
            }
          },
          "province": {
            "type": "array",
            "description": "If set, Province will be set to this value in certificates issued by this role.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Province/State"
            }
          },
          "require_cn": {
            "type": "boolean",
            "description": "If set to false, makes the 'common_name' field optional while generating a certificate.",
            "default": true,
            "x-vault-displayAttrs": {
              "name": "Require Common Name"
            }
          },
          "server_flag": {
            "type": "boolean",
            "description": "If set, certificates are flagged for server auth use. Defaults to true. See also RFC 5280 Section 4.2.1.12.",
            "default": true,
            "x-vault-displayAttrs": {
              "value": true
            }
          },
          "signature_bits": {
            "type": "integer",
            "description": "The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).",
            "default": 0
          },
          "street_address": {
            "type": "array",
            "description": "If set, Street Address will be set to this value in certificates issued by this role.",
            "items": {
              "type": "string"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "The lease duration (validity period of the certificate) if no specific lease duration is requested. The lease duration controls the expiration of certificates issued by this backend. Defaults to the system default value or the value of max_ttl, whichever is shorter.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          },
          "use_csr_common_name": {
            "type": "boolean",
            "description": "If set, when used with a signing profile, the common name in the CSR will be used. This does *not* include any requested Subject Alternative Names; use use_csr_sans for that. Defaults to true.",
            "default": true,
            "x-vault-displayAttrs": {
              "name": "Use CSR Common Name",
              "value": true
            }
          },
          "use_csr_sans": {
            "type": "boolean",
            "description": "If set, when used with a signing profile, the SANs in the CSR will be used. This does *not* include the Common Name (cn); use use_csr_common_name for that. Defaults to true.",
            "default": true,
            "x-vault-displayAttrs": {
              "name": "Use CSR Subject Alternative Names",
              "value": true
            }
          },
          "use_pss": {
            "type": "boolean",
            "description": "Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.",
            "default": false
          }
        }
      },
      "PKIWriteURLConfigRequest": {
        "type": "object",
        "properties": {
          "crl_distribution_points": {
            "type": "array",
            "description": "Comma-separated list of URLs to be used for the CRL distribution points attribute. See also RFC 5280 Section 4.2.1.13.",
            "items": {
              "type": "string"
            }
          },
          "enable_templating": {
            "type": "boolean",
            "description": "Whether or not to enabling templating of the above AIA fields. When templating is enabled the special values '{{issuer_id}}' and '{{cluster_path}}' are available, but the addresses are not checked for URI validity until issuance time. This requires /config/cluster's path to be set on all PR Secondary clusters.",
            "default": false
          },
          "issuing_certificates": {
            "type": "array",
            "description": "Comma-separated list of URLs to be used for the issuing certificate attribute. See also RFC 5280 Section 4.2.2.1.",
            "items": {
              "type": "string"
            }
          },
          "ocsp_servers": {
            "type": "array",
            "description": "Comma-separated list of URLs to be used for the OCSP servers attribute. See also RFC 5280 Section 4.2.2.1.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "PersonaIDWriteByIDRequest": {
        "type": "object",
        "properties": {
          "entity_id": {
            "type": "string",
            "description": "Entity ID to which this persona should be tied to"
          },
          "metadata": {
            "type": "object",
            "description": "Metadata to be associated with the persona. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
            "format": "kvpairs"
          },
          "mount_accessor": {
            "type": "string",
            "description": "Mount accessor to which this persona belongs to"
          },
          "name": {
            "type": "string",
            "description": "Name of the persona"
          }
        }
      },
      "PersonaWriteRequest": {
        "type": "object",
        "properties": {
          "entity_id": {
            "type": "string",
            "description": "Entity ID to which this persona belongs to"
          },
          "id": {
            "type": "string",
            "description": "ID of the persona"
          },
          "metadata": {
            "type": "object",
            "description": "Metadata to be associated with the persona. In CLI, this parameter can be repeated multiple times, and it all gets merged together. For example: vault <command> <path> metadata=key1=value1 metadata=key2=value2",
            "format": "kvpairs"
          },
          "mount_accessor": {
            "type": "string",
            "description": "Mount accessor to which this persona belongs to"
          },
          "name": {
            "type": "string",
            "description": "Name of the persona"
          }
        }
      },
      "PkiWriteIssuerRefDerPemRequest": {
        "type": "object",
        "properties": {
          "crl_distribution_points": {
            "type": "array",
            "description": "Comma-separated list of URLs to be used for the CRL distribution points attribute. See also RFC 5280 Section 4.2.1.13.",
            "items": {
              "type": "string"
            }
          },
          "enable_aia_url_templating": {
            "type": "boolean",
            "description": "Whether or not to enabling templating of the above AIA fields. When templating is enabled the special values '{{issuer_id}}' and '{{cluster_path}}' are available, but the addresses are not checked for URL validity until issuance time. This requires /config/cluster's path to be set on all PR Secondary clusters.",
            "default": false
          },
          "issuer_name": {
            "type": "string",
            "description": "Provide a name to the generated or existing issuer, the name must be unique across all issuers and not be the reserved value 'default'"
          },
          "issuing_certificates": {
            "type": "array",
            "description": "Comma-separated list of URLs to be used for the issuing certificate attribute. See also RFC 5280 Section 4.2.2.1.",
            "items": {
              "type": "string"
            }
          },
          "leaf_not_after_behavior": {
            "type": "string",
            "description": "Behavior of leaf's NotAfter fields: \"err\" to error if the computed NotAfter date exceeds that of this issuer; \"truncate\" to silently truncate to that of this issuer; or \"permit\" to allow this issuance to succeed (with NotAfter exceeding that of an issuer). Note that not all values will results in certificates that can be validated through the entire validity period. It is suggested to use \"truncate\" for intermediate CAs and \"permit\" only for root CAs.",
            "default": "err"
          },
          "manual_chain": {
            "type": "array",
            "description": "Chain of issuer references to use to build this issuer's computed CAChain field, when non-empty.",
            "items": {
              "type": "string"
            }
          },
          "ocsp_servers": {
            "type": "array",
            "description": "Comma-separated list of URLs to be used for the OCSP servers attribute. See also RFC 5280 Section 4.2.2.1.",
            "items": {
              "type": "string"
            }
          },
          "revocation_signature_algorithm": {
            "type": "string",
            "description": "Which x509.SignatureAlgorithm name to use for signing CRLs. This parameter allows differentiation between PKCS#1v1.5 and PSS keys and choice of signature hash algorithm. The default (empty string) value is for Go to select the signature algorithm. This can fail if the underlying key does not support the requested signature algorithm, which may not be known at modification time (such as with PKCS#11 managed RSA keys).",
            "default": ""
          },
          "usage": {
            "type": "array",
            "description": "Comma-separated list (or string slice) of usages for this issuer; valid values are \"read-only\", \"issuing-certificates\", \"crl-signing\", and \"ocsp-signing\". Multiple values may be specified. Read-only is implicit and always set.",
            "items": {
              "type": "string"
            },
            "default": [
              "read-only",
              "issuing-certificates",
              "crl-signing",
              "ocsp-signing"
            ]
          }
        }
      },
      "PkiWriteJsonRequest": {
        "type": "object",
        "properties": {
          "crl_distribution_points": {
            "type": "array",
            "description": "Comma-separated list of URLs to be used for the CRL distribution points attribute. See also RFC 5280 Section 4.2.1.13.",
            "items": {
              "type": "string"
            }
          },
          "enable_aia_url_templating": {
            "type": "boolean",
            "description": "Whether or not to enabling templating of the above AIA fields. When templating is enabled the special values '{{issuer_id}}' and '{{cluster_path}}' are available, but the addresses are not checked for URL validity until issuance time. This requires /config/cluster's path to be set on all PR Secondary clusters.",
            "default": false
          },
          "issuer_name": {
            "type": "string",
            "description": "Provide a name to the generated or existing issuer, the name must be unique across all issuers and not be the reserved value 'default'"
          },
          "issuer_ref": {
            "type": "string",
            "description": "Reference to a existing issuer; either \"default\" for the configured default issuer, an identifier or the name assigned to the issuer.",
            "default": "default"
          },
          "issuing_certificates": {
            "type": "array",
            "description": "Comma-separated list of URLs to be used for the issuing certificate attribute. See also RFC 5280 Section 4.2.2.1.",
            "items": {
              "type": "string"
            }
          },
          "leaf_not_after_behavior": {
            "type": "string",
            "description": "Behavior of leaf's NotAfter fields: \"err\" to error if the computed NotAfter date exceeds that of this issuer; \"truncate\" to silently truncate to that of this issuer; or \"permit\" to allow this issuance to succeed (with NotAfter exceeding that of an issuer). Note that not all values will results in certificates that can be validated through the entire validity period. It is suggested to use \"truncate\" for intermediate CAs and \"permit\" only for root CAs.",
            "default": "err"
          },
          "manual_chain": {
            "type": "array",
            "description": "Chain of issuer references to use to build this issuer's computed CAChain field, when non-empty.",
            "items": {
              "type": "string"
            }
          },
          "ocsp_servers": {
            "type": "array",
            "description": "Comma-separated list of URLs to be used for the OCSP servers attribute. See also RFC 5280 Section 4.2.2.1.",
            "items": {
              "type": "string"
            }
          },
          "revocation_signature_algorithm": {
            "type": "string",
            "description": "Which x509.SignatureAlgorithm name to use for signing CRLs. This parameter allows differentiation between PKCS#1v1.5 and PSS keys and choice of signature hash algorithm. The default (empty string) value is for Go to select the signature algorithm. This can fail if the underlying key does not support the requested signature algorithm, which may not be known at modification time (such as with PKCS#11 managed RSA keys).",
            "default": ""
          },
          "usage": {
            "type": "array",
            "description": "Comma-separated list (or string slice) of usages for this issuer; valid values are \"read-only\", \"issuing-certificates\", \"crl-signing\", and \"ocsp-signing\". Multiple values may be specified. Read-only is implicit and always set.",
            "items": {
              "type": "string"
            },
            "default": [
              "read-only",
              "issuing-certificates",
              "crl-signing",
              "ocsp-signing"
            ]
          }
        }
      },
      "RabbitMQWriteConnectionConfigRequest": {
        "type": "object",
        "properties": {
          "connection_uri": {
            "type": "string",
            "description": "RabbitMQ Management URI"
          },
          "password": {
            "type": "string",
            "description": "Password of the provided RabbitMQ management user"
          },
          "password_policy": {
            "type": "string",
            "description": "Name of the password policy to use to generate passwords for dynamic credentials."
          },
          "username": {
            "type": "string",
            "description": "Username of a RabbitMQ management administrator"
          },
          "username_template": {
            "type": "string",
            "description": "Template describing how dynamic usernames are generated."
          },
          "verify_connection": {
            "type": "boolean",
            "description": "If set, connection_uri is verified by actually connecting to the RabbitMQ management API",
            "default": true
          }
        }
      },
      "RabbitMQWriteLeaseConfigRequest": {
        "type": "object",
        "properties": {
          "max_ttl": {
            "type": "integer",
            "description": "Duration after which the issued credentials should not be allowed to be renewed",
            "format": "seconds",
            "default": 0
          },
          "ttl": {
            "type": "integer",
            "description": "Duration before which the issued credentials needs renewal",
            "format": "seconds",
            "default": 0
          }
        }
      },
      "RabbitMQWriteRoleRequest": {
        "type": "object",
        "properties": {
          "tags": {
            "type": "string",
            "description": "Comma-separated list of tags for this role."
          },
          "vhost_topics": {
            "type": "string",
            "description": "A nested map of virtual hosts and exchanges to topic permissions."
          },
          "vhosts": {
            "type": "string",
            "description": "A map of virtual hosts to permissions."
          }
        }
      },
      "RadiusLoginRequest": {
        "type": "object",
        "properties": {
          "password": {
            "type": "string",
            "description": "Password for this user."
          },
          "urlusername": {
            "type": "string",
            "description": "Username to be used for login. (URL parameter)"
          },
          "username": {
            "type": "string",
            "description": "Username to be used for login. (POST request body)"
          }
        }
      },
      "RadiusLoginWithUsernameRequest": {
        "type": "object",
        "properties": {
          "password": {
            "type": "string",
            "description": "Password for this user."
          },
          "username": {
            "type": "string",
            "description": "Username to be used for login. (POST request body)"
          }
        }
      },
      "RadiusWriteConfigRequest": {
        "type": "object",
        "properties": {
          "dial_timeout": {
            "type": "integer",
            "description": "Number of seconds before connect times out (default: 10)",
            "format": "seconds",
            "default": 10,
            "x-vault-displayAttrs": {
              "value": 10
            }
          },
          "host": {
            "type": "string",
            "description": "RADIUS server host",
            "x-vault-displayAttrs": {
              "name": "Host"
            }
          },
          "nas_identifier": {
            "type": "string",
            "description": "RADIUS NAS Identifier field (optional)",
            "default": "",
            "x-vault-displayAttrs": {
              "name": "NAS Identifier"
            }
          },
          "nas_port": {
            "type": "integer",
            "description": "RADIUS NAS port field (default: 10)",
            "default": 10,
            "x-vault-displayAttrs": {
              "name": "NAS Port",
              "value": 10
            }
          },
          "port": {
            "type": "integer",
            "description": "RADIUS server port (default: 1812)",
            "default": 1812,
            "x-vault-displayAttrs": {
              "value": 1812
            }
          },
          "read_timeout": {
            "type": "integer",
            "description": "Number of seconds before response times out (default: 10)",
            "format": "seconds",
            "default": 10,
            "x-vault-displayAttrs": {
              "value": 10
            }
          },
          "secret": {
            "type": "string",
            "description": "Secret shared with the RADIUS server"
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies. This will apply to all tokens generated by this auth method, in addition to any configured for specific users.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "unregistered_user_policies": {
            "type": "string",
            "description": "Comma-separated list of policies to grant upon successful RADIUS authentication of an unregisted user (default: empty)",
            "default": "",
            "x-vault-displayAttrs": {
              "name": "Policies for unregistered users"
            }
          }
        }
      },
      "RadiusWriteUserRequest": {
        "type": "object",
        "properties": {
          "policies": {
            "type": "array",
            "description": "Comma-separated list of policies associated to the user.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "RemountRequest": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "description": "The previous mount point."
          },
          "to": {
            "type": "string",
            "description": "The new mount point."
          }
        }
      },
      "RenewForRequest": {
        "type": "object",
        "properties": {
          "increment": {
            "type": "integer",
            "description": "The desired increment in seconds to the lease",
            "format": "seconds"
          },
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "RenewRequest": {
        "type": "object",
        "properties": {
          "increment": {
            "type": "integer",
            "description": "The desired increment in seconds to the lease",
            "format": "seconds"
          },
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          },
          "url_lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "RevokeLeaseRequest": {
        "type": "object",
        "properties": {
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          },
          "sync": {
            "type": "boolean",
            "description": "Whether or not to perform the revocation synchronously",
            "default": true
          }
        }
      },
      "RevokePrefixRequest": {
        "type": "object",
        "properties": {
          "sync": {
            "type": "boolean",
            "description": "Whether or not to perform the revocation synchronously",
            "default": true
          }
        }
      },
      "RevokeRequest": {
        "type": "object",
        "properties": {
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          },
          "sync": {
            "type": "boolean",
            "description": "Whether or not to perform the revocation synchronously",
            "default": true
          },
          "url_lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "SSHLookupRequest": {
        "type": "object",
        "properties": {
          "ip": {
            "type": "string",
            "description": "[Required] IP address of remote host"
          }
        }
      },
      "SSHSignRequest": {
        "type": "object",
        "properties": {
          "cert_type": {
            "type": "string",
            "description": "Type of certificate to be created; either \"user\" or \"host\".",
            "default": "user"
          },
          "critical_options": {
            "type": "object",
            "description": "Critical options that the certificate should be signed for.",
            "format": "map"
          },
          "extensions": {
            "type": "object",
            "description": "Extensions that the certificate should be signed for.",
            "format": "map"
          },
          "key_id": {
            "type": "string",
            "description": "Key id that the created certificate should have. If not specified, the display name of the token will be used."
          },
          "public_key": {
            "type": "string",
            "description": "SSH public key that should be signed."
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the SSH certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be later than the role max TTL.",
            "format": "seconds"
          },
          "valid_principals": {
            "type": "string",
            "description": "Valid principals, either usernames or hostnames, that the certificate should be signed for."
          }
        }
      },
      "SSHVerifyRequest": {
        "type": "object",
        "properties": {
          "otp": {
            "type": "string",
            "description": "[Required] One-Time-Key that needs to be validated"
          }
        }
      },
      "SSHWriteCAConfigRequest": {
        "type": "object",
        "properties": {
          "generate_signing_key": {
            "type": "boolean",
            "description": "Generate SSH key pair internally rather than use the private_key and public_key fields.",
            "default": true
          },
          "key_bits": {
            "type": "integer",
            "description": "Specifies the desired key bits when generating variable-length keys (such as when key_type=\"ssh-rsa\") or which NIST P-curve to use when key_type=\"ec\" (256, 384, or 521).",
            "default": 0
          },
          "key_type": {
            "type": "string",
            "description": "Specifies the desired key type when generating; could be a OpenSSH key type identifier (ssh-rsa, ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, ecdsa-sha2-nistp521, or ssh-ed25519) or an algorithm (rsa, ec, ed25519).",
            "default": "ssh-rsa"
          },
          "private_key": {
            "type": "string",
            "description": "Private half of the SSH key that will be used to sign certificates."
          },
          "public_key": {
            "type": "string",
            "description": "Public half of the SSH key that will be used to sign certificates."
          }
        }
      },
      "SSHWriteCredentialsRequest": {
        "type": "object",
        "properties": {
          "ip": {
            "type": "string",
            "description": "[Required] IP of the remote host"
          },
          "username": {
            "type": "string",
            "description": "[Optional] Username in remote host"
          }
        }
      },
      "SSHWriteIssueRequest": {
        "type": "object",
        "properties": {
          "cert_type": {
            "type": "string",
            "description": "Type of certificate to be created; either \"user\" or \"host\".",
            "default": "user"
          },
          "critical_options": {
            "type": "object",
            "description": "Critical options that the certificate should be signed for.",
            "format": "map"
          },
          "extensions": {
            "type": "object",
            "description": "Extensions that the certificate should be signed for.",
            "format": "map"
          },
          "key_bits": {
            "type": "integer",
            "description": "Specifies the number of bits to use for the generated keys.",
            "default": 0
          },
          "key_id": {
            "type": "string",
            "description": "Key id that the created certificate should have. If not specified, the display name of the token will be used."
          },
          "key_type": {
            "type": "string",
            "description": "Specifies the desired key type; must be `rsa`, `ed25519` or `ec`",
            "default": "rsa"
          },
          "ttl": {
            "type": "integer",
            "description": "The requested Time To Live for the SSH certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be later than the role max TTL.",
            "format": "seconds"
          },
          "valid_principals": {
            "type": "string",
            "description": "Valid principals, either usernames or hostnames, that the certificate should be signed for."
          }
        }
      },
      "SSHWriteKeysRequest": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "[Required] SSH private key with super user privileges in host"
          }
        }
      },
      "SSHWriteRoleRequest": {
        "type": "object",
        "properties": {
          "admin_user": {
            "type": "string",
            "description": "[Required for Dynamic type] [Not applicable for OTP type] [Not applicable for CA type] Admin user at remote host. The shared key being registered should be for this user and should have root privileges. Everytime a dynamic credential is being generated for other users, Vault uses this admin username to login to remote host and install the generated credential for the other user.",
            "x-vault-displayAttrs": {
              "name": "Admin Username"
            }
          },
          "algorithm_signer": {
            "type": "string",
            "description": "When supplied, this value specifies a signing algorithm for the key. Possible values: ssh-rsa, rsa-sha2-256, rsa-sha2-512, default, or the empty string.",
            "enum": [
              "",
              "ssh-rsa",
              "rsa-sha2-256",
              "rsa-sha2-512"
            ],
            "x-vault-displayAttrs": {
              "name": "Signing Algorithm"
            }
          },
          "allow_bare_domains": {
            "type": "boolean",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, host certificates that are requested are allowed to use the base domains listed in \"allowed_domains\", e.g. \"example.com\". This is a separate option as in some cases this can be considered a security threat."
          },
          "allow_host_certificates": {
            "type": "boolean",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, certificates are allowed to be signed for use as a 'host'.",
            "default": false
          },
          "allow_subdomains": {
            "type": "boolean",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, host certificates that are requested are allowed to use subdomains of those listed in \"allowed_domains\"."
          },
          "allow_user_certificates": {
            "type": "boolean",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, certificates are allowed to be signed for use as a 'user'.",
            "default": false
          },
          "allow_user_key_ids": {
            "type": "boolean",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If true, users can override the key ID for a signed certificate with the \"key_id\" field. When false, the key ID will always be the token display name. The key ID is logged by the SSH server and can be useful for auditing.",
            "x-vault-displayAttrs": {
              "name": "Allow User Key IDs"
            }
          },
          "allowed_critical_options": {
            "type": "string",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] A comma-separated list of critical options that certificates can have when signed. To allow any critical options, set this to an empty string."
          },
          "allowed_domains": {
            "type": "string",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If this option is not specified, client can request for a signed certificate for any valid host. If only certain domains are allowed, then this list enforces it."
          },
          "allowed_domains_template": {
            "type": "boolean",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, Allowed domains can be specified using identity template policies. Non-templated domains are also permitted.",
            "default": false
          },
          "allowed_extensions": {
            "type": "string",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] A comma-separated list of extensions that certificates can have when signed. An empty list means that no extension overrides are allowed by an end-user; explicitly specify '*' to allow any extensions to be set."
          },
          "allowed_user_key_lengths": {
            "type": "object",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, allows the enforcement of key types and minimum key sizes to be signed.",
            "format": "map"
          },
          "allowed_users": {
            "type": "string",
            "description": "[Optional for all types] [Works differently for CA type] If this option is not specified, or is '*', client can request a credential for any valid user at the remote host, including the admin user. If only certain usernames are to be allowed, then this list enforces it. If this field is set, then credentials can only be created for default_user and usernames present in this list. Setting this option will enable all the users with access to this role to fetch credentials for all other usernames in this list. Use with caution. N.B.: with the CA type, an empty list means that no users are allowed; explicitly specify '*' to allow any user."
          },
          "allowed_users_template": {
            "type": "boolean",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, Allowed users can be specified using identity template policies. Non-templated users are also permitted.",
            "default": false
          },
          "cidr_list": {
            "type": "string",
            "description": "[Optional for Dynamic type] [Optional for OTP type] [Not applicable for CA type] Comma separated list of CIDR blocks for which the role is applicable for. CIDR blocks can belong to more than one role.",
            "x-vault-displayAttrs": {
              "name": "CIDR List"
            }
          },
          "default_critical_options": {
            "type": "object",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] Critical options certificates should have if none are provided when signing. This field takes in key value pairs in JSON format. Note that these are not restricted by \"allowed_critical_options\". Defaults to none.",
            "format": "map"
          },
          "default_extensions": {
            "type": "object",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] Extensions certificates should have if none are provided when signing. This field takes in key value pairs in JSON format. Note that these are not restricted by \"allowed_extensions\". Defaults to none.",
            "format": "map"
          },
          "default_extensions_template": {
            "type": "boolean",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, Default extension values can be specified using identity template policies. Non-templated extension values are also permitted.",
            "default": false
          },
          "default_user": {
            "type": "string",
            "description": "[Required for Dynamic type] [Required for OTP type] [Optional for CA type] Default username for which a credential will be generated. When the endpoint 'creds/' is used without a username, this value will be used as default username.",
            "x-vault-displayAttrs": {
              "name": "Default Username"
            }
          },
          "default_user_template": {
            "type": "boolean",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] If set, Default user can be specified using identity template policies. Non-templated users are also permitted.",
            "default": false
          },
          "exclude_cidr_list": {
            "type": "string",
            "description": "[Optional for Dynamic type] [Optional for OTP type] [Not applicable for CA type] Comma separated list of CIDR blocks. IP addresses belonging to these blocks are not accepted by the role. This is particularly useful when big CIDR blocks are being used by the role and certain parts of it needs to be kept out.",
            "x-vault-displayAttrs": {
              "name": "Exclude CIDR List"
            }
          },
          "install_script": {
            "type": "string",
            "description": "[Optional for Dynamic type] [Not-applicable for OTP type] [Not applicable for CA type] Script used to install and uninstall public keys in the target machine. The inbuilt default install script will be for Linux hosts. For sample script, refer the project documentation website."
          },
          "key": {
            "type": "string",
            "description": "[Required for Dynamic type] [Not applicable for OTP type] [Not applicable for CA type] Name of the registered key in Vault. Before creating the role, use the 'keys/' endpoint to create a named key."
          },
          "key_bits": {
            "type": "integer",
            "description": "[Optional for Dynamic type] [Not applicable for OTP type] [Not applicable for CA type] Length of the RSA dynamic key in bits. It is 1024 by default or it can be 2048."
          },
          "key_id_format": {
            "type": "string",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] When supplied, this value specifies a custom format for the key id of a signed certificate. The following variables are available for use: '{{token_display_name}}' - The display name of the token used to make the request. '{{role_name}}' - The name of the role signing the request. '{{public_key_hash}}' - A SHA256 checksum of the public key that is being signed.",
            "x-vault-displayAttrs": {
              "name": "Key ID Format"
            }
          },
          "key_option_specs": {
            "type": "string",
            "description": "[Optional for Dynamic type] [Not applicable for OTP type] [Not applicable for CA type] Comma separated option specifications which will be prefixed to RSA key in authorized_keys file. Options should be valid and comply with authorized_keys file format and should not contain spaces."
          },
          "key_type": {
            "type": "string",
            "description": "[Required for all types] Type of key used to login to hosts. It can be either 'otp', 'dynamic' or 'ca'. 'otp' type requires agent to be installed in remote hosts.",
            "enum": [
              "otp",
              "dynamic",
              "ca"
            ],
            "x-vault-displayAttrs": {
              "value": "ca"
            }
          },
          "max_ttl": {
            "type": "integer",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] The maximum allowed lease duration",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Max TTL"
            }
          },
          "not_before_duration": {
            "type": "integer",
            "description": "The duration that the SSH certificate should be backdated by at issuance.",
            "format": "seconds",
            "default": 30,
            "x-vault-displayAttrs": {
              "name": "Not before duration",
              "value": 30
            }
          },
          "port": {
            "type": "integer",
            "description": "[Optional for Dynamic type] [Optional for OTP type] [Not applicable for CA type] Port number for SSH connection. Default is '22'. Port number does not play any role in creation of OTP. For 'otp' type, this is just a way to inform client about the port number to use. Port number will be returned to client by Vault server along with OTP.",
            "x-vault-displayAttrs": {
              "value": 22
            }
          },
          "ttl": {
            "type": "integer",
            "description": "[Not applicable for Dynamic type] [Not applicable for OTP type] [Optional for CA type] The lease duration if no specific lease duration is requested. The lease duration controls the expiration of certificates issued by this backend. Defaults to the value of max_ttl.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "TTL"
            }
          }
        }
      },
      "SSHWriteZeroAddressConfigRequest": {
        "type": "object",
        "properties": {
          "roles": {
            "type": "array",
            "description": "[Required] Comma separated list of role names which allows credentials to be requested for any IP address. CIDR blocks previously registered under these roles will be ignored.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "SysWritePluginsCatalogNameRequest": {
        "type": "object",
        "properties": {
          "args": {
            "type": "array",
            "description": "The args passed to plugin command.",
            "items": {
              "type": "string"
            }
          },
          "command": {
            "type": "string",
            "description": "The command used to start the plugin. The executable defined in this command must exist in vault's plugin directory."
          },
          "env": {
            "type": "array",
            "description": "The environment variables passed to plugin command. Each entry is of the form \"key=value\".",
            "items": {
              "type": "string"
            }
          },
          "sha256": {
            "type": "string",
            "description": "The SHA256 sum of the executable used in the command field. This should be HEX encoded."
          },
          "type": {
            "type": "string",
            "description": "The type of the plugin, may be auth, secret, or database"
          },
          "version": {
            "type": "string",
            "description": "The semantic version of the plugin to use."
          }
        }
      },
      "SysWriteToolsRandomUrlbytesRequest": {
        "type": "object",
        "properties": {
          "bytes": {
            "type": "integer",
            "description": "The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).",
            "default": 32
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"base64\".",
            "default": "base64"
          },
          "source": {
            "type": "string",
            "description": "Which system to source random data from, ether \"platform\", \"seal\", or \"all\".",
            "default": "platform"
          }
        }
      },
      "TOTPWriteCodeRequest": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": "TOTP code to be validated."
          }
        }
      },
      "TOTPWriteKeyRequest": {
        "type": "object",
        "properties": {
          "account_name": {
            "type": "string",
            "description": "The name of the account associated with the key. Required if generate is true."
          },
          "algorithm": {
            "type": "string",
            "description": "The hashing algorithm used to generate the TOTP token. Options include SHA1, SHA256 and SHA512.",
            "default": "SHA1"
          },
          "digits": {
            "type": "integer",
            "description": "The number of digits in the generated TOTP token. This value can either be 6 or 8.",
            "default": 6
          },
          "exported": {
            "type": "boolean",
            "description": "Determines if a QR code and url are returned upon generating a key. Only used if generate is true.",
            "default": true
          },
          "generate": {
            "type": "boolean",
            "description": "Determines if a key should be generated by Vault or if a key is being passed from another service.",
            "default": false
          },
          "issuer": {
            "type": "string",
            "description": "The name of the key's issuing organization. Required if generate is true."
          },
          "key": {
            "type": "string",
            "description": "The shared master key used to generate a TOTP token. Only used if generate is false."
          },
          "key_size": {
            "type": "integer",
            "description": "Determines the size in bytes of the generated key. Only used if generate is true.",
            "default": 20
          },
          "period": {
            "type": "integer",
            "description": "The length of time used to generate a counter for the TOTP token calculation.",
            "format": "seconds",
            "default": 30
          },
          "qr_size": {
            "type": "integer",
            "description": "The pixel size of the generated square QR code. Only used if generate is true and exported is true. If this value is 0, a QR code will not be returned.",
            "default": 200
          },
          "skew": {
            "type": "integer",
            "description": "The number of delay periods that are allowed when validating a TOTP token. This value can either be 0 or 1. Only used if generate is true.",
            "default": 1
          },
          "url": {
            "type": "string",
            "description": "A TOTP url string containing all of the parameters for key setup. Only used if generate is false."
          }
        }
      },
      "TerraformWriteConfigRequest": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "The address to access Terraform Cloud or Enterprise. Default is \"https://app.terraform.io\".",
            "default": "https://app.terraform.io"
          },
          "base_path": {
            "type": "string",
            "description": "The base path for the Terraform Cloud or Enterprise API. Default is \"/api/v2/\".",
            "default": "/api/v2/"
          },
          "token": {
            "type": "string",
            "description": "The token to access Terraform Cloud",
            "x-vault-displayAttrs": {
              "name": "Token",
              "sensitive": true
            }
          }
        },
        "required": [
          "token"
        ]
      },
      "TerraformWriteRoleRequest": {
        "type": "object",
        "properties": {
          "max_ttl": {
            "type": "integer",
            "description": "Maximum time for role. If not set or set to 0, will use system default.",
            "format": "seconds"
          },
          "organization": {
            "type": "string",
            "description": "Name of the Terraform Cloud or Enterprise organization"
          },
          "team_id": {
            "type": "string",
            "description": "ID of the Terraform Cloud or Enterprise team under organization (e.g., settings/teams/team-xxxxxxxxxxxxx)"
          },
          "ttl": {
            "type": "integer",
            "description": "Default lease for generated credentials. If not set or set to 0, will use system default.",
            "format": "seconds"
          },
          "user_id": {
            "type": "string",
            "description": "ID of the Terraform Cloud or Enterprise user (e.g., user-xxxxxxxxxxxxxxxx)"
          }
        }
      },
      "TokenRenewAccessorRequest": {
        "type": "object",
        "properties": {
          "accessor": {
            "type": "string",
            "description": "Accessor of the token to renew (request body)"
          },
          "increment": {
            "type": "integer",
            "description": "The desired increment in seconds to the token expiration",
            "format": "seconds",
            "default": 0
          }
        }
      },
      "TokenRenewRequest": {
        "type": "object",
        "properties": {
          "increment": {
            "type": "integer",
            "description": "The desired increment in seconds to the token expiration",
            "format": "seconds",
            "default": 0
          },
          "token": {
            "type": "string",
            "description": "Token to renew (request body)"
          }
        }
      },
      "TokenRenewSelfRequest": {
        "type": "object",
        "properties": {
          "increment": {
            "type": "integer",
            "description": "The desired increment in seconds to the token expiration",
            "format": "seconds",
            "default": 0
          },
          "token": {
            "type": "string",
            "description": "Token to renew (unused, does not need to be set)"
          }
        }
      },
      "TokenRevokeAccessorRequest": {
        "type": "object",
        "properties": {
          "accessor": {
            "type": "string",
            "description": "Accessor of the token (request body)"
          }
        }
      },
      "TokenRevokeOrphanRequest": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "description": "Token to revoke (request body)"
          }
        }
      },
      "TokenRevokeRequest": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "description": "Token to revoke (request body)"
          }
        }
      },
      "TokenWriteCreateOrphanRequest": {
        "type": "object",
        "properties": {
          "display_name": {
            "type": "string",
            "description": "Name to associate with this token"
          },
          "entity_alias": {
            "type": "string",
            "description": "Name of the entity alias to associate with this token"
          },
          "explicit_max_ttl": {
            "type": "string",
            "description": "Explicit Max TTL of this token"
          },
          "id": {
            "type": "string",
            "description": "Value for the token"
          },
          "metadata": {
            "type": "object",
            "description": "Arbitrary key=value metadata to associate with the token",
            "format": "map"
          },
          "no_default_policy": {
            "type": "boolean",
            "description": "Do not include default policy for this token"
          },
          "no_parent": {
            "type": "boolean",
            "description": "Create the token with no parent"
          },
          "num_uses": {
            "type": "integer",
            "description": "Max number of uses for this token"
          },
          "period": {
            "type": "string",
            "description": "Renew period"
          },
          "policies": {
            "type": "array",
            "description": "List of policies for the token",
            "items": {
              "type": "string"
            }
          },
          "renewable": {
            "type": "boolean",
            "description": "Allow token to be renewed past its initial TTL up to system/mount maximum TTL"
          },
          "role_name": {
            "type": "string",
            "description": "Name of the role"
          },
          "ttl": {
            "type": "string",
            "description": "Time to live for this token"
          },
          "type": {
            "type": "string",
            "description": "Token type"
          }
        }
      },
      "TokenWriteCreateRequest": {
        "type": "object",
        "properties": {
          "display_name": {
            "type": "string",
            "description": "Name to associate with this token"
          },
          "entity_alias": {
            "type": "string",
            "description": "Name of the entity alias to associate with this token"
          },
          "explicit_max_ttl": {
            "type": "string",
            "description": "Explicit Max TTL of this token"
          },
          "id": {
            "type": "string",
            "description": "Value for the token"
          },
          "metadata": {
            "type": "object",
            "description": "Arbitrary key=value metadata to associate with the token",
            "format": "map"
          },
          "no_default_policy": {
            "type": "boolean",
            "description": "Do not include default policy for this token"
          },
          "no_parent": {
            "type": "boolean",
            "description": "Create the token with no parent"
          },
          "num_uses": {
            "type": "integer",
            "description": "Max number of uses for this token"
          },
          "period": {
            "type": "string",
            "description": "Renew period"
          },
          "policies": {
            "type": "array",
            "description": "List of policies for the token",
            "items": {
              "type": "string"
            }
          },
          "renewable": {
            "type": "boolean",
            "description": "Allow token to be renewed past its initial TTL up to system/mount maximum TTL"
          },
          "ttl": {
            "type": "string",
            "description": "Time to live for this token"
          },
          "type": {
            "type": "string",
            "description": "Token type"
          }
        }
      },
      "TokenWriteCreateWithRoleRequest": {
        "type": "object",
        "properties": {
          "display_name": {
            "type": "string",
            "description": "Name to associate with this token"
          },
          "entity_alias": {
            "type": "string",
            "description": "Name of the entity alias to associate with this token"
          },
          "explicit_max_ttl": {
            "type": "string",
            "description": "Explicit Max TTL of this token"
          },
          "id": {
            "type": "string",
            "description": "Value for the token"
          },
          "metadata": {
            "type": "object",
            "description": "Arbitrary key=value metadata to associate with the token",
            "format": "map"
          },
          "no_default_policy": {
            "type": "boolean",
            "description": "Do not include default policy for this token"
          },
          "no_parent": {
            "type": "boolean",
            "description": "Create the token with no parent"
          },
          "num_uses": {
            "type": "integer",
            "description": "Max number of uses for this token"
          },
          "period": {
            "type": "string",
            "description": "Renew period"
          },
          "policies": {
            "type": "array",
            "description": "List of policies for the token",
            "items": {
              "type": "string"
            }
          },
          "renewable": {
            "type": "boolean",
            "description": "Allow token to be renewed past its initial TTL up to system/mount maximum TTL"
          },
          "ttl": {
            "type": "string",
            "description": "Time to live for this token"
          },
          "type": {
            "type": "string",
            "description": "Token type"
          }
        }
      },
      "TokenWriteLookupAccessorRequest": {
        "type": "object",
        "properties": {
          "accessor": {
            "type": "string",
            "description": "Accessor of the token to look up (request body)"
          }
        }
      },
      "TokenWriteLookupRequest": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "description": "Token to lookup (POST request body)"
          }
        }
      },
      "TokenWriteLookupSelfRequest": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string",
            "description": "Token to look up (unused, does not need to be set)"
          }
        }
      },
      "TokenWriteRoleRequest": {
        "type": "object",
        "properties": {
          "allowed_entity_aliases": {
            "type": "array",
            "description": "String or JSON list of allowed entity aliases. If set, specifies the entity aliases which are allowed to be used during token generation. This field supports globbing.",
            "items": {
              "type": "string"
            }
          },
          "allowed_policies": {
            "type": "array",
            "description": "If set, tokens can be created with any subset of the policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy names.",
            "items": {
              "type": "string"
            }
          },
          "allowed_policies_glob": {
            "type": "array",
            "description": "If set, tokens can be created with any subset of glob matched policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy name globs.",
            "items": {
              "type": "string"
            }
          },
          "bound_cidrs": {
            "type": "array",
            "description": "Use 'token_bound_cidrs' instead.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "disallowed_policies": {
            "type": "array",
            "description": "If set, successful token creation via this role will require that no policies in the given list are requested. The parameter is a comma-delimited string of policy names.",
            "items": {
              "type": "string"
            }
          },
          "disallowed_policies_glob": {
            "type": "array",
            "description": "If set, successful token creation via this role will require that no requested policies glob match any of policies in this list. The parameter is a comma-delimited string of policy name globs.",
            "items": {
              "type": "string"
            }
          },
          "explicit_max_ttl": {
            "type": "integer",
            "description": "Use 'token_explicit_max_ttl' instead.",
            "format": "seconds",
            "deprecated": true
          },
          "orphan": {
            "type": "boolean",
            "description": "If true, tokens created via this role will be orphan tokens (have no parent)"
          },
          "path_suffix": {
            "type": "string",
            "description": "If set, tokens created via this role will contain the given suffix as a part of their path. This can be used to assist use of the 'revoke-prefix' endpoint later on. The given suffix must match the regular expression.\\w[\\w-.]+\\w"
          },
          "period": {
            "type": "integer",
            "description": "Use 'token_period' instead.",
            "format": "seconds",
            "deprecated": true
          },
          "renewable": {
            "type": "boolean",
            "description": "Tokens created via this role will be renewable or not according to this value. Defaults to \"true\".",
            "default": true
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          }
        }
      },
      "ToolsGenerateRandomRequest": {
        "type": "object",
        "properties": {
          "bytes": {
            "type": "integer",
            "description": "The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).",
            "default": 32
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"base64\".",
            "default": "base64"
          },
          "source": {
            "type": "string",
            "description": "Which system to source random data from, ether \"platform\", \"seal\", or \"all\".",
            "default": "platform"
          },
          "urlbytes": {
            "type": "string",
            "description": "The number of bytes to generate (POST URL parameter)"
          }
        }
      },
      "ToolsGenerateRandomSourceBytesRequest": {
        "type": "object",
        "properties": {
          "bytes": {
            "type": "integer",
            "description": "The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).",
            "default": 32
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"base64\".",
            "default": "base64"
          }
        }
      },
      "ToolsGenerateRandomSourceRequest": {
        "type": "object",
        "properties": {
          "bytes": {
            "type": "integer",
            "description": "The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).",
            "default": 32
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"base64\".",
            "default": "base64"
          },
          "urlbytes": {
            "type": "string",
            "description": "The number of bytes to generate (POST URL parameter)"
          }
        }
      },
      "ToolsHashRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 Defaults to \"sha2-256\".",
            "default": "sha2-256"
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"hex\".",
            "default": "hex"
          },
          "input": {
            "type": "string",
            "description": "The base64-encoded input data"
          },
          "urlalgorithm": {
            "type": "string",
            "description": "Algorithm to use (POST URL parameter)"
          }
        }
      },
      "ToolsHashWithRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 Defaults to \"sha2-256\".",
            "default": "sha2-256"
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"hex\".",
            "default": "hex"
          },
          "input": {
            "type": "string",
            "description": "The base64-encoded input data"
          }
        }
      },
      "TransitDecryptRequest": {
        "type": "object",
        "properties": {
          "associated_data": {
            "type": "string",
            "description": "When using an AEAD cipher mode, such as AES-GCM, this parameter allows passing associated data (AD/AAD) into the encryption function; this data must be passed on subsequent decryption requests but can be transited in plaintext. On successful decryption, both the ciphertext and the associated data are attested not to have been tampered with."
          },
          "ciphertext": {
            "type": "string",
            "description": "The ciphertext to decrypt, provided as returned by encrypt."
          },
          "context": {
            "type": "string",
            "description": "Base64 encoded context for key derivation. Required if key derivation is enabled."
          },
          "nonce": {
            "type": "string",
            "description": "Base64 encoded nonce value used during encryption. Must be provided if convergent encryption is enabled for this key and the key was generated with Vault 0.6.1. Not required for keys created in 0.6.2+."
          },
          "partial_failure_response_code": {
            "type": "integer",
            "description": "Ordinarily, if a batch item fails to decrypt due to a bad input, but other batch items succeed, the HTTP response code is 400 (Bad Request). Some applications may want to treat partial failures differently. Providing the parameter returns the given response code integer instead of a 400 in this case. If all values fail HTTP 400 is still returned."
          }
        }
      },
      "TransitEncryptRequest": {
        "type": "object",
        "properties": {
          "associated_data": {
            "type": "string",
            "description": "When using an AEAD cipher mode, such as AES-GCM, this parameter allows passing associated data (AD/AAD) into the encryption function; this data must be passed on subsequent decryption requests but can be transited in plaintext. On successful decryption, both the ciphertext and the associated data are attested not to have been tampered with."
          },
          "context": {
            "type": "string",
            "description": "Base64 encoded context for key derivation. Required if key derivation is enabled"
          },
          "convergent_encryption": {
            "type": "boolean",
            "description": "This parameter will only be used when a key is expected to be created. Whether to support convergent encryption. This is only supported when using a key with key derivation enabled and will require all requests to carry both a context and 96-bit (12-byte) nonce. The given nonce will be used in place of a randomly generated nonce. As a result, when the same context and nonce are supplied, the same ciphertext is generated. It is *very important* when using this mode that you ensure that all nonces are unique for a given context. Failing to do so will severely impact the ciphertext's security."
          },
          "key_version": {
            "type": "integer",
            "description": "The version of the key to use for encryption. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key."
          },
          "nonce": {
            "type": "string",
            "description": "Base64 encoded nonce value. Must be provided if convergent encryption is enabled for this key and the key was generated with Vault 0.6.1. Not required for keys created in 0.6.2+. The value must be exactly 96 bits (12 bytes) long and the user must ensure that for any given context (and thus, any given encryption key) this nonce value is **never reused**."
          },
          "partial_failure_response_code": {
            "type": "integer",
            "description": "Ordinarily, if a batch item fails to encrypt due to a bad input, but other batch items succeed, the HTTP response code is 400 (Bad Request). Some applications may want to treat partial failures differently. Providing the parameter returns the given response code integer instead of a 400 in this case. If all values fail HTTP 400 is still returned."
          },
          "plaintext": {
            "type": "string",
            "description": "Base64 encoded plaintext value to be encrypted"
          },
          "type": {
            "type": "string",
            "description": "This parameter is required when encryption key is expected to be created. When performing an upsert operation, the type of key to create. Currently, \"aes128-gcm96\" (symmetric) and \"aes256-gcm96\" (symmetric) are the only types supported. Defaults to \"aes256-gcm96\".",
            "default": "aes256-gcm96"
          }
        }
      },
      "TransitGenerateDataKeyRequest": {
        "type": "object",
        "properties": {
          "bits": {
            "type": "integer",
            "description": "Number of bits for the key; currently 128, 256, and 512 bits are supported. Defaults to 256.",
            "default": 256
          },
          "context": {
            "type": "string",
            "description": "Context for key derivation. Required for derived keys."
          },
          "key_version": {
            "type": "integer",
            "description": "The version of the Vault key to use for encryption of the data key. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key."
          },
          "nonce": {
            "type": "string",
            "description": "Nonce for when convergent encryption v1 is used (only in Vault 0.6.1)"
          }
        }
      },
      "TransitGenerateHMACRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 Defaults to \"sha2-256\".",
            "default": "sha2-256"
          },
          "input": {
            "type": "string",
            "description": "The base64-encoded input data"
          },
          "key_version": {
            "type": "integer",
            "description": "The version of the key to use for generating the HMAC. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key."
          },
          "urlalgorithm": {
            "type": "string",
            "description": "Algorithm to use (POST URL parameter)"
          }
        }
      },
      "TransitGenerateHMACWithAlgorithmRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 Defaults to \"sha2-256\".",
            "default": "sha2-256"
          },
          "input": {
            "type": "string",
            "description": "The base64-encoded input data"
          },
          "key_version": {
            "type": "integer",
            "description": "The version of the key to use for generating the HMAC. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key."
          }
        }
      },
      "TransitGenerateRandomRequest": {
        "type": "object",
        "properties": {
          "bytes": {
            "type": "integer",
            "description": "The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).",
            "default": 32
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"base64\".",
            "default": "base64"
          },
          "source": {
            "type": "string",
            "description": "Which system to source random data from, ether \"platform\", \"seal\", or \"all\".",
            "default": "platform"
          },
          "urlbytes": {
            "type": "string",
            "description": "The number of bytes to generate (POST URL parameter)"
          }
        }
      },
      "TransitGenerateRandomSourceBytesRequest": {
        "type": "object",
        "properties": {
          "bytes": {
            "type": "integer",
            "description": "The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).",
            "default": 32
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"base64\".",
            "default": "base64"
          }
        }
      },
      "TransitGenerateRandomSourceRequest": {
        "type": "object",
        "properties": {
          "bytes": {
            "type": "integer",
            "description": "The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).",
            "default": 32
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"base64\".",
            "default": "base64"
          },
          "urlbytes": {
            "type": "string",
            "description": "The number of bytes to generate (POST URL parameter)"
          }
        }
      },
      "TransitHashRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 Defaults to \"sha2-256\".",
            "default": "sha2-256"
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"hex\".",
            "default": "hex"
          },
          "input": {
            "type": "string",
            "description": "The base64-encoded input data"
          },
          "urlalgorithm": {
            "type": "string",
            "description": "Algorithm to use (POST URL parameter)"
          }
        }
      },
      "TransitHashWithAlgorithmRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 Defaults to \"sha2-256\".",
            "default": "sha2-256"
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"hex\".",
            "default": "hex"
          },
          "input": {
            "type": "string",
            "description": "The base64-encoded input data"
          }
        }
      },
      "TransitImportKeyRequest": {
        "type": "object",
        "properties": {
          "allow_plaintext_backup": {
            "type": "boolean",
            "description": "Enables taking a backup of the named key in plaintext format. Once set, this cannot be disabled."
          },
          "allow_rotation": {
            "type": "boolean",
            "description": "True if the imported key may be rotated within Vault; false otherwise."
          },
          "auto_rotate_period": {
            "type": "integer",
            "description": "Amount of time the key should live before being automatically rotated. A value of 0 (default) disables automatic rotation for the key.",
            "format": "seconds",
            "default": 0
          },
          "ciphertext": {
            "type": "string",
            "description": "The base64-encoded ciphertext of the keys. The AES key should be encrypted using OAEP with the wrapping key and then concatenated with the import key, wrapped by the AES key."
          },
          "context": {
            "type": "string",
            "description": "Base64 encoded context for key derivation. When reading a key with key derivation enabled, if the key type supports public keys, this will return the public key for the given context."
          },
          "derived": {
            "type": "boolean",
            "description": "Enables key derivation mode. This allows for per-transaction unique keys for encryption operations."
          },
          "exportable": {
            "type": "boolean",
            "description": "Enables keys to be exportable. This allows for all the valid keys in the key ring to be exported."
          },
          "hash_function": {
            "type": "string",
            "description": "The hash function used as a random oracle in the OAEP wrapping of the user-generated, ephemeral AES key. Can be one of \"SHA1\", \"SHA224\", \"SHA256\" (default), \"SHA384\", or \"SHA512\"",
            "default": "SHA256"
          },
          "type": {
            "type": "string",
            "description": "The type of key being imported. Currently, \"aes128-gcm96\" (symmetric), \"aes256-gcm96\" (symmetric), \"ecdsa-p256\" (asymmetric), \"ecdsa-p384\" (asymmetric), \"ecdsa-p521\" (asymmetric), \"ed25519\" (asymmetric), \"rsa-2048\" (asymmetric), \"rsa-3072\" (asymmetric), \"rsa-4096\" (asymmetric) are supported. Defaults to \"aes256-gcm96\".",
            "default": "aes256-gcm96"
          }
        }
      },
      "TransitImportKeyVersionRequest": {
        "type": "object",
        "properties": {
          "ciphertext": {
            "type": "string",
            "description": "The base64-encoded ciphertext of the keys. The AES key should be encrypted using OAEP with the wrapping key and then concatenated with the import key, wrapped by the AES key."
          },
          "hash_function": {
            "type": "string",
            "description": "The hash function used as a random oracle in the OAEP wrapping of the user-generated, ephemeral AES key. Can be one of \"SHA1\", \"SHA224\", \"SHA256\" (default), \"SHA384\", or \"SHA512\"",
            "default": "SHA256"
          }
        }
      },
      "TransitRestoreKeyRequest": {
        "type": "object",
        "properties": {
          "backup": {
            "type": "string",
            "description": "Backed up key data to be restored. This should be the output from the 'backup/' endpoint."
          },
          "force": {
            "type": "boolean",
            "description": "If set and a key by the given name exists, force the restore operation and override the key.",
            "default": false
          }
        }
      },
      "TransitRestoreRequest": {
        "type": "object",
        "properties": {
          "backup": {
            "type": "string",
            "description": "Backed up key data to be restored. This should be the output from the 'backup/' endpoint."
          },
          "force": {
            "type": "boolean",
            "description": "If set and a key by the given name exists, force the restore operation and override the key.",
            "default": false
          },
          "name": {
            "type": "string",
            "description": "If set, this will be the name of the restored key."
          }
        }
      },
      "TransitRewrapRequest": {
        "type": "object",
        "properties": {
          "ciphertext": {
            "type": "string",
            "description": "Ciphertext value to rewrap"
          },
          "context": {
            "type": "string",
            "description": "Base64 encoded context for key derivation. Required for derived keys."
          },
          "key_version": {
            "type": "integer",
            "description": "The version of the key to use for encryption. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key."
          },
          "nonce": {
            "type": "string",
            "description": "Nonce for when convergent encryption is used"
          }
        }
      },
      "TransitSignRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "Deprecated: use \"hash_algorithm\" instead.",
            "default": "sha2-256"
          },
          "context": {
            "type": "string",
            "description": "Base64 encoded context for key derivation. Required if key derivation is enabled; currently only available with ed25519 keys."
          },
          "hash_algorithm": {
            "type": "string",
            "description": "Hash algorithm to use (POST body parameter). Valid values are: * sha1 * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 * none Defaults to \"sha2-256\". Not valid for all key types, including ed25519. Using none requires setting prehashed=true and signature_algorithm=pkcs1v15, yielding a PKCSv1_5_NoOID instead of the usual PKCSv1_5_DERnull signature.",
            "default": "sha2-256"
          },
          "input": {
            "type": "string",
            "description": "The base64-encoded input data"
          },
          "key_version": {
            "type": "integer",
            "description": "The version of the key to use for signing. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key."
          },
          "marshaling_algorithm": {
            "type": "string",
            "description": "The method by which to marshal the signature. The default is 'asn1' which is used by openssl and X.509. It can also be set to 'jws' which is used for JWT signatures; setting it to this will also cause the encoding of the signature to be url-safe base64 instead of using standard base64 encoding. Currently only valid for ECDSA P-256 key types\".",
            "default": "asn1"
          },
          "prehashed": {
            "type": "boolean",
            "description": "Set to 'true' when the input is already hashed. If the key type is 'rsa-2048', 'rsa-3072' or 'rsa-4096', then the algorithm used to hash the input should be indicated by the 'algorithm' parameter."
          },
          "salt_length": {
            "type": "string",
            "description": "The salt length used to sign. Currently only applies to the RSA PSS signature scheme. Options are 'auto' (the default used by Golang, causing the salt to be as large as possible when signing), 'hash' (causes the salt length to equal the length of the hash used in the signature), or an integer between the minimum and the maximum permissible salt lengths for the given RSA key size. Defaults to 'auto'.",
            "default": "auto"
          },
          "signature_algorithm": {
            "type": "string",
            "description": "The signature algorithm to use for signing. Currently only applies to RSA key types. Options are 'pss' or 'pkcs1v15'. Defaults to 'pss'"
          },
          "urlalgorithm": {
            "type": "string",
            "description": "Hash algorithm to use (POST URL parameter)"
          }
        }
      },
      "TransitSignWithAlgorithmRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "Deprecated: use \"hash_algorithm\" instead.",
            "default": "sha2-256"
          },
          "context": {
            "type": "string",
            "description": "Base64 encoded context for key derivation. Required if key derivation is enabled; currently only available with ed25519 keys."
          },
          "hash_algorithm": {
            "type": "string",
            "description": "Hash algorithm to use (POST body parameter). Valid values are: * sha1 * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 * none Defaults to \"sha2-256\". Not valid for all key types, including ed25519. Using none requires setting prehashed=true and signature_algorithm=pkcs1v15, yielding a PKCSv1_5_NoOID instead of the usual PKCSv1_5_DERnull signature.",
            "default": "sha2-256"
          },
          "input": {
            "type": "string",
            "description": "The base64-encoded input data"
          },
          "key_version": {
            "type": "integer",
            "description": "The version of the key to use for signing. Must be 0 (for latest) or a value greater than or equal to the min_encryption_version configured on the key."
          },
          "marshaling_algorithm": {
            "type": "string",
            "description": "The method by which to marshal the signature. The default is 'asn1' which is used by openssl and X.509. It can also be set to 'jws' which is used for JWT signatures; setting it to this will also cause the encoding of the signature to be url-safe base64 instead of using standard base64 encoding. Currently only valid for ECDSA P-256 key types\".",
            "default": "asn1"
          },
          "prehashed": {
            "type": "boolean",
            "description": "Set to 'true' when the input is already hashed. If the key type is 'rsa-2048', 'rsa-3072' or 'rsa-4096', then the algorithm used to hash the input should be indicated by the 'algorithm' parameter."
          },
          "salt_length": {
            "type": "string",
            "description": "The salt length used to sign. Currently only applies to the RSA PSS signature scheme. Options are 'auto' (the default used by Golang, causing the salt to be as large as possible when signing), 'hash' (causes the salt length to equal the length of the hash used in the signature), or an integer between the minimum and the maximum permissible salt lengths for the given RSA key size. Defaults to 'auto'.",
            "default": "auto"
          },
          "signature_algorithm": {
            "type": "string",
            "description": "The signature algorithm to use for signing. Currently only applies to RSA key types. Options are 'pss' or 'pkcs1v15'. Defaults to 'pss'"
          }
        }
      },
      "TransitTrimKeyRequest": {
        "type": "object",
        "properties": {
          "min_available_version": {
            "type": "integer",
            "description": "The minimum available version for the key ring. All versions before this version will be permanently deleted. This value can at most be equal to the lesser of 'min_decryption_version' and 'min_encryption_version'. This is not allowed to be set when either 'min_encryption_version' or 'min_decryption_version' is set to zero."
          }
        }
      },
      "TransitVerifyRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "Deprecated: use \"hash_algorithm\" instead.",
            "default": "sha2-256"
          },
          "context": {
            "type": "string",
            "description": "Base64 encoded context for key derivation. Required if key derivation is enabled; currently only available with ed25519 keys."
          },
          "hash_algorithm": {
            "type": "string",
            "description": "Hash algorithm to use (POST body parameter). Valid values are: * sha1 * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 * none Defaults to \"sha2-256\". Not valid for all key types. See note about none on signing path.",
            "default": "sha2-256"
          },
          "hmac": {
            "type": "string",
            "description": "The HMAC, including vault header/key version"
          },
          "input": {
            "type": "string",
            "description": "The base64-encoded input data to verify"
          },
          "marshaling_algorithm": {
            "type": "string",
            "description": "The method by which to unmarshal the signature when verifying. The default is 'asn1' which is used by openssl and X.509; can also be set to 'jws' which is used for JWT signatures in which case the signature is also expected to be url-safe base64 encoding instead of standard base64 encoding. Currently only valid for ECDSA P-256 key types\".",
            "default": "asn1"
          },
          "prehashed": {
            "type": "boolean",
            "description": "Set to 'true' when the input is already hashed. If the key type is 'rsa-2048', 'rsa-3072' or 'rsa-4096', then the algorithm used to hash the input should be indicated by the 'algorithm' parameter."
          },
          "salt_length": {
            "type": "string",
            "description": "The salt length used to sign. Currently only applies to the RSA PSS signature scheme. Options are 'auto' (the default used by Golang, causing the salt to be as large as possible when signing), 'hash' (causes the salt length to equal the length of the hash used in the signature), or an integer between the minimum and the maximum permissible salt lengths for the given RSA key size. Defaults to 'auto'.",
            "default": "auto"
          },
          "signature": {
            "type": "string",
            "description": "The signature, including vault header/key version"
          },
          "signature_algorithm": {
            "type": "string",
            "description": "The signature algorithm to use for signature verification. Currently only applies to RSA key types. Options are 'pss' or 'pkcs1v15'. Defaults to 'pss'"
          },
          "urlalgorithm": {
            "type": "string",
            "description": "Hash algorithm to use (POST URL parameter)"
          }
        }
      },
      "TransitVerifyWithAlgorithmRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "Deprecated: use \"hash_algorithm\" instead.",
            "default": "sha2-256"
          },
          "context": {
            "type": "string",
            "description": "Base64 encoded context for key derivation. Required if key derivation is enabled; currently only available with ed25519 keys."
          },
          "hash_algorithm": {
            "type": "string",
            "description": "Hash algorithm to use (POST body parameter). Valid values are: * sha1 * sha2-224 * sha2-256 * sha2-384 * sha2-512 * sha3-224 * sha3-256 * sha3-384 * sha3-512 * none Defaults to \"sha2-256\". Not valid for all key types. See note about none on signing path.",
            "default": "sha2-256"
          },
          "hmac": {
            "type": "string",
            "description": "The HMAC, including vault header/key version"
          },
          "input": {
            "type": "string",
            "description": "The base64-encoded input data to verify"
          },
          "marshaling_algorithm": {
            "type": "string",
            "description": "The method by which to unmarshal the signature when verifying. The default is 'asn1' which is used by openssl and X.509; can also be set to 'jws' which is used for JWT signatures in which case the signature is also expected to be url-safe base64 encoding instead of standard base64 encoding. Currently only valid for ECDSA P-256 key types\".",
            "default": "asn1"
          },
          "prehashed": {
            "type": "boolean",
            "description": "Set to 'true' when the input is already hashed. If the key type is 'rsa-2048', 'rsa-3072' or 'rsa-4096', then the algorithm used to hash the input should be indicated by the 'algorithm' parameter."
          },
          "salt_length": {
            "type": "string",
            "description": "The salt length used to sign. Currently only applies to the RSA PSS signature scheme. Options are 'auto' (the default used by Golang, causing the salt to be as large as possible when signing), 'hash' (causes the salt length to equal the length of the hash used in the signature), or an integer between the minimum and the maximum permissible salt lengths for the given RSA key size. Defaults to 'auto'.",
            "default": "auto"
          },
          "signature": {
            "type": "string",
            "description": "The signature, including vault header/key version"
          },
          "signature_algorithm": {
            "type": "string",
            "description": "The signature algorithm to use for signature verification. Currently only applies to RSA key types. Options are 'pss' or 'pkcs1v15'. Defaults to 'pss'"
          }
        }
      },
      "TransitWriteCacheConfigRequest": {
        "type": "object",
        "properties": {
          "size": {
            "type": "integer",
            "description": "Size of cache, use 0 for an unlimited cache size, defaults to 0",
            "default": 0
          }
        }
      },
      "TransitWriteConfigKeysRequest": {
        "type": "object",
        "properties": {
          "disable_upsert": {
            "type": "boolean",
            "description": "Whether to allow automatic upserting (creation) of keys on the encrypt endpoint."
          }
        }
      },
      "TransitWriteKeyConfigRequest": {
        "type": "object",
        "properties": {
          "allow_plaintext_backup": {
            "type": "boolean",
            "description": "Enables taking a backup of the named key in plaintext format. Once set, this cannot be disabled."
          },
          "auto_rotate_period": {
            "type": "integer",
            "description": "Amount of time the key should live before being automatically rotated. A value of 0 disables automatic rotation for the key.",
            "format": "seconds"
          },
          "deletion_allowed": {
            "type": "boolean",
            "description": "Whether to allow deletion of the key"
          },
          "exportable": {
            "type": "boolean",
            "description": "Enables export of the key. Once set, this cannot be disabled."
          },
          "min_decryption_version": {
            "type": "integer",
            "description": "If set, the minimum version of the key allowed to be decrypted. For signing keys, the minimum version allowed to be used for verification."
          },
          "min_encryption_version": {
            "type": "integer",
            "description": "If set, the minimum version of the key allowed to be used for encryption; or for signing keys, to be used for signing. If set to zero, only the latest version of the key is allowed."
          }
        }
      },
      "TransitWriteKeyRequest": {
        "type": "object",
        "properties": {
          "allow_plaintext_backup": {
            "type": "boolean",
            "description": "Enables taking a backup of the named key in plaintext format. Once set, this cannot be disabled."
          },
          "auto_rotate_period": {
            "type": "integer",
            "description": "Amount of time the key should live before being automatically rotated. A value of 0 (default) disables automatic rotation for the key.",
            "format": "seconds",
            "default": 0
          },
          "context": {
            "type": "string",
            "description": "Base64 encoded context for key derivation. When reading a key with key derivation enabled, if the key type supports public keys, this will return the public key for the given context."
          },
          "convergent_encryption": {
            "type": "boolean",
            "description": "Whether to support convergent encryption. This is only supported when using a key with key derivation enabled and will require all requests to carry both a context and 96-bit (12-byte) nonce. The given nonce will be used in place of a randomly generated nonce. As a result, when the same context and nonce are supplied, the same ciphertext is generated. It is *very important* when using this mode that you ensure that all nonces are unique for a given context. Failing to do so will severely impact the ciphertext's security."
          },
          "derived": {
            "type": "boolean",
            "description": "Enables key derivation mode. This allows for per-transaction unique keys for encryption operations."
          },
          "exportable": {
            "type": "boolean",
            "description": "Enables keys to be exportable. This allows for all the valid keys in the key ring to be exported."
          },
          "key_size": {
            "type": "integer",
            "description": "The key size in bytes for the algorithm. Only applies to HMAC and must be no fewer than 32 bytes and no more than 512",
            "default": 0
          },
          "type": {
            "type": "string",
            "description": "The type of key to create. Currently, \"aes128-gcm96\" (symmetric), \"aes256-gcm96\" (symmetric), \"ecdsa-p256\" (asymmetric), \"ecdsa-p384\" (asymmetric), \"ecdsa-p521\" (asymmetric), \"ed25519\" (asymmetric), \"rsa-2048\" (asymmetric), \"rsa-3072\" (asymmetric), \"rsa-4096\" (asymmetric) are supported. Defaults to \"aes256-gcm96\".",
            "default": "aes256-gcm96"
          }
        }
      },
      "TransitWriteRandomUrlbytesRequest": {
        "type": "object",
        "properties": {
          "bytes": {
            "type": "integer",
            "description": "The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).",
            "default": 32
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"base64\".",
            "default": "base64"
          },
          "source": {
            "type": "string",
            "description": "Which system to source random data from, ether \"platform\", \"seal\", or \"all\".",
            "default": "platform"
          }
        }
      },
      "UnsealRequest": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "Specifies a single unseal key share. This is required unless reset is true."
          },
          "reset": {
            "type": "boolean",
            "description": "Specifies if previously-provided unseal keys are discarded and the unseal process is reset."
          }
        }
      },
      "UserpassLoginRequest": {
        "type": "object",
        "properties": {
          "password": {
            "type": "string",
            "description": "Password for this user."
          }
        }
      },
      "UserpassWriteUserPasswordRequest": {
        "type": "object",
        "properties": {
          "password": {
            "type": "string",
            "description": "Password for this user."
          }
        }
      },
      "UserpassWriteUserPoliciesRequest": {
        "type": "object",
        "properties": {
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "UserpassWriteUserRequest": {
        "type": "object",
        "properties": {
          "bound_cidrs": {
            "type": "array",
            "description": "Use \"token_bound_cidrs\" instead. If this and \"token_bound_cidrs\" are both specified, only \"token_bound_cidrs\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "max_ttl": {
            "type": "integer",
            "description": "Use \"token_max_ttl\" instead. If this and \"token_max_ttl\" are both specified, only \"token_max_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          },
          "password": {
            "type": "string",
            "description": "Password for this user.",
            "x-vault-displayAttrs": {
              "sensitive": true
            }
          },
          "policies": {
            "type": "array",
            "description": "Use \"token_policies\" instead. If this and \"token_policies\" are both specified, only \"token_policies\" will be used.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "token_bound_cidrs": {
            "type": "array",
            "description": "Comma separated string or JSON list of CIDR blocks. If set, specifies the blocks of IP addresses which are allowed to use the generated token.",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Bound CIDRs",
              "group": "Tokens"
            }
          },
          "token_explicit_max_ttl": {
            "type": "integer",
            "description": "If set, tokens created via this role carry an explicit maximum TTL. During renewal, the current maximum TTL values of the role and the mount are not checked for changes, and any updates to these values will have no effect on the token being renewed.",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Explicit Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_max_ttl": {
            "type": "integer",
            "description": "The maximum lifetime of the generated token",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Maximum TTL",
              "group": "Tokens"
            }
          },
          "token_no_default_policy": {
            "type": "boolean",
            "description": "If true, the 'default' policy will not automatically be added to generated tokens",
            "x-vault-displayAttrs": {
              "name": "Do Not Attach 'default' Policy To Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_num_uses": {
            "type": "integer",
            "description": "The maximum number of times a token may be used, a value of zero means unlimited",
            "x-vault-displayAttrs": {
              "name": "Maximum Uses of Generated Tokens",
              "group": "Tokens"
            }
          },
          "token_period": {
            "type": "integer",
            "description": "If set, tokens created via this role will have no max lifetime; instead, their renewal period will be fixed to this value. This takes an integer number of seconds, or a string duration (e.g. \"24h\").",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Period",
              "group": "Tokens"
            }
          },
          "token_policies": {
            "type": "array",
            "description": "Comma-separated list of policies",
            "items": {
              "type": "string"
            },
            "x-vault-displayAttrs": {
              "name": "Generated Token's Policies",
              "group": "Tokens"
            }
          },
          "token_ttl": {
            "type": "integer",
            "description": "The initial ttl of the token to generate",
            "format": "seconds",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Initial TTL",
              "group": "Tokens"
            }
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to generate, service or batch",
            "default": "default-service",
            "x-vault-displayAttrs": {
              "name": "Generated Token's Type",
              "group": "Tokens"
            }
          },
          "ttl": {
            "type": "integer",
            "description": "Use \"token_ttl\" instead. If this and \"token_ttl\" are both specified, only \"token_ttl\" will be used.",
            "format": "seconds",
            "deprecated": true
          }
        }
      },
      "WrappingRewrapRequest": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string"
          }
        }
      },
      "WrappingUnwrapRequest": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string"
          }
        }
      },
      "WrappingWriteLookupRequest": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string"
          }
        }
      },
      "WriteAuditDeviceRequest": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "description": "User-friendly description for this audit backend."
          },
          "local": {
            "type": "boolean",
            "description": "Mark the mount as a local mount, which is not replicated and is unaffected by replication.",
            "default": false
          },
          "options": {
            "type": "object",
            "description": "Configuration options for the audit backend.",
            "format": "kvpairs"
          },
          "type": {
            "type": "string",
            "description": "The type of the backend. Example: \"mysql\""
          }
        }
      },
      "WriteAuthMethodRequest": {
        "type": "object",
        "properties": {
          "config": {
            "type": "object",
            "description": "Configuration for this mount, such as plugin_name.",
            "format": "map"
          },
          "description": {
            "type": "string",
            "description": "User-friendly description for this credential backend."
          },
          "external_entropy_access": {
            "type": "boolean",
            "description": "Whether to give the mount access to Vault's external entropy.",
            "default": false
          },
          "local": {
            "type": "boolean",
            "description": "Mark the mount as a local mount, which is not replicated and is unaffected by replication.",
            "default": false
          },
          "options": {
            "type": "object",
            "description": "The options to pass into the backend. Should be a json object with string keys and values.",
            "format": "kvpairs"
          },
          "plugin_name": {
            "type": "string",
            "description": "Name of the auth plugin to use based from the name in the plugin catalog."
          },
          "plugin_version": {
            "type": "string",
            "description": "The semantic version of the plugin to use."
          },
          "seal_wrap": {
            "type": "boolean",
            "description": "Whether to turn on seal wrapping for the mount.",
            "default": false
          },
          "type": {
            "type": "string",
            "description": "The type of the backend. Example: \"userpass\""
          }
        }
      },
      "WriteAuthMethodTuneRequest": {
        "type": "object",
        "properties": {
          "allowed_response_headers": {
            "type": "array",
            "description": "A list of headers to whitelist and allow a plugin to set on responses.",
            "items": {
              "type": "string"
            }
          },
          "audit_non_hmac_request_keys": {
            "type": "array",
            "description": "The list of keys in the request data object that will not be HMAC'ed by audit devices.",
            "items": {
              "type": "string"
            }
          },
          "audit_non_hmac_response_keys": {
            "type": "array",
            "description": "The list of keys in the response data object that will not be HMAC'ed by audit devices.",
            "items": {
              "type": "string"
            }
          },
          "default_lease_ttl": {
            "type": "string",
            "description": "The default lease TTL for this mount."
          },
          "description": {
            "type": "string",
            "description": "User-friendly description for this credential backend."
          },
          "listing_visibility": {
            "type": "string",
            "description": "Determines the visibility of the mount in the UI-specific listing endpoint. Accepted value are 'unauth' and 'hidden', with the empty default ('') behaving like 'hidden'."
          },
          "max_lease_ttl": {
            "type": "string",
            "description": "The max lease TTL for this mount."
          },
          "options": {
            "type": "object",
            "description": "The options to pass into the backend. Should be a json object with string keys and values.",
            "format": "kvpairs"
          },
          "passthrough_request_headers": {
            "type": "array",
            "description": "A list of headers to whitelist and pass from the request to the plugin.",
            "items": {
              "type": "string"
            }
          },
          "plugin_version": {
            "type": "string",
            "description": "The semantic version of the plugin to use."
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to issue (service or batch)."
          },
          "user_lockout_config": {
            "type": "object",
            "description": "The user lockout configuration to pass into the backend. Should be a json object with string keys and values.",
            "format": "map"
          }
        }
      },
      "WriteCapabilitiesAccessorRequest": {
        "type": "object",
        "properties": {
          "accessor": {
            "type": "string",
            "description": "Accessor of the token for which capabilities are being queried."
          },
          "path": {
            "type": "array",
            "description": "Use 'paths' instead.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "paths": {
            "type": "array",
            "description": "Paths on which capabilities are being queried.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "WriteCapabilitiesRequest": {
        "type": "object",
        "properties": {
          "path": {
            "type": "array",
            "description": "Use 'paths' instead.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "paths": {
            "type": "array",
            "description": "Paths on which capabilities are being queried.",
            "items": {
              "type": "string"
            }
          },
          "token": {
            "type": "string",
            "description": "Token for which capabilities are being queried."
          }
        }
      },
      "WriteCapabilitiesSelfRequest": {
        "type": "object",
        "properties": {
          "path": {
            "type": "array",
            "description": "Use 'paths' instead.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "paths": {
            "type": "array",
            "description": "Paths on which capabilities are being queried.",
            "items": {
              "type": "string"
            }
          },
          "token": {
            "type": "string",
            "description": "Token for which capabilities are being queried."
          }
        }
      },
      "WriteConfigAuditingRequestHeaderRequest": {
        "type": "object",
        "properties": {
          "hmac": {
            "type": "boolean"
          }
        }
      },
      "WriteConfigCORSRequest": {
        "type": "object",
        "properties": {
          "allowed_headers": {
            "type": "array",
            "description": "A comma-separated string or array of strings indicating headers that are allowed on cross-origin requests.",
            "items": {
              "type": "string"
            }
          },
          "allowed_origins": {
            "type": "array",
            "description": "A comma-separated string or array of strings indicating origins that may make cross-origin requests.",
            "items": {
              "type": "string"
            }
          },
          "enable": {
            "type": "boolean",
            "description": "Enables or disables CORS headers on requests."
          }
        }
      },
      "WriteConfigUIHeaderRequest": {
        "type": "object",
        "properties": {
          "multivalue": {
            "type": "boolean",
            "description": "Returns multiple values if true"
          },
          "values": {
            "type": "array",
            "description": "The values to set the header.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "WriteGenerateRootAttemptRequest": {
        "type": "object",
        "properties": {
          "pgp_key": {
            "type": "string",
            "description": "Specifies a base64-encoded PGP public key."
          }
        }
      },
      "WriteGenerateRootRequest": {
        "type": "object",
        "properties": {
          "pgp_key": {
            "type": "string",
            "description": "Specifies a base64-encoded PGP public key."
          }
        }
      },
      "WriteGenerateRootUpdateRequest": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "Specifies a single unseal key share."
          },
          "nonce": {
            "type": "string",
            "description": "Specifies the nonce of the attempt."
          }
        }
      },
      "WriteInitRequest": {
        "type": "object",
        "properties": {
          "pgp_keys": {
            "type": "array",
            "description": "Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as `secret_shares`.",
            "items": {
              "type": "string"
            }
          },
          "recovery_pgp_keys": {
            "type": "array",
            "description": "Specifies an array of PGP public keys used to encrypt the output recovery keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as `recovery_shares`.",
            "items": {
              "type": "string"
            }
          },
          "recovery_shares": {
            "type": "integer",
            "description": "Specifies the number of shares to split the recovery key into."
          },
          "recovery_threshold": {
            "type": "integer",
            "description": "Specifies the number of shares required to reconstruct the recovery key. This must be less than or equal to `recovery_shares`."
          },
          "root_token_pgp_key": {
            "type": "string",
            "description": "Specifies a PGP public key used to encrypt the initial root token. The key must be base64-encoded from its original binary representation."
          },
          "secret_shares": {
            "type": "integer",
            "description": "Specifies the number of shares to split the unseal key into."
          },
          "secret_threshold": {
            "type": "integer",
            "description": "Specifies the number of shares required to reconstruct the unseal key. This must be less than or equal secret_shares. If using Vault HSM with auto-unsealing, this value must be the same as `secret_shares`."
          },
          "stored_shares": {
            "type": "integer",
            "description": "Specifies the number of shares that should be encrypted by the HSM and stored for auto-unsealing. Currently must be the same as `secret_shares`."
          }
        }
      },
      "WriteInternalCountersConfigRequest": {
        "type": "object",
        "properties": {
          "default_report_months": {
            "type": "integer",
            "description": "Number of months to report if no start date specified.",
            "default": 12
          },
          "enabled": {
            "type": "string",
            "description": "Enable or disable collection of client count: enable, disable, or default.",
            "default": "default"
          },
          "retention_months": {
            "type": "integer",
            "description": "Number of months of client data to retain. Setting to 0 will clear all existing data.",
            "default": 24
          }
        }
      },
      "WriteInternalSpecsOpenAPIRequest": {
        "type": "object",
        "properties": {
          "context": {
            "type": "string",
            "description": "Context string appended to every operationId"
          }
        }
      },
      "WriteLeasesLookupRequest": {
        "type": "object",
        "properties": {
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "WriteLeasesRenew2Request": {
        "type": "object",
        "properties": {
          "increment": {
            "type": "integer",
            "description": "The desired increment in seconds to the lease",
            "format": "seconds"
          },
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "WriteLeasesRenewRequest": {
        "type": "object",
        "properties": {
          "increment": {
            "type": "integer",
            "description": "The desired increment in seconds to the lease",
            "format": "seconds"
          },
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          },
          "url_lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "WriteLeasesRevoke2Request": {
        "type": "object",
        "properties": {
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          },
          "sync": {
            "type": "boolean",
            "description": "Whether or not to perform the revocation synchronously",
            "default": true
          }
        }
      },
      "WriteLeasesRevokePrefixRequest": {
        "type": "object",
        "properties": {
          "sync": {
            "type": "boolean",
            "description": "Whether or not to perform the revocation synchronously",
            "default": true
          }
        }
      },
      "WriteLeasesRevokeRequest": {
        "type": "object",
        "properties": {
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          },
          "sync": {
            "type": "boolean",
            "description": "Whether or not to perform the revocation synchronously",
            "default": true
          },
          "url_lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "WriteLoggerRequest": {
        "type": "object",
        "properties": {
          "level": {
            "type": "string",
            "description": "Log verbosity level. Supported values (in order of detail) are \"trace\", \"debug\", \"info\", \"warn\", and \"error\"."
          }
        }
      },
      "WriteLoggersRequest": {
        "type": "object",
        "properties": {
          "level": {
            "type": "string",
            "description": "Log verbosity level. Supported values (in order of detail) are \"trace\", \"debug\", \"info\", \"warn\", and \"error\"."
          }
        }
      },
      "WriteMountRequest": {
        "type": "object",
        "properties": {
          "config": {
            "type": "object",
            "description": "Configuration for this mount, such as default_lease_ttl and max_lease_ttl.",
            "format": "map"
          },
          "description": {
            "type": "string",
            "description": "User-friendly description for this mount."
          },
          "external_entropy_access": {
            "type": "boolean",
            "description": "Whether to give the mount access to Vault's external entropy.",
            "default": false
          },
          "local": {
            "type": "boolean",
            "description": "Mark the mount as a local mount, which is not replicated and is unaffected by replication.",
            "default": false
          },
          "options": {
            "type": "object",
            "description": "The options to pass into the backend. Should be a json object with string keys and values.",
            "format": "kvpairs"
          },
          "plugin_name": {
            "type": "string",
            "description": "Name of the plugin to mount based from the name registered in the plugin catalog."
          },
          "plugin_version": {
            "type": "string",
            "description": "The semantic version of the plugin to use."
          },
          "seal_wrap": {
            "type": "boolean",
            "description": "Whether to turn on seal wrapping for the mount.",
            "default": false
          },
          "type": {
            "type": "string",
            "description": "The type of the backend. Example: \"passthrough\""
          }
        }
      },
      "WriteMountsConfigRequest": {
        "type": "object",
        "properties": {
          "allowed_managed_keys": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "allowed_response_headers": {
            "type": "array",
            "description": "A list of headers to whitelist and allow a plugin to set on responses.",
            "items": {
              "type": "string"
            }
          },
          "audit_non_hmac_request_keys": {
            "type": "array",
            "description": "The list of keys in the request data object that will not be HMAC'ed by audit devices.",
            "items": {
              "type": "string"
            }
          },
          "audit_non_hmac_response_keys": {
            "type": "array",
            "description": "The list of keys in the response data object that will not be HMAC'ed by audit devices.",
            "items": {
              "type": "string"
            }
          },
          "default_lease_ttl": {
            "type": "string",
            "description": "The default lease TTL for this mount."
          },
          "description": {
            "type": "string",
            "description": "User-friendly description for this credential backend."
          },
          "listing_visibility": {
            "type": "string",
            "description": "Determines the visibility of the mount in the UI-specific listing endpoint. Accepted value are 'unauth' and 'hidden', with the empty default ('') behaving like 'hidden'."
          },
          "max_lease_ttl": {
            "type": "string",
            "description": "The max lease TTL for this mount."
          },
          "options": {
            "type": "object",
            "description": "The options to pass into the backend. Should be a json object with string keys and values.",
            "format": "kvpairs"
          },
          "passthrough_request_headers": {
            "type": "array",
            "description": "A list of headers to whitelist and pass from the request to the plugin.",
            "items": {
              "type": "string"
            }
          },
          "plugin_version": {
            "type": "string",
            "description": "The semantic version of the plugin to use."
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to issue (service or batch)."
          },
          "user_lockout_config": {
            "type": "object",
            "description": "The user lockout configuration to pass into the backend. Should be a json object with string keys and values.",
            "format": "map"
          }
        }
      },
      "WritePluginsCatalogByTypeByNameRequest": {
        "type": "object",
        "properties": {
          "args": {
            "type": "array",
            "description": "The args passed to plugin command.",
            "items": {
              "type": "string"
            }
          },
          "command": {
            "type": "string",
            "description": "The command used to start the plugin. The executable defined in this command must exist in vault's plugin directory."
          },
          "env": {
            "type": "array",
            "description": "The environment variables passed to plugin command. Each entry is of the form \"key=value\".",
            "items": {
              "type": "string"
            }
          },
          "sha256": {
            "type": "string",
            "description": "The SHA256 sum of the executable used in the command field. This should be HEX encoded."
          },
          "version": {
            "type": "string",
            "description": "The semantic version of the plugin to use."
          }
        }
      },
      "WritePluginsReloadBackendRequest": {
        "type": "object",
        "properties": {
          "mounts": {
            "type": "array",
            "description": "The mount paths of the plugin backends to reload.",
            "items": {
              "type": "string"
            }
          },
          "plugin": {
            "type": "string",
            "description": "The name of the plugin to reload, as registered in the plugin catalog."
          },
          "scope": {
            "type": "string"
          }
        }
      },
      "WritePoliciesACLRequest": {
        "type": "object",
        "properties": {
          "policy": {
            "type": "string",
            "description": "The rules of the policy."
          }
        }
      },
      "WritePoliciesPasswordRequest": {
        "type": "object",
        "properties": {
          "policy": {
            "type": "string",
            "description": "The password policy"
          }
        }
      },
      "WritePolicyRequest": {
        "type": "object",
        "properties": {
          "policy": {
            "type": "string",
            "description": "The rules of the policy."
          },
          "rules": {
            "type": "string",
            "description": "The rules of the policy.",
            "deprecated": true
          }
        }
      },
      "WriteQuotasConfigRequest": {
        "type": "object",
        "properties": {
          "enable_rate_limit_audit_logging": {
            "type": "boolean",
            "description": "If set, starts audit logging of requests that get rejected due to rate limit quota rule violations."
          },
          "enable_rate_limit_response_headers": {
            "type": "boolean",
            "description": "If set, additional rate limit quota HTTP headers will be added to responses."
          },
          "rate_limit_exempt_paths": {
            "type": "array",
            "description": "Specifies the list of exempt paths from all rate limit quotas. If empty no paths will be exempt.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "WriteQuotasRateLimitRequest": {
        "type": "object",
        "properties": {
          "block_interval": {
            "type": "integer",
            "description": "If set, when a client reaches a rate limit threshold, the client will be prohibited from any further requests until after the 'block_interval' has elapsed.",
            "format": "seconds"
          },
          "interval": {
            "type": "integer",
            "description": "The duration to enforce rate limiting for (default '1s').",
            "format": "seconds"
          },
          "path": {
            "type": "string",
            "description": "Path of the mount or namespace to apply the quota. A blank path configures a global quota. For example namespace1/ adds a quota to a full namespace, namespace1/auth/userpass adds a quota to userpass in namespace1."
          },
          "rate": {
            "type": "number",
            "description": "The maximum number of requests in a given interval to be allowed by the quota rule. The 'rate' must be positive.",
            "format": "float"
          },
          "role": {
            "type": "string",
            "description": "Login role to apply this quota to. Note that when set, path must be configured to a valid auth method with a concept of roles."
          },
          "type": {
            "type": "string",
            "description": "Type of the quota rule."
          }
        }
      },
      "WriteRawPathRequest": {
        "type": "object",
        "properties": {
          "compressed": {
            "type": "boolean"
          },
          "compression_type": {
            "type": "string"
          },
          "encoding": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        }
      },
      "WriteRawRequest": {
        "type": "object",
        "properties": {
          "compressed": {
            "type": "boolean"
          },
          "compression_type": {
            "type": "string"
          },
          "encoding": {
            "type": "string"
          },
          "path": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        }
      },
      "WriteRekeyInitRequest": {
        "type": "object",
        "properties": {
          "backup": {
            "type": "boolean",
            "description": "Specifies if using PGP-encrypted keys, whether Vault should also store a plaintext backup of the PGP-encrypted keys."
          },
          "pgp_keys": {
            "type": "array",
            "description": "Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as secret_shares.",
            "items": {
              "type": "string"
            }
          },
          "require_verification": {
            "type": "boolean",
            "description": "Turns on verification functionality"
          },
          "secret_shares": {
            "type": "integer",
            "description": "Specifies the number of shares to split the unseal key into."
          },
          "secret_threshold": {
            "type": "integer",
            "description": "Specifies the number of shares required to reconstruct the unseal key. This must be less than or equal secret_shares. If using Vault HSM with auto-unsealing, this value must be the same as secret_shares."
          }
        }
      },
      "WriteRekeyUpdateRequest": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "Specifies a single unseal key share."
          },
          "nonce": {
            "type": "string",
            "description": "Specifies the nonce of the rekey attempt."
          }
        }
      },
      "WriteRekeyVerifyRequest": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "Specifies a single unseal share key from the new set of shares."
          },
          "nonce": {
            "type": "string",
            "description": "Specifies the nonce of the rekey verification operation."
          }
        }
      },
      "WriteRotateConfigRequest": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "Whether automatic rotation is enabled."
          },
          "interval": {
            "type": "integer",
            "description": "How long after installation of an active key term that the key will be automatically rotated.",
            "format": "seconds"
          },
          "max_operations": {
            "type": "integer",
            "description": "The number of encryption operations performed before the barrier key is automatically rotated.",
            "format": "int64"
          }
        }
      }
    }
  }
}
