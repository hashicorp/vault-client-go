{{>partial_header}}
package {{packageName}}

import (
	"context"
	"fmt"
	"net"
	"net/http"
	"net/url"
	"strings"
	"sync"

	"github.com/hashicorp/go-retryablehttp"
)

// Client manages communication with Vault, initialize it with vault.New(...)
type Client struct {
	// configuration object is immutable after the client has been initialized
	configuration ClientConfiguration

	parsedBaseAddress *url.URL

	client            *http.Client
	clientWithRetries *retryablehttp.Client

	// headers & callbacks that will be applied to each request
	clientRequestModifiers     requestModifiers
	clientRequestModifiersLock sync.RWMutex

	// replication state cache used to ensure read-after-write semantics
	replicationStates replicationStateCache

	// API wrappers
{{#apiInfo}}
{{#apis}}
{{#operations}}
	{{classname}} {{classname}}
{{/operations}}
{{/apis}}
{{/apiInfo}}
}

// New returns a new client decorated with the given configuration options
func New(options ...ClientOption) (*Client, error) {
	configuration := DefaultConfiguration()

	for _, option := range options {
		if err := option(&configuration); err != nil {
			return nil, err
		}
	}

	return newClient(configuration)
}

// newClient returns a new Vault client with a copy of the given configuration
func newClient(configuration Configuration) (*Client, error) {
	c := Client{
		configuration: configuration,

		// configured or default HTTP client
		client: configuration.BaseClient,

		// retryablehttp wrapper around the HTTP client
		clientWithRetries: &retryablehttp.Client{
			HTTPClient:   configuration.BaseClient,
			Logger:       configuration.Retries.Logger,
			RetryWaitMin: configuration.Retries.RetryWaitMin,
			RetryWaitMax: configuration.Retries.RetryWaitMax,
			RetryMax:     configuration.Retries.RetryMax,
			CheckRetry:   configuration.Retries.CheckRetry,
			Backoff:      configuration.Retries.Backoff,
			ErrorHandler: configuration.Retries.ErrorHandler,
		},

		clientRequestModifiers: requestModifiers{
			headers: requestHeaders{
				userAgent:                 userAgent("{{packageVersion}}"),
				token:                     configuration.initialToken,
				namespace:                 configuration.initialNamespace,
				replicationForwardingMode: ReplicationForwardNone,
			},
		},
		clientRequestModifiersLock: sync.RWMutex{},
	}

	address, err := parseAddress(configuration.BaseAddress)
	if err != nil {
		return nil, err
	}
	c.parsedBaseAddress = address

	// Internet draft https://datatracker.ietf.org/doc/html/draft-andrews-http-srv-02
	// specifies that the port must be empty
	if configuration.EnableSRVLookup && address.Port() != "" {
		return nil, fmt.Errorf("cannot enable DNS service record (SRV) lookup since the base address port (%q) is not empty", address.Port())
	}

	transport, ok := c.client.Transport.(*http.Transport);
	if !ok {
		return nil, fmt.Errorf("the configured base client's transport (%T) is not of type *http.Transport", c.client.Transport)
	}

	// Adjust the dial contex for unix domain socket addresses
	if strings.HasPrefix(configuration.BaseAddress, "unix://") {
		transport.DialContext = func(context.Context, string, string) (net.Conn, error) {
			socket := strings.TrimPrefix(configuration.BaseAddress, "unix://")
			return net.Dial("unix", socket)
		}
	}

	if err := configuration.TLS.applyTo(transport.TLSClientConfig); err != nil {
		return nil, err
	}

{{#apiInfo}}
{{#apis}}
{{#operations}}
	c.{{classname}} = {{classname}}{
		client: &c,
	}
{{/operations}}
{{/apis}}
{{/apiInfo}}

	return &c, nil
}

// parseAddress parses the given address string with special handling for unix
// domain sockets
func parseAddress(address string) (*url.URL, error) {
	parsed, err := url.Parse(address)
	if err != nil {
		return nil, err
	}

	if strings.HasPrefix(address, "unix://") {
		// The address in the client is expected to be pointing to the protocol
		// used in the application layer and not to the transport layer. Hence,
		// setting the fields accordingly.
		parsed.Scheme = "http"
		parsed.Host = strings.TrimPrefix(address, "unix://") // socket
		parsed.Path = ""
	}

	return parsed, nil
}

// Clone creates a new client with the same configuration, request modifiers,
// and replication states as the original client. Note that the cloned client
// will point to the same base http.Client and retryablehttp.Client objects.
func (c *Client) Clone() *Client {
	clone := Client{
		configuration:     c.configuration,
		parsedBaseAddress: c.parsedBaseAddress,
		client:            c.client,
		clientWithRetries: c.clientWithRetries,
	}

	if c.configuration.EnforceReadYourWritesConsistency {
		clone.replicationStates = c.replicationStates.clone()
	}

	clone.clientRequestModifiers = c.cloneClientRequestModifiers()

{{#apiInfo}}
{{#apis}}
{{#operations}}
	clone.{{classname}} = {{classname}} {
		client: &clone,
	}
{{/operations}}
{{/apis}}
{{/apiInfo}}

	return &clone
}

// cloneClientRequestModifiers returns a copy of the modifiers behind a mutex
func (c *Client) cloneClientRequestModifiers() requestModifiers {
	/* */ c.clientRequestModifiersLock.RLock()
	defer c.clientRequestModifiersLock.RUnlock()

	var clone requestModifiers

	copy(clone.requestCallbacks, c.clientRequestModifiers.requestCallbacks)
	copy(clone.responseCallbacks, c.clientRequestModifiers.responseCallbacks)

	clone.headers = requestHeaders{
		token:                     c.clientRequestModifiers.headers.token,
		namespace:                 c.clientRequestModifiers.headers.namespace,
		responseWrappingTTL:       c.clientRequestModifiers.headers.responseWrappingTTL,
		replicationForwardingMode: c.clientRequestModifiers.headers.replicationForwardingMode,
		customHeaders:             c.clientRequestModifiers.headers.customHeaders.Clone(),
	}

	copy(clone.headers.mfaCredentials, c.clientRequestModifiers.headers.mfaCredentials)

	return clone
}

// Configuration returns a copy of the configuration object used to initialize
// this client
func (c *Client) Configuration() Configuration {
	return c.configuration
}
