{{>partial_header}}
package {{packageName}}

import (
	"bytes"
	"context"
	"encoding/json"
	"encoding/xml"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"reflect"
	"regexp"
	"strings"
	"time"

	"github.com/hashicorp/go-retryablehttp"
)

var (
	jsonCheck = regexp.MustCompile(`(?i:(?:application|text)/(?:vnd\.[^;]+\+)?json)`)
	xmlCheck  = regexp.MustCompile(`(?i:(?:application|text)/xml)`)
)

// Client manages communication with the {{appName}} v{{version}}
// In most cases there should be only one, shared, Client.
type Client struct {
	configuration Configuration

	client            *http.Client
	clientWithRetries *retryablehttp.Client

	parsedBaseAddress *url.URL

	// API wrappers
{{#apiInfo}}
{{#apis}}
{{#operations}}
	{{classname}} {{classname}}
{{/operations}}
{{/apis}}
{{/apiInfo}}
}


// NewClient returns a new Vault client with a copy of the given configuration
func NewClient(configuration Configuration) (*Client, error) {
	c := Client{
		configuration: configuration,

		// configured or default HTTP client
		client: configuration.HTTPClient,

		// retryablehttp wrapper around the HTTP client
		clientWithRetries: &retryablehttp.Client{
			HTTPClient:   configuration.HTTPClient,
			Logger:       configuration.RetryOptions.Logger,
			RetryWaitMin: configuration.RetryOptions.RetryWaitMin,
			RetryWaitMax: configuration.RetryOptions.RetryWaitMax,
			RetryMax:     configuration.RetryOptions.RetryMax,
			CheckRetry:   configuration.RetryOptions.CheckRetry,
			Backoff:      configuration.RetryOptions.Backoff,
			ErrorHandler: configuration.RetryOptions.ErrorHandler,
		},
	}

	a, err := url.Parse(configuration.BaseAddress)
	if err != nil {
		return nil, err
	}

	c.parsedBaseAddress = a

{{#apiInfo}}
	// API wrappers
{{#apis}}
{{#operations}}
	c.{{classname}} = {{classname}} {
		client: &c,
	}
{{/operations}}
{{/apis}}
{{/apiInfo}}

	return &c, nil
}

// NewStructuredRequest expects json.Marshaler encoded request body and returns a new request with vault-specific headers
func (c *Client) NewStructuredRequest(method, path string, body json.Marshaler) (*http.Request, error) {
	if body == nil {
		return c.NewRequest(method, path, nil)
	}

	buf := bytes.Buffer{}

	if err := json.NewEncoder(&buf).Encode(body); err != nil {
		return nil, fmt.Errorf("could not encode request body: %w", err)
	}

	return c.NewRequest(method, path, &buf)
}

// NewRequest returns a new request with vault-specific headers
func (c *Client) NewRequest(method, path string, body io.Reader) (*http.Request, error) {
	// concatenate the base address with the given path
	url, err := c.parsedBaseAddress.Parse(path)
	if err != nil {
		return nil, err
	}

	return http.NewRequest(method, url.String(), body)
}

// Do wraps http.client.Do or retryablehttp.client.Do to send an http request
func (c *Client) Do(ctx context.Context, req *http.Request, retry bool) (*http.Response, error) {
	var resp *http.Response

	req = req.WithContext(ctx)

	if retry {
		retryableReq, err := retryablehttp.FromRequest(req)
		if err != nil {
			return nil, fmt.Errorf("could not form a retryable request: %w", err)
		}

		r, err := c.clientWithRetries.Do(retryableReq)
		if err != nil {
			return nil, err
		}

		resp = r
	} else {
		r, err := c.client.Do(req)
		if err != nil {
			return nil, err
		}

		resp = r
	}

	return resp, nil
}
