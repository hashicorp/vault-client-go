/*
HashiCorp Vault API

HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.

API version: 1.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package vault

import (
	"context"
	"net/http"
	"net/url"
	"strings"
)

// Auth is a simple wrapper around the client for Auth requests
type Auth struct {
	client *Client
}

// DeleteAuthAlicloudRoleRole Create a role and associate policies to it.
// role: The name of the role as it should appear in Vault.
func (a *Auth) DeleteAuthAlicloudRoleRole(ctx context.Context, role string) (*http.Response, error) {
	requestPath := "/v1/auth/alicloud/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAppIdMapAppIdKey Read/write/delete a single app-id mapping
// key: Key for the app-id mapping
func (a *Auth) DeleteAuthAppIdMapAppIdKey(ctx context.Context, key string) (*http.Response, error) {
	requestPath := "/v1/auth/app-id/map/app-id/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAppIdMapUserIdKey Read/write/delete a single user-id mapping
// key: Key for the user-id mapping
func (a *Auth) DeleteAuthAppIdMapUserIdKey(ctx context.Context, key string) (*http.Response, error) {
	requestPath := "/v1/auth/app-id/map/user-id/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleName Register an role with the backend.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleName(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleNameBindSecretId Impose secret_id to be presented during login using this role.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameBindSecretId(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/bind-secret-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleNameBoundCidrList Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameBoundCidrList(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/bound-cidr-list"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleNamePeriod Updates the value of 'period' on the role
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNamePeriod(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/period"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleNamePolicies Policies of the role.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNamePolicies(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/policies"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroy
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameSecretIdAccessorDestroy(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-accessor/destroy"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleNameSecretIdBoundCidrs Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameSecretIdBoundCidrs(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-bound-cidrs"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleNameSecretIdDestroy Invalidate an issued secret_id
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameSecretIdDestroy(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id/destroy"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleNameSecretIdNumUses Use limit of the SecretID generated against the role.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameSecretIdNumUses(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-num-uses"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleNameSecretIdTtl Duration in seconds, representing the lifetime of the SecretIDs that are generated against the role using 'role/<role_name>/secret-id' or 'role/<role_name>/custom-secret-id' endpoints.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameSecretIdTtl(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleNameTokenBoundCidrs Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameTokenBoundCidrs(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-bound-cidrs"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleNameTokenMaxTtl Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameTokenMaxTtl(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-max-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleNameTokenNumUses Number of times issued tokens can be used
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameTokenNumUses(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-num-uses"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthApproleRoleRoleNameTokenTtl Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
// roleName: Name of the role.
func (a *Auth) DeleteAuthApproleRoleRoleNameTokenTtl(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAwsConfigCertificateCertName
// certName: Name of the certificate.
func (a *Auth) DeleteAuthAwsConfigCertificateCertName(ctx context.Context, certName string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/certificate/{cert_name}"
	requestPath = strings.Replace(requestPath, "{"+"cert_name"+"}", url.PathEscape(certName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAwsConfigClient
func (a *Auth) DeleteAuthAwsConfigClient(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/client"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAwsConfigStsAccountId
// accountId: AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.
func (a *Auth) DeleteAuthAwsConfigStsAccountId(ctx context.Context, accountId string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/sts/{account_id}"
	requestPath = strings.Replace(requestPath, "{"+"account_id"+"}", url.PathEscape(accountId), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAwsConfigTidyIdentityAccesslist
func (a *Auth) DeleteAuthAwsConfigTidyIdentityAccesslist(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/tidy/identity-accesslist"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAwsConfigTidyIdentityWhitelist
func (a *Auth) DeleteAuthAwsConfigTidyIdentityWhitelist(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/tidy/identity-whitelist"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAwsConfigTidyRoletagBlacklist
func (a *Auth) DeleteAuthAwsConfigTidyRoletagBlacklist(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/tidy/roletag-blacklist"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAwsConfigTidyRoletagDenylist
func (a *Auth) DeleteAuthAwsConfigTidyRoletagDenylist(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/tidy/roletag-denylist"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAwsIdentityAccesslistInstanceId
// instanceId: EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.
func (a *Auth) DeleteAuthAwsIdentityAccesslistInstanceId(ctx context.Context, instanceId string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/identity-accesslist/{instance_id}"
	requestPath = strings.Replace(requestPath, "{"+"instance_id"+"}", url.PathEscape(instanceId), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAwsIdentityWhitelistInstanceId
// instanceId: EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.
func (a *Auth) DeleteAuthAwsIdentityWhitelistInstanceId(ctx context.Context, instanceId string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/identity-whitelist/{instance_id}"
	requestPath = strings.Replace(requestPath, "{"+"instance_id"+"}", url.PathEscape(instanceId), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAwsRoleRole
// role: Name of the role.
func (a *Auth) DeleteAuthAwsRoleRole(ctx context.Context, role string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAwsRoletagBlacklistRoleTag
// roleTag: Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.
func (a *Auth) DeleteAuthAwsRoletagBlacklistRoleTag(ctx context.Context, roleTag string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/roletag-blacklist/{role_tag}"
	requestPath = strings.Replace(requestPath, "{"+"role_tag"+"}", url.PathEscape(roleTag), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAwsRoletagDenylistRoleTag
// roleTag: Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.
func (a *Auth) DeleteAuthAwsRoletagDenylistRoleTag(ctx context.Context, roleTag string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/roletag-denylist/{role_tag}"
	requestPath = strings.Replace(requestPath, "{"+"role_tag"+"}", url.PathEscape(roleTag), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAzureConfig
func (a *Auth) DeleteAuthAzureConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/azure/config"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthAzureRoleName
// name: Name of the role.
func (a *Auth) DeleteAuthAzureRoleName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/azure/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthCertCertsName Manage trusted certificates used for authentication.
// name: The name of the certificate
func (a *Auth) DeleteAuthCertCertsName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/cert/certs/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthCertCrlsName Manage Certificate Revocation Lists checked during authentication.
// name: The name of the certificate
func (a *Auth) DeleteAuthCertCrlsName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/cert/crls/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthCfConfig
func (a *Auth) DeleteAuthCfConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/cf/config"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthCfRolesRole
// role: The name of the role.
func (a *Auth) DeleteAuthCfRolesRole(ctx context.Context, role string) (*http.Response, error) {
	requestPath := "/v1/auth/cf/roles/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthGcpRoleName Create a GCP role with associated policies and required attributes.
// name: Name of the role.
func (a *Auth) DeleteAuthGcpRoleName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/gcp/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthGithubMapTeamsKey Read/write/delete a single teams mapping
// key: Key for the teams mapping
func (a *Auth) DeleteAuthGithubMapTeamsKey(ctx context.Context, key string) (*http.Response, error) {
	requestPath := "/v1/auth/github/map/teams/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthGithubMapUsersKey Read/write/delete a single users mapping
// key: Key for the users mapping
func (a *Auth) DeleteAuthGithubMapUsersKey(ctx context.Context, key string) (*http.Response, error) {
	requestPath := "/v1/auth/github/map/users/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthJwtRoleName Delete an existing role.
// name: Name of the role.
func (a *Auth) DeleteAuthJwtRoleName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/jwt/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthKerberosGroupsName
// name: Name of the LDAP group.
func (a *Auth) DeleteAuthKerberosGroupsName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/kerberos/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthKubernetesRoleName Register an role with the backend.
// name: Name of the role.
func (a *Auth) DeleteAuthKubernetesRoleName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/kubernetes/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthLdapGroupsName Manage additional groups for users allowed to authenticate.
// name: Name of the LDAP group.
func (a *Auth) DeleteAuthLdapGroupsName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/ldap/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthLdapUsersName Manage users allowed to authenticate.
// name: Name of the LDAP user.
func (a *Auth) DeleteAuthLdapUsersName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/ldap/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthOciConfig Manages the configuration for the Vault Auth Plugin.
func (a *Auth) DeleteAuthOciConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/oci/config"

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthOciRoleRole Create a role and associate policies to it.
// role: Name of the role.
func (a *Auth) DeleteAuthOciRoleRole(ctx context.Context, role string) (*http.Response, error) {
	requestPath := "/v1/auth/oci/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthOidcRoleName Delete an existing role.
// name: Name of the role.
func (a *Auth) DeleteAuthOidcRoleName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/oidc/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthOktaGroupsName Manage users allowed to authenticate.
// name: Name of the Okta group.
func (a *Auth) DeleteAuthOktaGroupsName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/okta/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthOktaUsersName Manage additional groups for users allowed to authenticate.
// name: Name of the user.
func (a *Auth) DeleteAuthOktaUsersName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/okta/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthRadiusUsersName Manage users allowed to authenticate.
// name: Name of the RADIUS user.
func (a *Auth) DeleteAuthRadiusUsersName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/radius/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthTokenRolesRoleName
// roleName: Name of the role
func (a *Auth) DeleteAuthTokenRolesRoleName(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/token/roles/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// DeleteAuthUserpassUsersUsername Manage users allowed to authenticate.
// username: Username for this user.
func (a *Auth) DeleteAuthUserpassUsersUsername(ctx context.Context, username string) (*http.Response, error) {
	requestPath := "/v1/auth/userpass/users/{username}"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newRequest(ctx, http.MethodDelete, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAlicloudRole Lists all the roles that are registered with Vault.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAlicloudRole(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/alicloud/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAlicloudRoleRole Create a role and associate policies to it.
// role: The name of the role as it should appear in Vault.
func (a *Auth) GetAuthAlicloudRoleRole(ctx context.Context, role string) (*http.Response, error) {
	requestPath := "/v1/auth/alicloud/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAlicloudRoles Lists all the roles that are registered with Vault.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAlicloudRoles(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/alicloud/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAppIdMapAppId Read mappings for app-id
// list: Return a list if &#x60;true&#x60;
func (a *Auth) GetAuthAppIdMapAppId(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/app-id/map/app-id"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAppIdMapAppIdKey Read/write/delete a single app-id mapping
// key: Key for the app-id mapping
func (a *Auth) GetAuthAppIdMapAppIdKey(ctx context.Context, key string) (*http.Response, error) {
	requestPath := "/v1/auth/app-id/map/app-id/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAppIdMapUserId Read mappings for user-id
// list: Return a list if &#x60;true&#x60;
func (a *Auth) GetAuthAppIdMapUserId(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/app-id/map/user-id"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAppIdMapUserIdKey Read/write/delete a single user-id mapping
// key: Key for the user-id mapping
func (a *Auth) GetAuthAppIdMapUserIdKey(ctx context.Context, key string) (*http.Response, error) {
	requestPath := "/v1/auth/app-id/map/user-id/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRole Lists all the roles registered with the backend.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthApproleRole(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleName Register an role with the backend.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleName(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNameBindSecretId Impose secret_id to be presented during login using this role.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameBindSecretId(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/bind-secret-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNameBoundCidrList Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameBoundCidrList(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/bound-cidr-list"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNameLocalSecretIds Enables cluster local secret IDs
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameLocalSecretIds(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/local-secret-ids"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNamePeriod Updates the value of 'period' on the role
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNamePeriod(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/period"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNamePolicies Policies of the role.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNamePolicies(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/policies"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNameRoleId Returns the 'role_id' of the role.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameRoleId(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/role-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNameSecretId Generate a SecretID against this role.
// roleName: Name of the role.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthApproleRoleRoleNameSecretId(ctx context.Context, roleName string, list string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNameSecretIdBoundCidrs Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameSecretIdBoundCidrs(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-bound-cidrs"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNameSecretIdNumUses Use limit of the SecretID generated against the role.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameSecretIdNumUses(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-num-uses"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNameSecretIdTtl Duration in seconds, representing the lifetime of the SecretIDs that are generated against the role using 'role/<role_name>/secret-id' or 'role/<role_name>/custom-secret-id' endpoints.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameSecretIdTtl(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNameTokenBoundCidrs Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameTokenBoundCidrs(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-bound-cidrs"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNameTokenMaxTtl Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameTokenMaxTtl(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-max-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNameTokenNumUses Number of times issued tokens can be used
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameTokenNumUses(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-num-uses"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthApproleRoleRoleNameTokenTtl Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
// roleName: Name of the role.
func (a *Auth) GetAuthApproleRoleRoleNameTokenTtl(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsConfigCertificateCertName
// certName: Name of the certificate.
func (a *Auth) GetAuthAwsConfigCertificateCertName(ctx context.Context, certName string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/certificate/{cert_name}"
	requestPath = strings.Replace(requestPath, "{"+"cert_name"+"}", url.PathEscape(certName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsConfigCertificates
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsConfigCertificates(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/certificates"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsConfigClient
func (a *Auth) GetAuthAwsConfigClient(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/client"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsConfigIdentity
func (a *Auth) GetAuthAwsConfigIdentity(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/identity"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsConfigSts
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsConfigSts(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/sts"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsConfigStsAccountId
// accountId: AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.
func (a *Auth) GetAuthAwsConfigStsAccountId(ctx context.Context, accountId string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/sts/{account_id}"
	requestPath = strings.Replace(requestPath, "{"+"account_id"+"}", url.PathEscape(accountId), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsConfigTidyIdentityAccesslist
func (a *Auth) GetAuthAwsConfigTidyIdentityAccesslist(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/tidy/identity-accesslist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsConfigTidyIdentityWhitelist
func (a *Auth) GetAuthAwsConfigTidyIdentityWhitelist(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/tidy/identity-whitelist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsConfigTidyRoletagBlacklist
func (a *Auth) GetAuthAwsConfigTidyRoletagBlacklist(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/tidy/roletag-blacklist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsConfigTidyRoletagDenylist
func (a *Auth) GetAuthAwsConfigTidyRoletagDenylist(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/tidy/roletag-denylist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsIdentityAccesslist
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsIdentityAccesslist(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/identity-accesslist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsIdentityAccesslistInstanceId
// instanceId: EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.
func (a *Auth) GetAuthAwsIdentityAccesslistInstanceId(ctx context.Context, instanceId string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/identity-accesslist/{instance_id}"
	requestPath = strings.Replace(requestPath, "{"+"instance_id"+"}", url.PathEscape(instanceId), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsIdentityWhitelist
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsIdentityWhitelist(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/identity-whitelist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsIdentityWhitelistInstanceId
// instanceId: EC2 instance ID. A successful login operation from an EC2 instance gets cached in this accesslist, keyed off of instance ID.
func (a *Auth) GetAuthAwsIdentityWhitelistInstanceId(ctx context.Context, instanceId string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/identity-whitelist/{instance_id}"
	requestPath = strings.Replace(requestPath, "{"+"instance_id"+"}", url.PathEscape(instanceId), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsRole
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsRole(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsRoleRole
// role: Name of the role.
func (a *Auth) GetAuthAwsRoleRole(ctx context.Context, role string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsRoles
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsRoles(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsRoletagBlacklist
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsRoletagBlacklist(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/roletag-blacklist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsRoletagBlacklistRoleTag
// roleTag: Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.
func (a *Auth) GetAuthAwsRoletagBlacklistRoleTag(ctx context.Context, roleTag string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/roletag-blacklist/{role_tag}"
	requestPath = strings.Replace(requestPath, "{"+"role_tag"+"}", url.PathEscape(roleTag), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsRoletagDenylist
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAwsRoletagDenylist(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/roletag-denylist"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAwsRoletagDenylistRoleTag
// roleTag: Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.
func (a *Auth) GetAuthAwsRoletagDenylistRoleTag(ctx context.Context, roleTag string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/roletag-denylist/{role_tag}"
	requestPath = strings.Replace(requestPath, "{"+"role_tag"+"}", url.PathEscape(roleTag), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAzureConfig
func (a *Auth) GetAuthAzureConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/azure/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAzureRole
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthAzureRole(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/azure/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthAzureRoleName
// name: Name of the role.
func (a *Auth) GetAuthAzureRoleName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/azure/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthCentrifyConfig This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform for authenticating users.
func (a *Auth) GetAuthCentrifyConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/centrify/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthCertCerts Manage trusted certificates used for authentication.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthCertCerts(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/cert/certs"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthCertCertsName Manage trusted certificates used for authentication.
// name: The name of the certificate
func (a *Auth) GetAuthCertCertsName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/cert/certs/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthCertCrlsName Manage Certificate Revocation Lists checked during authentication.
// name: The name of the certificate
func (a *Auth) GetAuthCertCrlsName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/cert/crls/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthCfConfig
func (a *Auth) GetAuthCfConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/cf/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthCfRoles
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthCfRoles(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/cf/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthCfRolesRole
// role: The name of the role.
func (a *Auth) GetAuthCfRolesRole(ctx context.Context, role string) (*http.Response, error) {
	requestPath := "/v1/auth/cf/roles/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthGcpConfig Configure credentials used to query the GCP IAM API to verify authenticating service accounts
func (a *Auth) GetAuthGcpConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/gcp/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthGcpRole Lists all the roles that are registered with Vault.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthGcpRole(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/gcp/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthGcpRoleName Create a GCP role with associated policies and required attributes.
// name: Name of the role.
func (a *Auth) GetAuthGcpRoleName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/gcp/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthGcpRoles Lists all the roles that are registered with Vault.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthGcpRoles(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/gcp/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthGithubConfig
func (a *Auth) GetAuthGithubConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/github/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthGithubMapTeams Read mappings for teams
// list: Return a list if &#x60;true&#x60;
func (a *Auth) GetAuthGithubMapTeams(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/github/map/teams"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthGithubMapTeamsKey Read/write/delete a single teams mapping
// key: Key for the teams mapping
func (a *Auth) GetAuthGithubMapTeamsKey(ctx context.Context, key string) (*http.Response, error) {
	requestPath := "/v1/auth/github/map/teams/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthGithubMapUsers Read mappings for users
// list: Return a list if &#x60;true&#x60;
func (a *Auth) GetAuthGithubMapUsers(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/github/map/users"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthGithubMapUsersKey Read/write/delete a single users mapping
// key: Key for the users mapping
func (a *Auth) GetAuthGithubMapUsersKey(ctx context.Context, key string) (*http.Response, error) {
	requestPath := "/v1/auth/github/map/users/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthJwtConfig Read the current JWT authentication backend configuration.
func (a *Auth) GetAuthJwtConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/jwt/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthJwtOidcCallback Callback endpoint to complete an OIDC login.
func (a *Auth) GetAuthJwtOidcCallback(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/jwt/oidc/callback"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthJwtRole Lists all the roles registered with the backend.
// The list will contain the names of the roles.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthJwtRole(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/jwt/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthJwtRoleName Read an existing role.
// name: Name of the role.
func (a *Auth) GetAuthJwtRoleName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/jwt/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthKerberosConfig
func (a *Auth) GetAuthKerberosConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/kerberos/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthKerberosConfigLdap
func (a *Auth) GetAuthKerberosConfigLdap(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/kerberos/config/ldap"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthKerberosGroups
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthKerberosGroups(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/kerberos/groups"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthKerberosGroupsName
// name: Name of the LDAP group.
func (a *Auth) GetAuthKerberosGroupsName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/kerberos/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthKerberosLogin
func (a *Auth) GetAuthKerberosLogin(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/kerberos/login"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthKubernetesConfig Configures the JWT Public Key and Kubernetes API information.
func (a *Auth) GetAuthKubernetesConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/kubernetes/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthKubernetesRole Lists all the roles registered with the backend.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthKubernetesRole(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/kubernetes/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthKubernetesRoleName Register an role with the backend.
// name: Name of the role.
func (a *Auth) GetAuthKubernetesRoleName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/kubernetes/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthLdapConfig Configure the LDAP server to connect to, along with its options.
func (a *Auth) GetAuthLdapConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/ldap/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthLdapGroups Manage additional groups for users allowed to authenticate.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthLdapGroups(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/ldap/groups"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthLdapGroupsName Manage additional groups for users allowed to authenticate.
// name: Name of the LDAP group.
func (a *Auth) GetAuthLdapGroupsName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/ldap/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthLdapUsers Manage users allowed to authenticate.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthLdapUsers(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/ldap/users"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthLdapUsersName Manage users allowed to authenticate.
// name: Name of the LDAP user.
func (a *Auth) GetAuthLdapUsersName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/ldap/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthOciConfig Manages the configuration for the Vault Auth Plugin.
func (a *Auth) GetAuthOciConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/oci/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthOciRole Lists all the roles that are registered with Vault.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthOciRole(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/oci/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthOciRoleRole Create a role and associate policies to it.
// role: Name of the role.
func (a *Auth) GetAuthOciRoleRole(ctx context.Context, role string) (*http.Response, error) {
	requestPath := "/v1/auth/oci/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthOidcConfig Read the current JWT authentication backend configuration.
func (a *Auth) GetAuthOidcConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/oidc/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthOidcOidcCallback Callback endpoint to complete an OIDC login.
func (a *Auth) GetAuthOidcOidcCallback(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/oidc/oidc/callback"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthOidcRole Lists all the roles registered with the backend.
// The list will contain the names of the roles.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthOidcRole(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/oidc/role"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthOidcRoleName Read an existing role.
// name: Name of the role.
func (a *Auth) GetAuthOidcRoleName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/oidc/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthOktaConfig This endpoint allows you to configure the Okta and its configuration options.  The Okta organization are the characters at the front of the URL for Okta. Example https://ORG.okta.com
func (a *Auth) GetAuthOktaConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/okta/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthOktaGroups Manage users allowed to authenticate.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthOktaGroups(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/okta/groups"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthOktaGroupsName Manage users allowed to authenticate.
// name: Name of the Okta group.
func (a *Auth) GetAuthOktaGroupsName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/okta/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthOktaUsers Manage additional groups for users allowed to authenticate.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthOktaUsers(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/okta/users"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthOktaUsersName Manage additional groups for users allowed to authenticate.
// name: Name of the user.
func (a *Auth) GetAuthOktaUsersName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/okta/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthOktaVerifyNonce
// nonce: Nonce provided during a login request to retrieve the number verification challenge for the matching request.
func (a *Auth) GetAuthOktaVerifyNonce(ctx context.Context, nonce string) (*http.Response, error) {
	requestPath := "/v1/auth/okta/verify/{nonce}"
	requestPath = strings.Replace(requestPath, "{"+"nonce"+"}", url.PathEscape(nonce), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthRadiusConfig Configure the RADIUS server to connect to, along with its options.
func (a *Auth) GetAuthRadiusConfig(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/radius/config"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthRadiusUsers Manage users allowed to authenticate.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthRadiusUsers(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/radius/users"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthRadiusUsersName Manage users allowed to authenticate.
// name: Name of the RADIUS user.
func (a *Auth) GetAuthRadiusUsersName(ctx context.Context, name string) (*http.Response, error) {
	requestPath := "/v1/auth/radius/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthTokenAccessors List token accessors, which can then be be used to iterate and discover their properties or revoke them. Because this can be used to cause a denial of service, this endpoint requires 'sudo' capability in addition to 'list'.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthTokenAccessors(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/token/accessors/"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthTokenLookup This endpoint will lookup a token and its properties.
func (a *Auth) GetAuthTokenLookup(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/token/lookup"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthTokenLookupSelf This endpoint will lookup a token and its properties.
func (a *Auth) GetAuthTokenLookupSelf(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/token/lookup-self"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthTokenRoles This endpoint lists configured roles.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthTokenRoles(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/token/roles"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthTokenRolesRoleName
// roleName: Name of the role
func (a *Auth) GetAuthTokenRolesRoleName(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/token/roles/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthUserpassUsers Manage users allowed to authenticate.
// list: Must be set to &#x60;true&#x60;
func (a *Auth) GetAuthUserpassUsers(ctx context.Context, list string) (*http.Response, error) {
	requestPath := "/v1/auth/userpass/users"

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// GetAuthUserpassUsersUsername Manage users allowed to authenticate.
// username: Username for this user.
func (a *Auth) GetAuthUserpassUsersUsername(ctx context.Context, username string) (*http.Response, error) {
	requestPath := "/v1/auth/userpass/users/{username}"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newRequest(ctx, http.MethodGet, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAlicloudLogin Authenticates an RAM entity with Vault.
func (a *Auth) PostAuthAlicloudLogin(ctx context.Context, alicloudLoginRequest AlicloudLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/alicloud/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, alicloudLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAlicloudRoleRole Create a role and associate policies to it.
// role: The name of the role as it should appear in Vault.
func (a *Auth) PostAuthAlicloudRoleRole(ctx context.Context, role string, alicloudRoleRequest AlicloudRoleRequest) (*http.Response, error) {
	requestPath := "/v1/auth/alicloud/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, alicloudRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAppIdLogin Log in with an App ID and User ID.
func (a *Auth) PostAuthAppIdLogin(ctx context.Context, appIdLoginRequest AppIdLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/app-id/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, appIdLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAppIdLoginAppId Log in with an App ID and User ID.
// appId: The unique app ID
func (a *Auth) PostAuthAppIdLoginAppId(ctx context.Context, appId string, appIdLoginRequest AppIdLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/app-id/login/{app_id}"
	requestPath = strings.Replace(requestPath, "{"+"app_id"+"}", url.PathEscape(appId), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, appIdLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAppIdMapAppIdKey Read/write/delete a single app-id mapping
// key: Key for the app-id mapping
func (a *Auth) PostAuthAppIdMapAppIdKey(ctx context.Context, key string, appIdMapAppIdRequest AppIdMapAppIdRequest) (*http.Response, error) {
	requestPath := "/v1/auth/app-id/map/app-id/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, appIdMapAppIdRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAppIdMapUserIdKey Read/write/delete a single user-id mapping
// key: Key for the user-id mapping
func (a *Auth) PostAuthAppIdMapUserIdKey(ctx context.Context, key string, appIdMapUserIdRequest AppIdMapUserIdRequest) (*http.Response, error) {
	requestPath := "/v1/auth/app-id/map/user-id/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, appIdMapUserIdRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleLogin
func (a *Auth) PostAuthApproleLogin(ctx context.Context, approleLoginRequest ApproleLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleName Register an role with the backend.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleName(ctx context.Context, roleName string, approleRoleRequest ApproleRoleRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameBindSecretId Impose secret_id to be presented during login using this role.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameBindSecretId(ctx context.Context, roleName string, approleRoleBindSecretIdRequest ApproleRoleBindSecretIdRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/bind-secret-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleBindSecretIdRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameBoundCidrList Deprecated: Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameBoundCidrList(ctx context.Context, roleName string, approleRoleBoundCidrListRequest ApproleRoleBoundCidrListRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/bound-cidr-list"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleBoundCidrListRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameCustomSecretId Assign a SecretID of choice against the role.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameCustomSecretId(ctx context.Context, roleName string, approleRoleCustomSecretIdRequest ApproleRoleCustomSecretIdRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/custom-secret-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleCustomSecretIdRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNamePeriod Updates the value of 'period' on the role
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNamePeriod(ctx context.Context, roleName string, approleRolePeriodRequest ApproleRolePeriodRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/period"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRolePeriodRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNamePolicies Policies of the role.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNamePolicies(ctx context.Context, roleName string, approleRolePoliciesRequest ApproleRolePoliciesRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/policies"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRolePoliciesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameRoleId Returns the 'role_id' of the role.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameRoleId(ctx context.Context, roleName string, approleRoleRoleIdRequest ApproleRoleRoleIdRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/role-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleRoleIdRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameSecretId Generate a SecretID against this role.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretId(ctx context.Context, roleName string, approleRoleSecretIdRequest ApproleRoleSecretIdRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameSecretIdAccessorDestroy
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdAccessorDestroy(ctx context.Context, roleName string, approleRoleSecretIdAccessorDestroyRequest ApproleRoleSecretIdAccessorDestroyRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-accessor/destroy"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdAccessorDestroyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameSecretIdAccessorLookup
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdAccessorLookup(ctx context.Context, roleName string, approleRoleSecretIdAccessorLookupRequest ApproleRoleSecretIdAccessorLookupRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-accessor/lookup"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdAccessorLookupRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameSecretIdBoundCidrs Comma separated list of CIDR blocks, if set, specifies blocks of IP addresses which can perform the login operation
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdBoundCidrs(ctx context.Context, roleName string, approleRoleSecretIdBoundCidrsRequest ApproleRoleSecretIdBoundCidrsRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-bound-cidrs"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdBoundCidrsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameSecretIdDestroy Invalidate an issued secret_id
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdDestroy(ctx context.Context, roleName string, approleRoleSecretIdDestroyRequest ApproleRoleSecretIdDestroyRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id/destroy"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdDestroyRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameSecretIdLookup Read the properties of an issued secret_id
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdLookup(ctx context.Context, roleName string, approleRoleSecretIdLookupRequest ApproleRoleSecretIdLookupRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id/lookup"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdLookupRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameSecretIdNumUses Use limit of the SecretID generated against the role.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdNumUses(ctx context.Context, roleName string, approleRoleSecretIdNumUsesRequest ApproleRoleSecretIdNumUsesRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-num-uses"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdNumUsesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameSecretIdTtl Duration in seconds, representing the lifetime of the SecretIDs that are generated against the role using 'role/<role_name>/secret-id' or 'role/<role_name>/custom-secret-id' endpoints.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameSecretIdTtl(ctx context.Context, roleName string, approleRoleSecretIdTtlRequest ApproleRoleSecretIdTtlRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/secret-id-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleSecretIdTtlRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameTokenBoundCidrs Comma separated string or list of CIDR blocks. If set, specifies the blocks of IP addresses which can use the returned token.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameTokenBoundCidrs(ctx context.Context, roleName string, approleRoleTokenBoundCidrsRequest ApproleRoleTokenBoundCidrsRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-bound-cidrs"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleTokenBoundCidrsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameTokenMaxTtl Duration in seconds, the maximum lifetime of the tokens issued by using the SecretIDs that were generated against this role, after which the tokens are not allowed to be renewed.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameTokenMaxTtl(ctx context.Context, roleName string, approleRoleTokenMaxTtlRequest ApproleRoleTokenMaxTtlRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-max-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleTokenMaxTtlRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameTokenNumUses Number of times issued tokens can be used
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameTokenNumUses(ctx context.Context, roleName string, approleRoleTokenNumUsesRequest ApproleRoleTokenNumUsesRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-num-uses"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleTokenNumUsesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleRoleRoleNameTokenTtl Duration in seconds, the lifetime of the token issued by using the SecretID that is generated against this role, before which the token needs to be renewed.
// roleName: Name of the role.
func (a *Auth) PostAuthApproleRoleRoleNameTokenTtl(ctx context.Context, roleName string, approleRoleTokenTtlRequest ApproleRoleTokenTtlRequest) (*http.Response, error) {
	requestPath := "/v1/auth/approle/role/{role_name}/token-ttl"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, approleRoleTokenTtlRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthApproleTidySecretId Trigger the clean-up of expired SecretID entries.
func (a *Auth) PostAuthApproleTidySecretId(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/approle/tidy/secret-id"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsConfigCertificateCertName
// certName: Name of the certificate.
func (a *Auth) PostAuthAwsConfigCertificateCertName(ctx context.Context, certName string, awsConfigCertificateRequest AwsConfigCertificateRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/certificate/{cert_name}"
	requestPath = strings.Replace(requestPath, "{"+"cert_name"+"}", url.PathEscape(certName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigCertificateRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsConfigClient
func (a *Auth) PostAuthAwsConfigClient(ctx context.Context, awsConfigClientRequest AwsConfigClientRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/client"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigClientRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsConfigIdentity
func (a *Auth) PostAuthAwsConfigIdentity(ctx context.Context, awsConfigIdentityRequest AwsConfigIdentityRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/identity"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigIdentityRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsConfigRotateRoot
func (a *Auth) PostAuthAwsConfigRotateRoot(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/rotate-root"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsConfigStsAccountId
// accountId: AWS account ID to be associated with STS role. If set, Vault will use assumed credentials to verify any login attempts from EC2 instances in this account.
func (a *Auth) PostAuthAwsConfigStsAccountId(ctx context.Context, accountId string, awsConfigStsRequest AwsConfigStsRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/sts/{account_id}"
	requestPath = strings.Replace(requestPath, "{"+"account_id"+"}", url.PathEscape(accountId), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigStsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsConfigTidyIdentityAccesslist
func (a *Auth) PostAuthAwsConfigTidyIdentityAccesslist(ctx context.Context, awsConfigTidyIdentityAccesslistRequest AwsConfigTidyIdentityAccesslistRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/tidy/identity-accesslist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigTidyIdentityAccesslistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsConfigTidyIdentityWhitelist
func (a *Auth) PostAuthAwsConfigTidyIdentityWhitelist(ctx context.Context, awsConfigTidyIdentityWhitelistRequest AwsConfigTidyIdentityWhitelistRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/tidy/identity-whitelist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigTidyIdentityWhitelistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsConfigTidyRoletagBlacklist
func (a *Auth) PostAuthAwsConfigTidyRoletagBlacklist(ctx context.Context, awsConfigTidyRoletagBlacklistRequest AwsConfigTidyRoletagBlacklistRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/tidy/roletag-blacklist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigTidyRoletagBlacklistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsConfigTidyRoletagDenylist
func (a *Auth) PostAuthAwsConfigTidyRoletagDenylist(ctx context.Context, awsConfigTidyRoletagDenylistRequest AwsConfigTidyRoletagDenylistRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/config/tidy/roletag-denylist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsConfigTidyRoletagDenylistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsLogin
func (a *Auth) PostAuthAwsLogin(ctx context.Context, awsLoginRequest AwsLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsRoleRole
// role: Name of the role.
func (a *Auth) PostAuthAwsRoleRole(ctx context.Context, role string, awsRoleRequest AwsRoleRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsRoleRoleTag
// role: Name of the role.
func (a *Auth) PostAuthAwsRoleRoleTag(ctx context.Context, role string, awsRoleTagRequest AwsRoleTagRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/role/{role}/tag"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsRoleTagRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsRoletagBlacklistRoleTag
// roleTag: Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.
func (a *Auth) PostAuthAwsRoletagBlacklistRoleTag(ctx context.Context, roleTag string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/roletag-blacklist/{role_tag}"
	requestPath = strings.Replace(requestPath, "{"+"role_tag"+"}", url.PathEscape(roleTag), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsRoletagDenylistRoleTag
// roleTag: Role tag to be deny listed. The tag can be supplied as-is. In order to avoid any encoding problems, it can be base64 encoded.
func (a *Auth) PostAuthAwsRoletagDenylistRoleTag(ctx context.Context, roleTag string) (*http.Response, error) {
	requestPath := "/v1/auth/aws/roletag-denylist/{role_tag}"
	requestPath = strings.Replace(requestPath, "{"+"role_tag"+"}", url.PathEscape(roleTag), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsTidyIdentityAccesslist
func (a *Auth) PostAuthAwsTidyIdentityAccesslist(ctx context.Context, awsTidyIdentityAccesslistRequest AwsTidyIdentityAccesslistRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/tidy/identity-accesslist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsTidyIdentityAccesslistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsTidyIdentityWhitelist
func (a *Auth) PostAuthAwsTidyIdentityWhitelist(ctx context.Context, awsTidyIdentityWhitelistRequest AwsTidyIdentityWhitelistRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/tidy/identity-whitelist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsTidyIdentityWhitelistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsTidyRoletagBlacklist
func (a *Auth) PostAuthAwsTidyRoletagBlacklist(ctx context.Context, awsTidyRoletagBlacklistRequest AwsTidyRoletagBlacklistRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/tidy/roletag-blacklist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsTidyRoletagBlacklistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAwsTidyRoletagDenylist
func (a *Auth) PostAuthAwsTidyRoletagDenylist(ctx context.Context, awsTidyRoletagDenylistRequest AwsTidyRoletagDenylistRequest) (*http.Response, error) {
	requestPath := "/v1/auth/aws/tidy/roletag-denylist"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, awsTidyRoletagDenylistRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAzureConfig
func (a *Auth) PostAuthAzureConfig(ctx context.Context, azureConfigRequest AzureConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/azure/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, azureConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAzureLogin
func (a *Auth) PostAuthAzureLogin(ctx context.Context, azureLoginRequest AzureLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/azure/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, azureLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthAzureRoleName
// name: Name of the role.
func (a *Auth) PostAuthAzureRoleName(ctx context.Context, name string, azureRoleRequest AzureRoleRequest) (*http.Response, error) {
	requestPath := "/v1/auth/azure/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, azureRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthCentrifyConfig This path allows you to configure the centrify auth provider to interact with the Centrify Identity Services Platform for authenticating users.
func (a *Auth) PostAuthCentrifyConfig(ctx context.Context, centrifyConfigRequest CentrifyConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/centrify/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, centrifyConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthCentrifyLogin Log in with a username and password.
func (a *Auth) PostAuthCentrifyLogin(ctx context.Context, centrifyLoginRequest CentrifyLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/centrify/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, centrifyLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthCertCertsName Manage trusted certificates used for authentication.
// name: The name of the certificate
func (a *Auth) PostAuthCertCertsName(ctx context.Context, name string, certCertsRequest CertCertsRequest) (*http.Response, error) {
	requestPath := "/v1/auth/cert/certs/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, certCertsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthCertConfig
func (a *Auth) PostAuthCertConfig(ctx context.Context, certConfigRequest CertConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/cert/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, certConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthCertCrlsName Manage Certificate Revocation Lists checked during authentication.
// name: The name of the certificate
func (a *Auth) PostAuthCertCrlsName(ctx context.Context, name string, certCrlsRequest CertCrlsRequest) (*http.Response, error) {
	requestPath := "/v1/auth/cert/crls/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, certCrlsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthCertLogin
func (a *Auth) PostAuthCertLogin(ctx context.Context, certLoginRequest CertLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/cert/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, certLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthCfConfig
func (a *Auth) PostAuthCfConfig(ctx context.Context, cfConfigRequest CfConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/cf/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, cfConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthCfLogin
func (a *Auth) PostAuthCfLogin(ctx context.Context, cfLoginRequest CfLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/cf/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, cfLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthCfRolesRole
// role: The name of the role.
func (a *Auth) PostAuthCfRolesRole(ctx context.Context, role string, cfRolesRequest CfRolesRequest) (*http.Response, error) {
	requestPath := "/v1/auth/cf/roles/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, cfRolesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthGcpConfig Configure credentials used to query the GCP IAM API to verify authenticating service accounts
func (a *Auth) PostAuthGcpConfig(ctx context.Context, gcpConfigRequest GcpConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/gcp/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthGcpLogin
func (a *Auth) PostAuthGcpLogin(ctx context.Context, gcpLoginRequest GcpLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/gcp/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthGcpRoleName Create a GCP role with associated policies and required attributes.
// name: Name of the role.
func (a *Auth) PostAuthGcpRoleName(ctx context.Context, name string, gcpRoleRequest GcpRoleRequest) (*http.Response, error) {
	requestPath := "/v1/auth/gcp/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthGcpRoleNameLabels Add or remove labels for an existing 'gce' role
// name: Name of the role.
func (a *Auth) PostAuthGcpRoleNameLabels(ctx context.Context, name string, gcpRoleLabelsRequest GcpRoleLabelsRequest) (*http.Response, error) {
	requestPath := "/v1/auth/gcp/role/{name}/labels"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpRoleLabelsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthGcpRoleNameServiceAccounts Add or remove service accounts for an existing `iam` role
// name: Name of the role.
func (a *Auth) PostAuthGcpRoleNameServiceAccounts(ctx context.Context, name string, gcpRoleServiceAccountsRequest GcpRoleServiceAccountsRequest) (*http.Response, error) {
	requestPath := "/v1/auth/gcp/role/{name}/service-accounts"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, gcpRoleServiceAccountsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthGithubConfig
func (a *Auth) PostAuthGithubConfig(ctx context.Context, githubConfigRequest GithubConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/github/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, githubConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthGithubLogin
func (a *Auth) PostAuthGithubLogin(ctx context.Context, githubLoginRequest GithubLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/github/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, githubLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthGithubMapTeamsKey Read/write/delete a single teams mapping
// key: Key for the teams mapping
func (a *Auth) PostAuthGithubMapTeamsKey(ctx context.Context, key string, githubMapTeamsRequest GithubMapTeamsRequest) (*http.Response, error) {
	requestPath := "/v1/auth/github/map/teams/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, githubMapTeamsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthGithubMapUsersKey Read/write/delete a single users mapping
// key: Key for the users mapping
func (a *Auth) PostAuthGithubMapUsersKey(ctx context.Context, key string, githubMapUsersRequest GithubMapUsersRequest) (*http.Response, error) {
	requestPath := "/v1/auth/github/map/users/{key}"
	requestPath = strings.Replace(requestPath, "{"+"key"+"}", url.PathEscape(key), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, githubMapUsersRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthJwtConfig Configure the JWT authentication backend.
// The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
func (a *Auth) PostAuthJwtConfig(ctx context.Context, jwtConfigRequest JwtConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/jwt/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, jwtConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthJwtLogin Authenticates to Vault using a JWT (or OIDC) token.
func (a *Auth) PostAuthJwtLogin(ctx context.Context, jwtLoginRequest JwtLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/jwt/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, jwtLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthJwtOidcAuthUrl Request an authorization URL to start an OIDC login flow.
func (a *Auth) PostAuthJwtOidcAuthUrl(ctx context.Context, jwtOidcAuthUrlRequest JwtOidcAuthUrlRequest) (*http.Response, error) {
	requestPath := "/v1/auth/jwt/oidc/auth_url"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, jwtOidcAuthUrlRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthJwtOidcCallback Callback endpoint to handle form_posts.
func (a *Auth) PostAuthJwtOidcCallback(ctx context.Context, jwtOidcCallbackRequest JwtOidcCallbackRequest) (*http.Response, error) {
	requestPath := "/v1/auth/jwt/oidc/callback"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, jwtOidcCallbackRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthJwtRoleName Register an role with the backend.
// A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
// name: Name of the role.
func (a *Auth) PostAuthJwtRoleName(ctx context.Context, name string, jwtRoleRequest JwtRoleRequest) (*http.Response, error) {
	requestPath := "/v1/auth/jwt/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, jwtRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthKerberosConfig
func (a *Auth) PostAuthKerberosConfig(ctx context.Context, kerberosConfigRequest KerberosConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/kerberos/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kerberosConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthKerberosConfigLdap
func (a *Auth) PostAuthKerberosConfigLdap(ctx context.Context, kerberosConfigLdapRequest KerberosConfigLdapRequest) (*http.Response, error) {
	requestPath := "/v1/auth/kerberos/config/ldap"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kerberosConfigLdapRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthKerberosGroupsName
// name: Name of the LDAP group.
func (a *Auth) PostAuthKerberosGroupsName(ctx context.Context, name string, kerberosGroupsRequest KerberosGroupsRequest) (*http.Response, error) {
	requestPath := "/v1/auth/kerberos/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kerberosGroupsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthKerberosLogin
func (a *Auth) PostAuthKerberosLogin(ctx context.Context, kerberosLoginRequest KerberosLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/kerberos/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kerberosLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthKubernetesConfig Configures the JWT Public Key and Kubernetes API information.
func (a *Auth) PostAuthKubernetesConfig(ctx context.Context, kubernetesConfigRequest KubernetesConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/kubernetes/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kubernetesConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthKubernetesLogin Authenticates Kubernetes service accounts with Vault.
func (a *Auth) PostAuthKubernetesLogin(ctx context.Context, kubernetesLoginRequest KubernetesLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/kubernetes/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kubernetesLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthKubernetesRoleName Register an role with the backend.
// name: Name of the role.
func (a *Auth) PostAuthKubernetesRoleName(ctx context.Context, name string, kubernetesRoleRequest KubernetesRoleRequest) (*http.Response, error) {
	requestPath := "/v1/auth/kubernetes/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, kubernetesRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthLdapConfig Configure the LDAP server to connect to, along with its options.
func (a *Auth) PostAuthLdapConfig(ctx context.Context, ldapConfigRequest LdapConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/ldap/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ldapConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthLdapGroupsName Manage additional groups for users allowed to authenticate.
// name: Name of the LDAP group.
func (a *Auth) PostAuthLdapGroupsName(ctx context.Context, name string, ldapGroupsRequest LdapGroupsRequest) (*http.Response, error) {
	requestPath := "/v1/auth/ldap/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ldapGroupsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthLdapLoginUsername Log in with a username and password.
// username: DN (distinguished name) to be used for login.
func (a *Auth) PostAuthLdapLoginUsername(ctx context.Context, username string, ldapLoginRequest LdapLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/ldap/login/{username}"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ldapLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthLdapUsersName Manage users allowed to authenticate.
// name: Name of the LDAP user.
func (a *Auth) PostAuthLdapUsersName(ctx context.Context, name string, ldapUsersRequest LdapUsersRequest) (*http.Response, error) {
	requestPath := "/v1/auth/ldap/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ldapUsersRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthOciConfig Manages the configuration for the Vault Auth Plugin.
func (a *Auth) PostAuthOciConfig(ctx context.Context, ociConfigRequest OciConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/oci/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ociConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthOciLoginRole Authenticates to Vault using OCI credentials
// role: Name of the role.
func (a *Auth) PostAuthOciLoginRole(ctx context.Context, role string, ociLoginRequest OciLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/oci/login/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ociLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthOciRoleRole Create a role and associate policies to it.
// role: Name of the role.
func (a *Auth) PostAuthOciRoleRole(ctx context.Context, role string, ociRoleRequest OciRoleRequest) (*http.Response, error) {
	requestPath := "/v1/auth/oci/role/{role}"
	requestPath = strings.Replace(requestPath, "{"+"role"+"}", url.PathEscape(role), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, ociRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthOidcConfig Configure the JWT authentication backend.
// The JWT authentication backend validates JWTs (or OIDC) using the configured credentials. If using OIDC Discovery, the URL must be provided, along with (optionally) the CA cert to use for the connection. If performing JWT validation locally, a set of public keys must be provided.
func (a *Auth) PostAuthOidcConfig(ctx context.Context, oidcConfigRequest OidcConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/oidc/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oidcConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthOidcLogin Authenticates to Vault using a JWT (or OIDC) token.
func (a *Auth) PostAuthOidcLogin(ctx context.Context, oidcLoginRequest OidcLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/oidc/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oidcLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthOidcOidcAuthUrl Request an authorization URL to start an OIDC login flow.
func (a *Auth) PostAuthOidcOidcAuthUrl(ctx context.Context, oidcOidcAuthUrlRequest OidcOidcAuthUrlRequest) (*http.Response, error) {
	requestPath := "/v1/auth/oidc/oidc/auth_url"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oidcOidcAuthUrlRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthOidcOidcCallback Callback endpoint to handle form_posts.
func (a *Auth) PostAuthOidcOidcCallback(ctx context.Context, oidcOidcCallbackRequest OidcOidcCallbackRequest) (*http.Response, error) {
	requestPath := "/v1/auth/oidc/oidc/callback"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oidcOidcCallbackRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthOidcRoleName Register an role with the backend.
// A role is required to authenticate with this backend. The role binds   JWT token information with token policies and settings.   The bindings, token polices and token settings can all be configured   using this endpoint
// name: Name of the role.
func (a *Auth) PostAuthOidcRoleName(ctx context.Context, name string, oidcRoleRequest OidcRoleRequest) (*http.Response, error) {
	requestPath := "/v1/auth/oidc/role/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oidcRoleRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthOktaConfig This endpoint allows you to configure the Okta and its configuration options.  The Okta organization are the characters at the front of the URL for Okta. Example https://ORG.okta.com
func (a *Auth) PostAuthOktaConfig(ctx context.Context, oktaConfigRequest OktaConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/okta/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oktaConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthOktaGroupsName Manage users allowed to authenticate.
// name: Name of the Okta group.
func (a *Auth) PostAuthOktaGroupsName(ctx context.Context, name string, oktaGroupsRequest OktaGroupsRequest) (*http.Response, error) {
	requestPath := "/v1/auth/okta/groups/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oktaGroupsRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthOktaLoginUsername Log in with a username and password.
// username: Username to be used for login.
func (a *Auth) PostAuthOktaLoginUsername(ctx context.Context, username string, oktaLoginRequest OktaLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/okta/login/{username}"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oktaLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthOktaUsersName Manage additional groups for users allowed to authenticate.
// name: Name of the user.
func (a *Auth) PostAuthOktaUsersName(ctx context.Context, name string, oktaUsersRequest OktaUsersRequest) (*http.Response, error) {
	requestPath := "/v1/auth/okta/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, oktaUsersRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthRadiusConfig Configure the RADIUS server to connect to, along with its options.
func (a *Auth) PostAuthRadiusConfig(ctx context.Context, radiusConfigRequest RadiusConfigRequest) (*http.Response, error) {
	requestPath := "/v1/auth/radius/config"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, radiusConfigRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthRadiusLogin Log in with a username and password.
func (a *Auth) PostAuthRadiusLogin(ctx context.Context, radiusLoginRequest RadiusLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/radius/login"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, radiusLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthRadiusLoginUrlusername Log in with a username and password.
// urlusername: Username to be used for login. (URL parameter)
func (a *Auth) PostAuthRadiusLoginUrlusername(ctx context.Context, urlusername string, radiusLoginRequest RadiusLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/radius/login/{urlusername}"
	requestPath = strings.Replace(requestPath, "{"+"urlusername"+"}", url.PathEscape(urlusername), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, radiusLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthRadiusUsersName Manage users allowed to authenticate.
// name: Name of the RADIUS user.
func (a *Auth) PostAuthRadiusUsersName(ctx context.Context, name string, radiusUsersRequest RadiusUsersRequest) (*http.Response, error) {
	requestPath := "/v1/auth/radius/users/{name}"
	requestPath = strings.Replace(requestPath, "{"+"name"+"}", url.PathEscape(name), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, radiusUsersRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenCreate The token create path is used to create new tokens.
func (a *Auth) PostAuthTokenCreate(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/token/create"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenCreateOrphan The token create path is used to create new orphan tokens.
func (a *Auth) PostAuthTokenCreateOrphan(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/token/create-orphan"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenCreateRoleName This token create path is used to create new tokens adhering to the given role.
// roleName: Name of the role
func (a *Auth) PostAuthTokenCreateRoleName(ctx context.Context, roleName string) (*http.Response, error) {
	requestPath := "/v1/auth/token/create/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenLookup This endpoint will lookup a token and its properties.
func (a *Auth) PostAuthTokenLookup(ctx context.Context, tokenLookupRequest TokenLookupRequest) (*http.Response, error) {
	requestPath := "/v1/auth/token/lookup"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenLookupRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenLookupAccessor This endpoint will lookup a token associated with the given accessor and its properties. Response will not contain the token ID.
func (a *Auth) PostAuthTokenLookupAccessor(ctx context.Context, tokenLookupAccessorRequest TokenLookupAccessorRequest) (*http.Response, error) {
	requestPath := "/v1/auth/token/lookup-accessor"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenLookupAccessorRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenLookupSelf This endpoint will lookup a token and its properties.
func (a *Auth) PostAuthTokenLookupSelf(ctx context.Context, tokenLookupSelfRequest TokenLookupSelfRequest) (*http.Response, error) {
	requestPath := "/v1/auth/token/lookup-self"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenLookupSelfRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenRenew This endpoint will renew the given token and prevent expiration.
func (a *Auth) PostAuthTokenRenew(ctx context.Context, tokenRenewRequest TokenRenewRequest) (*http.Response, error) {
	requestPath := "/v1/auth/token/renew"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRenewRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenRenewAccessor This endpoint will renew a token associated with the given accessor and its properties. Response will not contain the token ID.
func (a *Auth) PostAuthTokenRenewAccessor(ctx context.Context, tokenRenewAccessorRequest TokenRenewAccessorRequest) (*http.Response, error) {
	requestPath := "/v1/auth/token/renew-accessor"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRenewAccessorRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenRenewSelf This endpoint will renew the token used to call it and prevent expiration.
func (a *Auth) PostAuthTokenRenewSelf(ctx context.Context, tokenRenewSelfRequest TokenRenewSelfRequest) (*http.Response, error) {
	requestPath := "/v1/auth/token/renew-self"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRenewSelfRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenRevoke This endpoint will delete the given token and all of its child tokens.
func (a *Auth) PostAuthTokenRevoke(ctx context.Context, tokenRevokeRequest TokenRevokeRequest) (*http.Response, error) {
	requestPath := "/v1/auth/token/revoke"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRevokeRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenRevokeAccessor This endpoint will delete the token associated with the accessor and all of its child tokens.
func (a *Auth) PostAuthTokenRevokeAccessor(ctx context.Context, tokenRevokeAccessorRequest TokenRevokeAccessorRequest) (*http.Response, error) {
	requestPath := "/v1/auth/token/revoke-accessor"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRevokeAccessorRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenRevokeOrphan This endpoint will delete the token and orphan its child tokens.
func (a *Auth) PostAuthTokenRevokeOrphan(ctx context.Context, tokenRevokeOrphanRequest TokenRevokeOrphanRequest) (*http.Response, error) {
	requestPath := "/v1/auth/token/revoke-orphan"

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRevokeOrphanRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenRevokeSelf This endpoint will delete the token used to call it and all of its child tokens.
func (a *Auth) PostAuthTokenRevokeSelf(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/token/revoke-self"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenRolesRoleName
// roleName: Name of the role
func (a *Auth) PostAuthTokenRolesRoleName(ctx context.Context, roleName string, tokenRolesRequest TokenRolesRequest) (*http.Response, error) {
	requestPath := "/v1/auth/token/roles/{role_name}"
	requestPath = strings.Replace(requestPath, "{"+"role_name"+"}", url.PathEscape(roleName), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, tokenRolesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthTokenTidy This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.
func (a *Auth) PostAuthTokenTidy(ctx context.Context) (*http.Response, error) {
	requestPath := "/v1/auth/token/tidy"

	req, err := a.client.newRequest(ctx, http.MethodPost, requestPath, nil)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthUserpassLoginUsername Log in with a username and password.
// username: Username of the user.
func (a *Auth) PostAuthUserpassLoginUsername(ctx context.Context, username string, userpassLoginRequest UserpassLoginRequest) (*http.Response, error) {
	requestPath := "/v1/auth/userpass/login/{username}"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, userpassLoginRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthUserpassUsersUsername Manage users allowed to authenticate.
// username: Username for this user.
func (a *Auth) PostAuthUserpassUsersUsername(ctx context.Context, username string, userpassUsersRequest UserpassUsersRequest) (*http.Response, error) {
	requestPath := "/v1/auth/userpass/users/{username}"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, userpassUsersRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthUserpassUsersUsernamePassword Reset user's password.
// username: Username for this user.
func (a *Auth) PostAuthUserpassUsersUsernamePassword(ctx context.Context, username string, userpassUsersPasswordRequest UserpassUsersPasswordRequest) (*http.Response, error) {
	requestPath := "/v1/auth/userpass/users/{username}/password"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, userpassUsersPasswordRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}

// PostAuthUserpassUsersUsernamePolicies Update the policies associated with the username.
// username: Username for this user.
func (a *Auth) PostAuthUserpassUsersUsernamePolicies(ctx context.Context, username string, userpassUsersPoliciesRequest UserpassUsersPoliciesRequest) (*http.Response, error) {
	requestPath := "/v1/auth/userpass/users/{username}/policies"
	requestPath = strings.Replace(requestPath, "{"+"username"+"}", url.PathEscape(username), -1)

	req, err := a.client.newStructuredRequest(ctx, http.MethodPost, requestPath, userpassUsersPoliciesRequest)
	if err != nil {
		return nil, err
	}

	resp, err := a.client.do(ctx, req, true)
	if err != nil || resp == nil {
		return resp, err
	}

	return resp, nil
}
